---
title: |
  Применение программно управляемой отладки при разработке виртуальной \
  вычислительной машины для Qemu
author:
- Ефимов В.Ю. &lt;real@ispras.ru>
- Колтунов Д.С. &lt;koltunov@ipsras.ru>
tags: []
abstract: |
  <br>

  **Аннотация.**
  Разработка виртуальных устройств и машин для QEMU --- трудоёмкий процесс.
  Ранее были проведены работы, нацеленные на автоматизацию начального этапа
  этого процесса.
  Результатом тех работы был набор инструментов с открытым исходным кодом
  QEMU Development Toolkit (QDT).
  Однако наибольшая часть времени уходит на итеративную часть разработки,
  в течение которой отладка и корректировка машины циклически следуют друг за
  другом.
  Данная работа нацелена на автоматизацию отладки за счёт применения
  разработанного программно управляемого отладчика.
  Автоматизации подвергается сбор информации с самого начала выполнения
  эмулятора для получения более подробной информации о происходящих в Qemu
  активностях.
  Предусмотрено графическое отображение отлаживаемой виртуальной машины.
  Программы управления отладкой (отладочные скрипты) пишутся на языке Python с
  использованием предоставляемого отладчиком API.
  Разработанные скрипты пригодны как для машин, полученных с использованием QDT,
  так для машин, реализованных классическим способом.
  Исходный код разработанного инструмента доступен по адресу
  https://github.com/ispras/qdt.

  <br>

  *Работа поддержана грантом РФФИ No 16-29-09632*.

  <br>

  **Ключевые слова**:
  Qemu;
  программно управляемая отладка;
  QDT;
  GDB RSP
...

# $. Введение

Виртуальные вычислительные машины применяются для решения разнообразных задач:
включая исследования в рамках информационной безопасности.
Одной из задач является организация контролируемого окружения для исследуемого
машинного кода во время динамического анализа.
Устоявшийся подход совмещает дизассемблер IDA Pro и интерактивную отладку,
когда сервером удалённой отладки выступает эмулятор.
Эмулятор даёт дополнительный "рубеж" изоляции между исследуемым кодом и
инструментами анализа.
Поэтому он хорошо подходит для исследования компьютерных вирусов и другого
вредоносного ПО.

Эмулятор Qemu наиболее подходит для этой цели, поскольку обладает рядом
полезных свойств: полностью открытый исходный код (лицензия GPL), поддержка
разнообразных гостевых архитектур (Intel x86, AMD 64, ARM, MIPS, PowerPC, SPARC
и др.), реализация важных, с точки зрения динамического анализа, технологий и
возможностей.
Если возникает необходимость в динамическом анализе машинного кода для
узкоспециализированных процессорных архитектур или малораспространённых машин,
то, скорее всего, готовой виртуальной машины не существует.
Разработка машины становится сама по себе существенной проблемой, поскольку
в её отсутствие анализируемый код до конца не работоспособен.

Ранее были проведены работы по автоматизации начального этапа разработки
виртуальной машины [[$](#ref.QDTCommon), [$](#ref.QDTRegisters)].
Результатом тех работ является набор программных средств Qemu Development
Toolkit (QDT).
Однако наибольшая часть времени разработчика уходит на итеративную часть
разработки, в течение которой отладка и корректировка машины циклически
следуют друг за другом.
Данная работа нацелена на автоматизацию отладки.

При разработке новой виртуальной вычислительной машины программист
неизбежно сталкивается с ситуацией, когда она ведёт себя не так, как он ожидает.
Причины этого бывают самые разные:
ошибка в реализации модели какого-то устройства,
неправильное соединение устройств между собой,
некорректная реализация гостевого программного обеспечения (ПО), используемого
для тестирования,
и т.д.
Часто это выглядит как
отсутствие каких-либо сообщений на устройствах ввода-вывода,
отказ (аварийное завершение процесса),
сообщение о сбое от гостевого ПО,
сообщение о неожиданном поведении гостевого ПО от модели устройства
и т.п.
В большинстве случаев для понимания неисправности от программиста требуется
сбор дополнительной информации.
При этом используется совокупность методов.

- Отладка процесса эмулятора.
В данном случае отслеживаются инициализация машины и её реакция на действия
гостевого ПО.
- Отладка гостевого ПО средствами эмулятора.
Тут наоборот, отслеживается реакция гостевого ПО на действия компонентов
машины.
- Использование отладочных возможностей инфраструктуры эмулятора, таких как
вывод схемы адресных пространств,
вывод дерева устройств и шин,
вывод трассы работы процессора и динамического двоичного транслятора TCG,
доступ к гостевой памяти и регистрам гостевого процессора,
и мн. др.

Доступных методов достаточно для обнаружения неисправности.
Наиболее полезный из них --- отладка процесса эмулятора.
Самым популярным отладчиком в данном случае является GNU Debugger (GDB).
GDB --- универсальный отладчик: он ориентирован на отладку
произвольного приложения.
Поэтому он не имеет каких-то специальных средств для отладки именно Qemu.
Специализированных отладчиков не обнаружено.
Отсутствие специализации отчасти компенсируется встроенным интерпретатором
Python.
В исходном коде эмулятора присутствуют скрипты, добавляющие отладочные
команды, выводящие дерево памяти и информацию о сопрограммах ввода-вывода
блочных устройств.
В ходе данной работы таким способом был добавлен вывод таблицы TLB.
При разработке скрипта была выявлена существенная проблема в этом методе:
отсутствие возможности отладки самого скрипта.
Для обнаружения проблемной строки приходилось использовать метод двоичного
поиска.
Информацию об интересующих переменных скрипта приходилось получать
с помощью трассировки значений.
Таким образом, разработка сложного отладочного скрипта может оказаться
чрезвычайно трудозатратной.
Подобная ситуация справедлива и при использовании известных интегрированных
сред
разработки (IDE): они реализуют графический интерфейс к отладчику, но не делают
его специализированным.

Другие методы сбора информации о машине или недостаточно подробные
(карта памяти, дерево устройств), или слишком узкоспециализированные
(трассировка TCG, отладка гостевого ПО).
Поэтому их часто оказывается недостаточно, и всё-равно приходится прибегать к
отладке эмулятора.

Виртуальная машина --- сложная взаимосвязанная система, а деятельности
в ней происходят в несколько этапов, разрежённых во времени.
Полноценное понимание ситуации в момент остановки на точке останова крайне
затруднительно без знания предыстории деятельности.
Для отслеживания некоторой деятельности с самого начала вручную потребовалось
бы долгая кропотливая работа, результат которой становился бы не актуален после
завершения текущей сессии отладки.
Можно прибегнуть к трассировке значений.
Но если активность не тривиальная, то
для фильтрации и удобной интерпретации трассы потребуется написание
специального скрипта.
У скрипта будет больше возможностей при наличии доступа к работающему процессу
эмулятора.
Т.е. лучше всего, чтобы скрипт был написан как программа, управляющая процессом
отладки.

Каждая проблема уникальна, как и скрипт для её отладки.
Однако, используя знания об инфраструктуре Qemu, можно создать набор скриптов,
автоматизирующих типовые действия при отладке, что облегчит написание более
специализированных программ отладки.

Таким образом, целью данной работы является автоматизация отладки
виртуальной вычислительной машины в эмуляторе Qemu.

Автоматизация осуществляется путём написания базовых универсальных отладочных
скриптов, а также основывающихся на них других скриптов, нацеленных на
выявление наиболее часто встречающихся проблем.
Разработанное в данной работе средство является расширением для QDT,
направленное на ускорение отладки в цикле итеративной разработки модели машины.

Побочным продуктом использования QDT может быть расширенная информация о
сгенерированном автоматически коде машины.
Эту информацию можно использовать в скриптах отладки машины.
Но несмотря на доступность дополнительной информации о коде машины, главным
приоритетом разрабатываемого инструмента является независимость от этой
информации.
Максимум информации, необходимой для работы инструмента, будет браться из
исходного кода главной ветки Qemu, а также из отладочной информации, выдаваемой
компилятором.
Таким образом, инструмент можно будет применить даже к машине, разработанной
классическим способом, хотя и с ограниченной функциональностью.
Ограничения можно восполнить путём добавления и корректировки скриптов отладки.

# $. Программно управляемая отладка

Программно управляемая отладка заключается в расстановке точек останова на
интересующих разработчика позициях и выполнении определённых действий
автоматически, с помощью выполнения кода ассоциированного с точкой останова.
Для этого скрипт назначает для точек останова функции обратного вызова.
Для самой возможности программно управляемой отладки от отладчика требуется
специальный API.
Ниже перечисляются основные требования к такому API.

От API отладчика требуется доступ к основным отладочным примитивам:

- постановка точек останова по управлению (breakpoint) и по доступу к памяти
(watchpoint);
- доступ к регистрам процессора и памяти отлаживаемого процесса.

Процессы (в том числе и Qemu) часто создают параллельно работающие нити.
К каждой нити данные отладочные примитивы применяются независимо.
В то время как одна нить остановлена на точке останова, другие продолжают
выполняться.
Этот режим работы называется неблокирующим.
Главным образом он позволяет снизить вносимое отладчиком замедление.
API отладчика, в свою очередь, должен поддерживать индивидуальное управление
нитями.

Однако этих примитивов не достаточно для отладки программы в символах исходного
кода, т.к. они оперируют низкоуровневыми сущностями: адрес, байт, регистр,
нить и т.д.

То есть, от API отладчика требуются дополнительные возможности:

- получение адреса машинной инструкции для точки останова по файлу и номеру
строки
или
по имени функции (а иногда бывает удобно по относительному номеру строки
в функции),
- идентификация номера строки или функции по адресу (в частности, по текущему
значению счётчика команд);
- доступ к глобальным и локальным переменным по строковому имени (в разные
моменты их значения могут находиться как в памяти, так и на регистре; а в
случае оптимизации могут быть получены косвенно: путём вычисления произвольного
символьного выражения);
- использование информации о типах языка для обращения
к полям структур (и прочих контейнеров) по имени или для обращения
к элементам массивов по индексу;
- восстановление стека вызовов функций.

Реализация этих возможностей требует от отладчика анализа отладочной
информации, генерируемой компилятором.
Однако эти возможности не являются обязательными, т.к. пользовательский скрипт
может проанализировать отладочную информацию, используя другие средства.

GDB Python API предоставляет все упомянутые возможности, но, как уже
отмечалось,
написание отладочных скриптов для него затруднено отсутствием возможности
отладки самих скриптов.
Данным недостатком не будет обладать реализация отладочного API в формате
модуля Python для обычного интерпретатора.
В открытых источниках было обнаружено несколько проектов с похожим назначением.

## $.$ FrTime

FrTime[[$](#ref.FrTime)] --- функциональный язык с lisp-подобным синтаксисом,
используемый для автоматизации отладки программ на языке Java.
Для отладки используется среда DrScheme.

Язык FrTime создан с учётом следующих требований к языку для написания скриптов
для отладчика, сформулированных авторами той работы:

- возможность для пользователя задать специализированные команды (функции);
- определение вспомогательных структур для данных с возможностью хранить их в
отладчике (код отлаживаемой программы должен быть неизменен);
- дописывать скрипт в течение сессии отладки (по мере надобности, без
перезапуска);
- программирование в событийно-ориентированном стиле (пример события: точка
останова);
- богатые возможности ввода-вывода и вспомогательные библиотеки (как в языках
общего назначения).

Приведённый в статье отладочный скрипт заключается в применении к потокам
сообщений определённых логических правил.
Отладке подвергается класс из программы на языке Java посредством протокола
Java Debug Wire Protocol (JDWP).
Сообщения получаются путём трассировки интересующих скрипт значений.
Захват значений выполняется в течение кратковременной остановки на точке
останова.
Позицию точки останова можно указать по имени метода и относительному номеру
строки.
В частности, при вызове определённых методов, значения интересующих аргументов
превращаются в сообщения и отправляются в свои потоки.
Для каждой точки трассировки --- отдельный поток.
Затем потоки могут процедурно преобразовываться и мультиплексироваться.
Разработчик формулирует гипотезу о возможной причине ошибки в виде правила на
языке FrTime.
В случае срабатывания правила отладчик, приостанавливают выполнение
программы.
Это подобно условной точке останова, но с возможностью учесть предысторию в
предикате.
Когда программа остановлена, разработчик может дописать отладочный скрипт (в
режиме командной строки) с целью получения и обработки дополнительных данных
из контекста отлаживаемой программы.
В статье приведён пример графического отображения состояния отлаживаемой
программы: визуализация алгоритма построения минимального остовного дерева.
При визуализации разработчик легко может увидеть аномалии: циклы и результат
неправильной сортировки рёбер по длине.


## $.$ UFO

Unicon-FORMAN[[$](#ref.UFO)] (UFO) --- язык для автоматизации отладки
программ на языках Unicon и Icon.
Деятельность отлаживаемой программы моделируется событиями (event).
Событие описывает выполнение синтаксической конструкции языка (вызов функции,
присваивание значения переменной, вычисление выражения и т.д.) и может иметь
атрибуты, соответствующие этой конструкции (имя функции и её аргументы и т.д.).
На множестве событий определено бинарное отношение предшествования
(precedence).
Поскольку конструкции языка часто бывают вложенными (например, вычисление
выражения в инструкции присваивания значения переменной), события могут
находится в бинарном отношении вложенности (inclusion).
Из событий с учётом их отношений и атрибутов составляется предикат подобный
регулярному выражению.
При обнаружении выражения в потоке событий выполняются указанные действия.
В качестве примеров авторы приводят трассировку вызова функции, поиск двойного
закрытия файла, обнаружение использования неинициализированной переменной,
замеры времени и количества вызовов функции.


## $.$ Expositor

Expositor[[$](#ref.Expositor)] --- система для анализа трасс выполнения
процесса, основанная на реверсивном отладчика UndoDB.
По словам авторов, UndoDB --- расширение для GDB Python.
Отладочные скрипты пишутся на языке Python.
Трасса (trace), в терминологии Expositor, --- последовательность снимков
(snapshot) состояния отлаживаемого процесса, сделанных в одном месте.
Например, все срабатывания одной конкретной точки останова формируют одну
трассу.
Таким образом, выполнение (execution) программы --- множество трасс.
API Expositor позволяют манипулировать несколькими трассами: объединять в одну,
фильтровать, извлекать подпоследовательности и "сканировать", аккумулируя
данные из нескольких снимков в трассе.
Особое внимание в статье уделено ленивому вычислению значений: снимки
захватываются по требованию.
Чтобы поддерживать ленивое вычисление в случае композиции из операций над
трассами, был реализована специальная версия структуры данных
Hash Array Mapped Trie (HAMT), названная Edit HAMT.
Edit (редактировать) указывает на то, что эта структура данных запоминает и
учитывает
операции, выполненные над трассами, с целью минимизации количества снимков,
полученных для удовлетворения итогового запроса.
Таким способом авторы снижают объём данных, получаемых из процесса, и
минимизируют время выполнения запроса, т.к.
честный сбор всех запрошенных трасс может быть очень долгим и требовательным к
ресурсам действом.
Важно заметить, что выбор получаемых снимков основывается на интервалах
времени, т.е. разработчик скрипта должен уметь указать интересующий интервал.
Также авторы статьи не рассматривают способы отладки самого отладочного,
скрипта.

## $.$ deet

Desktop error elimination tool[[$](#ref.deet)] (deet) --- графический
программируемый отладчик, написанный на языке Tcl и использующий интерактивный
интерпретатор tksh (вариант Korn shell).
Графический интерфейс deet основан на библиотеке Tk/Tcl[[$](#ref.Tk)].

deet состоит из клиента (отладчик и графический интерфейс) и сервера
(т.н. "nub").
Протокол взаимодействия машинно-независимый.
Он поддерживает точки останова, доступ к памяти и кадрам стека.
Взаимодействие проходит в терминах исходного кода.
Работа с нитями и доступ к регистрам процессора не входят в протокол.
Сервер реализует машинно-зависимую часть или выступает посредником к другому
отладчику.
В работе представлены реализации сервера на базе отладчиков cdb и gdb для
программ на языке Си, и с использованием отладочного пакта для языка Java.

Высокоуровневые отладочные функции реализуются клиентом.
Базовый набор функций может быть легко расширен и адаптирован под конкретную
задачу.
Пользователь может в течение отладки дописывать код отладчика, добавляя
вспомогательные функции и новые графические элементы.

Поддерживается сохранение состояния сессии отладки в исполняемый скрипт,
выполнение которого восстановит состояние клиента.
В состояние входят точки останова и их условия срабатывания, пользовательский
отладочный код, и др.

Заметим, что QDT также использует библиотеку Tk/Tcl, но посредством библиотеки
Tkinter для языка Python.
Отсутствие поддержки нитей даёт большое замедление, что делает deet непригодным
для автоматизированной отладки Qemu.
Кроме этого, использование языка Tcl затруднит повторное использование
логики из QDT, написанной на Python.


## $.$ DDD

DataDisplayDebugger[[$](#ref.DDD)] (DDD) --- графический интерфейс для
следующих отладчиков: GDV, DBX, WDB, Ladebug, JDB, XDB, отладик для Perl,
bashdb (для скриптов bash), remake (для скриптов GNU Make) и pydb (для скриптов
на языке Python).
DDD реализован на Си и использует для реализации графического интерфейса
пользователя библиотеку LessTif (альтернативная реализация Motif и Open Motif).
Отличительная особенность DDD --- отображение данных отлаживаемого процесса
в виде графа.
Вершины --- прямоугольные блоки в которых представлены сами данные:
значения базовых типов, строки, массивы, поля структур, включая вложенные
структуры.
Пользователь может сворачивать блоки и скрывать лишние данные.
Рёбра (стрелки) соответствуют разыменованию указателей и ведут от блока с
указателем к блоку, отображающему данные по адресу.
DDD автоматически отслеживает как обновление отображаемых данных (при
продолжении выполнения), так и временное скрытие блоков, когда соответствующие
переменные выходят из области видимости.
Построение графа основано на языке Visual Structure Language (VSL), для
которого в DDD реализован интерпретатор.

Графическое отображение ограничивается синтаксическими конструкциями
языка.
Реализация специального отображения данных для конкретного приложения явно
не оговаривается, хотя она возможна путям модификации кода отладчика, но
не может быть сделана в течение сессии отладки, т.к. требуется компиляция.


## $.$ Code Bubbles и Debugger Canvas

Расширение Code Bubbles[[$](#ref.CodeBubbles1), [$](#ref.CodeBubbles2)] для
Eclipse IDE и аналогичное ему Debugger Canvas[[$](#ref.DebuggerCanvas)] для
MS Visual Studio отображают код программы в виде графа.
Вершиной является прямоугольник, содержащий фрагмент кода, обычно
соответствующий методу или классу.
Ребро (стрелка) условно отображает смысловую связь между вершинами.
Например, при переходе к определению вызываемого метода, появляется новый
прямоугольник и создаётся ребро.
Ребро будет иметь начало у края старого прямоугольника (с вызывающим методом)
напротив строки, где содержится вызов метода, а конец --- на заголовке
нового прямоугольника.
Данная возможность особо удобна для представления стека вызовов во время
отладки, т.к. позволяет отобразить более длинную цепочку за счёт отображения
только нужных фрагментов исходного кода.
Код отображается в текстовом редакторе соответствующей IDE, т.е. можно
использовать такое отображение как альтернативу классическому редактору.
Графическое отображение зависимостей между данными, как в DDD, не
поддерживается.
Хотя упомянутые IDE имеют функционал для отображения структурированных данных
в отдельных графических элементах.
Поддерживается одновременное отображение нескольких сессий отладки, что, по
мнению авторов, может быть удобно для сравнения.

Code Bubbles поддерживает только язык Java.
Помимо отображения кода Code Bubbles может отображать документацию (JavaDoc) с
гипертекстовыми ссылками и произвольные заметки пользователя.
Попытки использовать его для Qemu (в форме проекта C/C++ Development Tooling)
потерпели фиаско.

Debugger Canvas, как заявляется авторами, пригоден для нескольких языков
(например, C# и Visual Basic), благодаря обобщённой языковой модели,
используемой внутри Visual Studio.

Добавление специального способа отображения для конкретного приложения
авторами не обсуждается.
Тем не менее, код Code Bubbles открыт, что даёт такую возможность.


## $.$ pygdb и API поверх GDB Machine Interface

Проект "pygdb" [[$](#ref.pygdb)] является реализаций отладчика, основанной на
системном вызове "ptrace".
Целью проекта является реализация возможностей, аналогичных GDB.
Однако в настоящее время проект является скорее тестовым прототипом, чем
готовым к использованию модулем.
Кроме этого, он не поддерживает 64-битный режим, в котором обычно работает
эмулятор.

Проекты "Python GDB MI Parser" [[$](#ref.python-gdb-mi)] и
"pygdbmi" [[$](#ref.pygdbmi)] реализуют API для работы с интерфейсом
"Machine Interface" (MI) GDB.
Данный интерфейс основывается на обмене сообщениями между клиентом
(GDB/MI frontend) и сервером (GDB).
Клиент отправляет команды, а сервер --- ответы на команды и уведомления.
Уведомления асинхронны, их появление может быть как косвенным следствием
выполнения команд (например, сообщение об остановке процесса на точке
останова), так и иметь независимые от клиента причины (например, содержать
данные, записанные процессом в стандартный поток вывода).
Обычно машинный интерфейс используется IDE для реализации графического
интерфейса для отладчика.

Несмотря на название, MI является достаточно высокоуровневым.
Он даёт полный доступ к возможностям GDB, что делает его
пригодным для программно управляемой отладки.
Однако есть две существенные особенности.

- Сообщения записываются в сложной грамматике, местами использующей
текстовой формат JSON.
Это удобно для анализа человеком, но, в то же время, это делает обмен
данными избыточным, а разбор сообщений --- долгим.
- В сообщения от сервера часто включается информация, которая не
требуется клиенту в данный момент.
Например, вместе с номером сработавшей точки останова отсылаются имена файла
(с путём и без) и номер строки, а также имя функции.
В то же время, при задании точки останова клиент уже имеет информацию о том,
куда им была поставлена данная точка останова.
Таким образом, сервер тратит лишнее время на определение позиции и отправку
её клиенту, а тот, в свою очередь, --- за анализ информации, которая ему всё
равно не нужна.

При пользовании MI из графического интерфейса во время ручной отладки эти
особенности не важны, т.к. сообщений пересылается мало и пользователь не
заметит потерь производительности.
Но при программно управляемой отладке, когда в секунду отрабатывается
десятки-сотни
точек останова, и для каждой происходит получение информации времени
выполнения об отлаживаемом процессе, эти издержки заметно ограничивают
теоретический максимум быстродействия.

## $.$ API поверх GDB Remote Serial Protocol

Кроме MI, GDB поддерживает так называемый Remote Serial Protocol (RSP).
Данный протокол используется для отладки удалённых процессов по сети или при
отладке ПО для встраиваемых платформ.
Заметим, что Qemu реализует именно этот протокол для отладки гостевого ПО.

RSP --- расширяемый протокол, но он также определяет необходимый минимум,
который должен поддерживать сервер.
Этот минимум включает уже описанные выше постановку точек останова,
доступ к памяти и регистрам,
и управление нитями.
Он, аналогично MI, оперирует сообщениями, в которых пересылаются команды,
ответы и уведомления.
Формат этих сообщений по большей части текстовой.
Но команды часто идентифицируются всего 3 байтами, а аргументы плотно
упакованы.
Значения регистров и байтов преобразуются в строки в системе счисления с
основанием 16.
При этом предусмотрен контроль целостности, опционально отключаемый для
надёжных соединений на подобие сокетов, использующих TCP.
Выполнение данных преобразований избыточно, но накладных вычислений всё равно
меньше, чем в случае MI.
Содержимое сообщений, отправляемых сервером лишено избыточной информации.
Для сравнения, уведомление о точке останова сопровождается идентификатором
нити и значениями указателей команд и стека.
Последний всегда необходим для доступа к локальным переменным функции.
У минимализма RSP есть и обратная сторона.
Поддержка отладочной информации и связанной с ней функциональности --- задача
клиента.

Модуль "pyrsp" [[$](#ref.pyrsp)] реализует API как для взаимодействия по
протоколу RSP, так и для работы с отладочной информацией в формате DWARF.
Последнее опирается на модуль "pyelftools" [[$](#ref.pyelftools)].
Эти два модуля были взяты за основу для разработки инструмента автоматизации
отладки Qemu.

В процессе работы выяснилось, что реализации обоих модулей не достаточно
полноценны, чтобы использовать их как есть.
"pyrsp" не поддерживал работу с несколькими нитями (неблокирующий режим).
Анализ отладочной информации был слишком примитивным и имел много допущений.
В частности корректно работать можно было только с исполняемыми файлами,
полученными из одного модуля компиляции.
Полностью отсутствовала работа с типами и значениями из отлаживаемого процесса,
как в GDB Python API.
"pyelftools" поддерживал большую часть базовых возможностей по разбору
отладочной информации из исполняемого ELF-файла.
Однако разбор всего файла Qemu занимал у него слишком много времени (порядка
нескольких минут).
Это обусловлено тем, что "pyelftools" спроектирован для анализа всего
содержимого ELF-файла разом.
Но для работы программно управляемого отладчика,
во-первых, не требуется вся информация,
во-вторых, она требуется не сразу, а по мере достижения определённого
состояния.

## $.$ Расширение возможностей pyrsp и pyelftools

Для решения обнаруженных проблем указанные модули были модифицированы следующим
образом.

В "pyelftools" были реализованы ленивый анализ и кэширование.
Суть ленивого анализа заключается в том, что он выполняется по запросу
извне для конкретных фрагментов отладочной информации.
Кроме этого, реализация API pyelftools была изменена так, чтобы избежать
лишнего анализа в процессе поиска запрашиваемой информации.
Вдобавок, кэширование помогает избежать повторных поиска и анализа
ранее запрашиваемых данных.
Ещё была добавлена поддержка форматов таблиц быстрого поиска имён
и типов ".debug_pubnames" и ".debug_pubtypes".

Модуль "pyrsp" был сильно переработан.
Ниже приводятся основные изменения.

- Реализовано независимое управления нитями удалённого процесса.
- Поддержан неблокирующий режим.
Без него независимое управление нитям не имеет смысла.
- Добавлена поддержка уведомлений.
В неблокирующем режиме посредством уведомлений клиенту передаётся информация об
остановках нитей.
Проясним, что в блокирующем режиме клиент уведомляется об остановках
посредством ответа на команду продолжения выполнения.
То есть, ответ ожидается клиентом до тех пор, пока не будет достигнута
какая-либо точка останова.
В неблокирующем режиме посредством ответа клиент только уведомляется о факте
успешного получения запроса на возобновление выполнения конкретной нити.
Это обычно происходит сразу.
- Реализована поддержка установки нескольких обратных вызовов на одну точку
останова.
Данная возможность особенно важна, когда с отлаживаемым процессом работают
несколько скриптов, не знающих друг про друга, но наблюдающих за одним и тем же
кодом.

Поверх модифицированных модулей "pyelftools" и "pyrsp" было реализовано
API для работы со значениями из отлаживаемого процесса на уровне символов
исходного кода.
Это API условно можно разделить на статическую часть, работающую поверх только
"pyelftools", и динамическую, использующую активную сессию отладки через
"pyrsp".
Статическая часть реализует работу с типами, получение точек останова по
позиции в файле, идентификация позиции в функции по адресу и др.
Динамическая часть отвечает за получение данных из отлаживаемого процесса.
При этом данные обрабатываются в терминах исходного кода (переменная,
поле структуры, функция, строка), для чего активно используется статическая
часть.

Стоит заметить, что реализованное API создаётся похожим на GDB Python API
(насколько это возможно).
В идеале это дало бы возможность переиспользовать код скриптов для GDB.
В настоящее время эта возможность не доступна в полной мере.
Кроме этого остаются нереализованными многие другие возможности, такие как
изменение значений отлаживаемого процесса, вызов функций и др.
Тем не менее, проект продолжает развиваться, и данные возможности будут
добавляться по мере надобности.

## $.$ Поддержка изменений исходного кода

В условиях непрерывного развития проекта позиции точек останова,
зафиксированные в отладочных скриптах, быстро становятся недействительными.
Даже небольшое изменение не относящегося к некоторой позиции кода, но
расположенного выше неё, приводит к смещению номера строки.
Это часто даже не приводит к сообщению об ошибке, т.к. смещённая позиция всё
равно соответствует какому-то коду.
То есть, некоторая часть скрипта начинает работать неадекватно, и разработчик
даже может это не сразу заметить.

Эта особенность была учтена в разработанном API.
Реализация автоматически контролирует актуальность позиций точек останова с
использованием информации из системы контроля версий Git.
Позиция в файле может быть сопровождена SHA1
идентификатором версии, для которой она актуальна.
Для каждой позиции инструмент сравнивает текущую версию кода с версией,
указанной для этой позиции.
Если изменения произошли ниже интересующей позиции, то они игнорируются.
Если --- выше, то корректируется номер строки.
Заметим, что Git оперирует изменениями с точностью до строки: для каждого
изменения указано, сколько строк было удалено, а сколько --- добавлено.
Изменение в строке описывается как удаление старой строки и добавление новой.
Таким образом, нетрудно вычислить разницу в номере интересующей позиции.

Важным параметром является окрестность позиции.
Дело в том, что не только изменение самой строки может сделать позицию не
адекватной.
Многие строки взаимосвязаны по смыслу.
Поиск метода доказательной проверки адекватности позиции с учётом изменений во
всём коде выходит за рамки данной работы.
Но принято допущение, что изменения в некоторой небольшой окрестности
следует считать стоящими внимания разработчика.
Окрестность выбирается в несколько строк.
Разработчик имеет возможность указать интервал, изменениям строк в котором
следует уделить особое внимание в будущем.
Очевидно, что чем больше интервал, тем больше будет ложноположительных
срабатываний.
При обнаружении важных изменений от разработчика скрипта требуется указать
новую позицию или подтвердить старую.
Это делается путём указания SHA1 идентификатора версии, соответствующей
изменению.

## $.$ Минимизация замедления отлаживаемого процесса

Хотя программно управляемая отладка значительно быстрее, чем ручная, вносимое
ей замедление ощутимо.
Например, инициализация виртуальной машины "nuri" (входит в сборку Qemu для
архитектуры процессора ARM) обычно выполняется около секунды.
Но в режиме восстановления состава машины, описанном ниже, время инициализации
составляет несколько минут.
При измерениях в обоих случаях использовалась отладочная сборка эмулятора.

Основная причина замедления --- простой нити во время обработки точки останова.
Очевидно, что исполнение горячего кода реализации отладочного API в форме
модуля на языке Си ускорило бы процесс (напомним, что API реализован как
модуль на языке Python).
Однако есть и принципиальная проблема: в подходе к написанию обработчиков точек
останова.

Обработку точки останова можно условно разделить на две логические части:

- **получение** данных из отлаживаемого процесса;
- высокоуровневая **обработка** этих данных.

Обе этих части часто выполняются в течение работы функции обратного вызова
(обработчика).
Реализация API, действуя надёжно, не возобновляет выполнение нити, пока
функция не вернёт управление.

Если рассмотреть первую часть более глубоко, то данные из отлаживаемого
процесса можно разделить на две категории.

- **Короткоживущие данные**.
Это --- данные, которые нельзя *надёжно* считать актуальными после
возобновления нити.
К ним относятся локальные переменные, размещённые на стеке, и т.п.
- **Долгоживущие данные**.
Это --- данные, для которых известно, что они неизменны в течение достаточно
длительного промежутка времени в этом режиме работы отлаживаемого процесса.
Например, структуры, описывающие виртуальные устройства в Qemu, размещаются в
куче и не перемещаются в течение всей работы эмулятора.
Такие данные можно читать даже после возобновления нити.

Принципиального ускорения можно добиться, если возобновлять нить сразу после
получения короткоживущих данных.
При этом не стоит забывать, что некоторые обработчики связаны по смыслу, и
может случиться так, что следующий сработает до того, как предыдущий закончит
свою вторую часть.

Разработчик может учесть эти особенности при написании кода обработчиков
самостоятельно.
Однако наличие вспомогательных инструментов в API сэкономило бы ему время.

В настоящее время предложено два подхода разграничению обозначенных этапов
работы обработчика.

**Явное возобновление работы нити.**
В данном случае API даёт возможность для обработчика явно указать,
когда нить может быть надёжно возобновлена.
Соблюсти порядок выполнения вторых частей можно путём блокировки обработчика
с момента возобновления нити и до момента, когда его предшественник не вернёт
управление (завершит свою вторую часть).
К реализации блокировки также есть два подхода.

- При запуске обработчика в отдельной нити реализация блокировки может быть
выполнена с помощью соответствующего примитива синхронизации.
Важно учесть, что создание нити --- дорогая операция, кроме этого потребуется
синхронизация доступа к разделяемым ресурсам.

- Если обработчик написан как сопрограмма (в Python сопрограммы реализуются с
помощью т.н. "генераторов"), то эффекта блокировки можно добиться
путём планирования времени, предоставляемого сопрограммам, и установлением
зависимостей между ними (в QDT реализован свой планировщик).

В общем случае, применение сопрограмм даёт больше возможностей по контролю
распределения времени.
Это важно при интеграции с графическим интерфейсом пользователя.
Для сравнения, стандартный планировщик нитей Python может предоставлять
циклу обработки сообщений графического интерфейса недостаточно времени, что
приводит к неудовлетворительной отзывчивости.

**Разбиение обработки на две функции.**
Подобный подход применяется в ядре ОС Linux для обработки прерываний.
Т.н. "верхняя половина" обработки будет происходить в первой функции и будет
заключаться в получении короткоживущих данных и сохранении их для второй,
"нижней", "половины".
Она будет выполнять оставшиеся, возможно, длительные действия.
"Нижние половины" будут вызываться в том же порядке, в каком были вызваны
соответствующие "верхние", что обеспечит правильный порядок.

Изучение, выбор и реализация одного из подходов являются направлением
дальнейших исследований.

# $. Автоматизированная отладка Qemu

В данном разделе рассматриваются реализованные отладочные скрипты общего
назначения, которые могут быть использованы для написания более
узконаправленных отладочных программ.

## $.$ Восстановление дерева типов QOM

Для описание различных сущностей в Qemu применяется реализованная на Си
объектно-ориентированная модель с динамической типизацией ---
QEMU Object Model (QOM).
Описание QOM дано в разделе 3.1 нашей предыдущей работы [[$](#ref.QDTCommon)].
С точки зрения отладки, сложность заключается в том, что дерево типов строится
динамически, путём выполнения кода при старте эмулятора.
Теоретически, дерево можно было бы восстановить с помощью статического анализа
кода, но это --- тема отдельного исследования.
Высокоуровневым скриптам необходима информация о дереве QOM для различения
объектов (специальная обработка для шин, устройств, прерываний и т.д.),
выбора правильного определения структуры для интерпретации данных в памяти и
т.д.

Восстановление дерева QOM осуществляется путём расстановки точек останова в
местах регистрации и инициализации типов (а также соответствующих им классов:
"типы" и "классы" это --- разные вещи в QOM).
При этом
сохраняются адреса структур-описателей в куче,
запоминаются строковые идентификаторы,
по указателям на родительские типы восстанавливается дерево типов
и т.д.

Особое внимание уделено восстановлению способа интерпретации данных.
Дело в том, что наследование в QOM осуществляется путём добавление в начало
структуры дочернего класса структуры родительского.
Так объект дочернего класса содержит в себе поля всех предков.
В зависимости от желания разработчика, один объект может быть удобно
интерпретировать с использованием разных определений структур.
Заранее известны лишь какие самые базовые структуры пригодны для интерпретации
некоторого объекта (отрезка памяти в куче).
Но при отладке, например, устройства часто нужна интерпретация с использованием
структуры, соответствующей именно типу этого устройства.
Автоматическое получение перечня структур, пригодных для интерпретации
объектов какого-либо типа, может быть сделано по-разному.
В Qemu принято писать код, работающий с разными интерпретациями объекта так,
чтобы для каждой интерпретации создавалась отдельная переменная
соответствующего типа.
Поэтому, в данной работе применена следующая эвристика.
Ставится точка останова на выход из функции, для которой известно, что
некоторый аргумент указывает на интересующий объект.
В момент остановки проверяются все локальные переменные, и у тех из них,
которые указывают на данный объект, запоминаются типы.

Данное действие можно было бы выполнить и с помощью статического анализа, но
не стоит забывать, что при приведении типов может быть использован макрос и/или
вызвана проверочная функция.
Т.е. статический подход тоже не тривиален.

Реализована возможность вывода дерева QOM в формате Graphviz, что может быть
использовано разработчиком для проверки правильности добавления своего
устройства в дерево или для справки.

## $.$ Восстановление состава машины

Для отладки виртуальной машины необходимо знать размещение входящих в неё
объектов в куче.
Взаимодействие между компонентами машины происходит посредством вызова
функций API Qemu.
При этом компоненты представлены указателями на описывающие их структуры: т.е.
--- адресами.
Для построения соответствия между адресами и компонентами в определённых
функциях API Qemu ставятся точки останова.
Обработчик точки останова написан в соответствии с семантикой функции API Qemu.
Так можно отследить
создание устройства, его настройку посредством свойств (подразумеваются
свойства объекта QOM),
соединение между шиной и устройством,
соединение двух устройств линией запроса прерывания и др.
Это даёт возможность в любой момент проверить состояние устройства,
определить какая линия прерывания активна,
к каким регистрам каких устройств обращается процессор
и мн.др.
Получить эту информацию статически нельзя, т.к. адреса в куче могут меняться от
запуска к запуску.
Разработанный инструмент поддерживает схематичное отображение восстановленной
машины средствами графического редактора из состава QDT.
Это позволяет разработчику проверить правильность соединения
компонентов, что актуально в случае если машина была создана
классическим способом, или в машину, полученную с помощью QDT, были внесены
изменения.

Особую сложность представляет отслеживание подключения прерываний в машинах,
реализованных вручную.
Причина в том, что разработчики часто подключают прерывания в обход API Qemu.
Это позволяет сократить объём кода, что важно в случае ручного написания
машины.
При необходимости отладки такой машины потребуется модифицировать инструмент:
поставить дополнительные точки останова в нужных местах и реализовать
специальные обработчики для получения информации о таких прерываниях.
<!--
В рамках эксперимента таким способом были подержаны прерывания "Global System
Interrupt (GSI)" машины "i440FX".
-->
Заметим, что QDT генерирует код, подключающий прерывания с использованием
API Qemu, т.к. для автоматизированной генерации проблема большого количества
кода не стоит так остро.
Отслеживание подключения прерываний не требует дополнительного кода в
отладочном скрипте.

# $. Заключение

В ходе данной работы был проведён поиск и анализ доступных средств программного
управления отладкой.
Важным критерием поиска была пригодность средства к автоматизации отладки
виртуальной машины в эмуляторе Qemu.
Выяснилось, что доступные средства не пригодны в достаточной мере.
Ввиду этого, на базе опыта, полученного в ходе экспериментов с
проанализированными средствами:

- во-первых, был реализован отладчик, предоставляющий API для написания
отладочных скриптов на языке Python, предоставляющий возможности,
необходимые для отладки Qemu;
- во-вторых, были написаны отладочные скрипты, реализующие часто используемые
отладочные алгоритмы;
- в-третьих, разработанные скрипты были успешно проверены как на виртуальных
машинах, реализованных классическим способом, так и на машинах,
сгенерированных QDT.

При реализации отладчика были пропущены такие часто встречающиеся в отладчиках
возможности как изменение значений в отлаживаемом процессе и вызов функций.
Это не является принципиальным ограничением, а только экономией времени.
Эти возможности не были нужны в ходе данной работы, и их реализация является
направлением дальнейших исследований.

Реализованный отладочный API имеет универсальные части, не ориентированные
именно на Qemu, поэтому он может быть использован для отладки произвольных
программ с учётом обозначенных ограничений реализации.

# Список литературы

[$]. <a name="ref.QDTCommon"></a>Ефимов В.Ю., Беззубиков А.А., Богомолов Д.А.,
Горемыкин О.В., Падарян В.А. Автоматизация разработки моделей устройств и
вычислительных машин для QEMU. Труды ИСП РАН, том 29, вып. 6, 2017 г.,
стр. 77-104. DOI: 10.15514/ISPRAS-2017-29(6)-4

[$]. <a name="ref.QDTRegisters"></a>QDT Device Registers

[$]. <a name="ref.pygdb"></a>Minimal C Debugger in Python. Доступно по ссылке:
   https://github.com/theicfire/pygdb, 23.09.2018.

[$]. <a name="ref.pyrsp"></a>pyrsp. Доступно по ссылке:
   https://github.com/stef/pyrsp,  23.09.2018.

[$]. <a name="ref.python-gdb-mi"></a>Python GDB MI Parser. Доступно по ссылке:
   https://github.com/hydra-dbg/python-gdb-mi, 23.09.2018.

[$]. <a name="ref.pygdbmi"></a>pygdbmi - Get Structured Output from GDB's
   Machine Interface. Доступно по ссылке:
   https://github.com/cs01/pygdbmi, 23.09.2018.

[$]. <a name="ref.pyelftools"></a>pyelftools. Доступно по ссылке:
   https://github.com/eliben/pyelftools, 23.09.2018.

[$]. <a name="ref.FrTime"></a>Marceau, G., Cooper, G.H., Spiro, J.P.,
Krishnamurthi, S., Reiss, S.P.: The design and implementation of a dataflow
language for scriptable debugging. Automated Software Engineering, volume 14,
issue 1, March 2007, pp. 59-86, DOI: 10.1007/s10515-006-0003-z

[$]. <a name="ref.UFO"></a>Auguston, M., Jeery, C., Underwood, S. A framework
for automatic debugging. In: Proc. ASE'02, IEEE Computer Society (2002) 217-222

[$]. <a name="ref.Expositor"></a>Khoo, Y.P., Foster, J.S., Hicks, M.:
Expositor: scriptable time-travel debugging with first-class traces.
In: Proc. ICSE. (2013) 352-361

[$]. <a name="ref.deet"></a>Hanson, D.R., Korn, J.L.: A simple and extensible
graphical debugger. In: WINTER 1997 USENIX CONFERENCE. (1997) 173-184

[$]. <a name="ref.DDD"></a>Zeller A., L¨utkehaus D. DDD --- a free graphical
front-end for UNIX debuggers. SIGPLAN Notices, 31(1):22-27, January 1996.

[$]. <a name="ref.Tk"></a>Ousterhout J. K. Tcl and the Tk Toolkit.
Addison-Wesley, Reading, MA, 1994.

[$]. <a name="ref.CodeBubbles1"></a>Bragdon A., Reiss S. P., Zeleznik R. C.,
Karumuri S., Cheung W., Kaplan J. et al., Code Bubbles: Rethinking the user
interface paradigm of integrated development environments, in International
Conference on Software Engineering, 2010.

[$]. <a name="ref.CodeBubbles2"></a>Bragdon A. and Zeleznik R. C., Code
bubbles: a working set-based interface for code understanding and maintenance,
in Computer Human Interaction - CHI, 2010.

[$]. <a name="ref.DebuggerCanvas"></a>DeLine R., Bragdon A., Rowan K.,
Jacobsen J., Reiss S. P.: Debugger canvas: industrial experience with the
code bubbles paradigm. In: ICSE. (2012) 1064-1073

