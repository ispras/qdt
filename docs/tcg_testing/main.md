---
title: |
  Автоматизированное тестирование фронтенда транслятора TCG для Qemu
author:
- Колтунов Д.С. &lt;koltunov@ispras.ru>
- Ефимов В.Ю. &lt;real@ispras.ru>
tags: []
abstract: |
  <br>

  **Аннотация.**
  Реализация новой виртуальной процессорной архитектуры в Qemu предполагает
  создание фронтенда динамического двоичного транслятора TCG для данной
  процессорной архитектуры.
  Для проверки правильности реализации данного компонента транслятора
  необходимо тестирование.
  Существующие на сегодняшний день системы тестирования фронтенда TCG для
  некоторой процессорной архитектуры используют подход на основе сравнения с
  эталоном той же процессорной архитектуры.
  В качестве данного эталона могут выступать реальный процессор, виртуальная
  машина с большей точностью эмуляции или другая реализация двоичного
  транслятора.
  Однако не всегда есть доступ к таким эталонам.
  Таким образом, данная работа нацелена на тестирование реализации процессорной
  архитектуры в Qemu при условии отсутсвия необходимого эталона для сравнения.
  Основная идея заключается в том, что программа,
  написанная на языке программирования высокого уровня, должна одинаково
  выполняться независимо от процессорной архитектуры.
  То есть, можно использовать процессор другой архитектуры для сравнения.
  В данной работе это — процессор машины разработчика с архитектурой AMD64.
  Объектами сравнения такого подхода выступают значения переменных (является
  понятием языка программирования высокого уровня, на котором пишутся тестовые
  сценарии).
  <!--
  языка высокого уровня, на котором пишутся тестовые сценарии.
  -->
  Данное программное средство реализовано на языке программирования Python,
  поддерживает тестирование Qemu в режиме полносистемной эмуляции и в режиме
  эмуляции уровня пользователя.
  Оно называется c2t (CPU Testing Tool) и входит в состав инструмента
  автоматизации разработки моделей устройств и вычислительных машин для
  Qemu [[$](#ref.QDT)], исходный код которого
  доступен по адресу https://github.com/ispras/qdt.
  Данное средство пригодно как для тестирования фронтендов TCG,
  полученных с использованием системы автоматизации создания фронтендов TCG
  [[$](#ref.TCGgen)], так и реализованных классическим способом (вручную).

  **Ключевые слова**:
  Qemu;
  автоматизированное тестирование фронтенда TCG;
  QDT;
  GDB RSP
...

# $. Введение

Виртуальные вычислительные машины применяются для решения разнообразных задач:
включая исследования в рамках информационной безопасности.
Одной из задач является организация контролируемого окружения для исследуемого
машинного кода во время динамического анализа.
Распространенный способ реализации контролируемого окружения – программный
эмулятор.
Такой способ обеспечивает изоляцию средств анализа от анализируемого кода.
Поэтому он хорошо подходит для исследования компьютерных вирусов и другого
вредоносного ПО.

Эмулятор Qemu наиболее подходит для этой цели, поскольку обладает рядом
полезных свойств: полностью открытый исходный код (лицензия GPL), поддержка
разнообразных гостевых архитектур (Intel x86, AMD 64, ARM, MIPS, PowerPC, SPARC
и др.), реализация важных, с точки зрения динамического анализа, технологий и
возможностей.
Если возникает необходимость в динамическом анализе машинного кода для
узкоспециализированных процессорных архитектур, то, скорее всего, готовой
виртуальной машины не существует.
Разработка машины становится сама по себе существенной проблемой, поскольку
в её отсутствие анализируемый код до конца не работоспособен.

Реализация новой процессорной архитектуры в Qemu предполагает создание
фронтенда динамического двоичного транслятора TCG для данной процессорной
архитектуры.
Данный процесс может быть выполнен классическим способом — вручную или с
использованием системы автоматизации создания фронтенда TCG.
В обоих случаях для проверки правильности реализации данного компонента
транслятора необходимо тестирование.
Так как тестирование является неотъемлемым этапом разработки ПО, который
сокращает количество допущенных программистом ошибок, что, в свою очередь,
повышает точность эмуляции и, соответственно, корректность и прозрачность
анализа исследуемого кода.
<!--
Благодаря чему возможно повысить точность эмуляции и, соответственно, точность
результатов анализа исследуемого кода.
-->
Под прозрачностью подразумевается успешное сокрытие факта проведение анализа от
анализируемого кода.

Самым распространенным способом тестирования реализации процессорной
архитектуры в Qemu является сравнение с эталоном.
<!--
, при котором производится сравнение поведения программной модели и эталона.
-->
Впервые понятие эталона для тестирования ("test oracle") было введено в работе
[[$](#ref.oracle_testing)].
Согласно данной работе для валидации программы необходимо предположить
существование эталона, который можно использовать для проверки правильности
результатов теста.
В ней также упоминается, что наиболее распространенным видом эталона является
тот, который можно использовать для проверки правильности выходных значений для
заданного набора входных значений.
<!--
и существование других видов эталонов, которые
могут использоваться для проверки правильности промежуточных/трасс значений
выбранных программных переменных.
-->

Существующие на сегодняшний день системы тестирования фронтенда TCG для
некоторой процессорной архитектуры используют подход на основе сравнения с
эталоном той же процессорной архитектуры.
В качестве данного эталона могут выступать реальный процессор, виртуальная
машина с большей точностью эмуляции, а также другая реализация двоичного
транслятора.
Данные эталоны используется для проверки правильности выходных значений для
заданного набора входных значений.
Например, специальным образом подготовленная инструкция подаётся на вход
тестируемого фронтенда и реального процессора (или виртуальной машине с большей
точностью эмуляции).
Затем сравниваются состояния регистров процессора и содержимое памяти
(выходные данные).
<!--
Например, реальный процессор и виртуальная машина с большей точностью эмуляции
используются для сравнения состояния регистров и содержимого памяти тестируемой
виртуальной машины, которые выступают в качестве выхода, полученных в
результате подачи специальным образом полученной инструкции гостевой
архитектуры в качестве входа эталону и тестируемой реализации процессорной
архитектуры.
-->

Также в качестве эталона можно использовать другую реализацию двоичного
транслятора.
В таком случае тестируемому фронтенду TCG и эталонному транслятору (или
нескольким трансляторам) на вход подается специальным образом подготовленный
гостевой код, который транслируется ими в их промежуточные представления.
Далее вводится некоторое специальное унифицированное промежуточное
представление, которое используется для объеденения каждого полученного
промежуточного представления в единую форму.
Затем все полученные промежуточные представления транслируются в
унифицированное промежуточное представление (выход).
После чего результаты сравниваются между собой и производится проверка на
наличие семантических расхождений.
<!--
А в случае использования в качестве эталона другой реализации двоичного
транслятора, выходом является некоторое специальное промежуточное
представление, которое получается путем трансляции промежуточных представлений,
полученных подачей специальным образом полученного гостевого кода в качестве
входа эталону и тестируемому фронтенду TCG.
-->
Однако не всегда есть доступ к таким эталонам.
Это обучловлено недоступностью необходимого реального оборудования, отсутствием
эталонной виртуальной машины или другой реализации двоичного транслятора нужной
процессорной архитектуры.
Таким образом, целью данной работы является разработка подхода к тестированию
реализации процессорной архитектуры в Qemu при условии отсутсвия необходимого
эталона для сравнения и реализация программного средства
автоматизированного тестирования.

Разработанный подход к тестированию должен решить проблему отсутствия
необходимого эталона для сравнения.
Это предлагается достичь за счет применения языка программирования высокого
уровня Си для написания тестовых сценариев, так как программа, написанная на
таком языке должна одинаково выполняться независимо от процессорной
архитектуры.
<!--
Это предлагается достичь за счет применения языка программирования высокого
уровня для написания тестовых сценариев, так как программа, написанная на таком
языке должна одинаково выполняться независимо от процессорной архитектуры.
-->
Таким образом, предоставляется возможность использовать фиксированный и
доступный эталон — процессор машины разработчика с архитектурой AMD64.
На основе данного подхода предлагается реализовать на языке программирования
Python программное средство автоматизированного тестирования фронтендов TCG.

# $. Обзор похожих работ

Существующие на сегодняшний день системы тестирования реализации процессорной
архитектуры в Qemu основываются на сравнении с эталоном данной процессорной
архитектуры.
<!--
В качестве данного эталона могут выступать реальный процессор, виртуальная
машина с большей точностью эмуляции, а также другая реализация
двоичного транслятора.
Данные эталоны используется для проверки правильности выходных значений для
заданного набора входных значений.
-->

Такие системы описаны в работах EmuFuzzer [[$](#ref.EmuFuzzer)],
KEmuFuzzer [[$](#ref.KEmuFuzzer)], PokeEMU [[$](#ref.PokeEMU)],
RISU [[$](#ref.RISU)] и MeanDiff [[$](#ref.MeanDiff)], а также есть система
генерации тестов MicroTESK [[$](#ref.MicroTESK)].
Далее кратко будет рассмотрена каждая из этих систем.
<!--
[[$](#ref.hi_fi_4_lo_fi)]
-->

## $. EmuFuzzer, KEmuFuzzer и PokeEMU

EmuFuzzer — прототип, в котором реализована полностью
автоматизированная методика тестирования для эмуляторов процессора (QEMU,
Valgrind, Pin и BOCHS), основанная на фаззинге.
Данная методика может быть использована для
автоматического обнаружения расхождений конфигурации среды (т.е. состояние
регистров процессора и содержимое памяти) в эмулируемом и физическом
процессорах.
Для тестирования эмулятора создается большое количество тестов, которые
запускаются на эмулируемом и реальном процессорах.
В конце выполнения каждого теста сравниваются конфигурации двух сред.
Любое расхождение является признаком неправильного поведения эмулятора.
<!--
Принимаются две стратегии для генерации тестовых сценариев: только случайная
генерация и гибридная алгоритмическая/случайная генерация.
Последнее гарантирует, что каждая инструкция в наборе команд проверяется,
по крайней мере, в некоторых выбранных контекстах выполнения.
-->

KEmuFuzzer — прототип, который реализует автоматизированную методику (как и
EmuFuzzer) для тестирования четырех современных виртуальных машин: BOCHS, QEMU,
VirtualBox и VMware.
Отличие от EmuFuzzer в том, что тестируются полносистемные эмуляторы и что в
качестве эталона выступает KVM.

PokeEMU — инструмент тестирования эмулятора.
Он автоматически генерирует наборы тестов с большым покрытием и сравнивает
поведение эмулятора с реальной машиной, выполняя тесты на обоих из них.
Инструмент генерирует тестовые сценарии с помощью символьного выполнения.
Данным инструментом были протестированы QEMU и BOCHS.
PokeEMU также использует в качестве эталона KVM.

Данные работы направлены на обнаружение неточностей реализации процессорной
архитектуры x86 в виртуальной машине с целью повысить прозрачность с точки
зрения динамического анализа.

Имеются еще работы подобного типа, такие как [[$](#ref.hi_4_lo)] и
[[$](#ref.pill_testing)].

## $. MeanDiff

MeanDiff — инструмент тестирования промежуточных представлений для двоичных
трансляторов.
Он реализует идею поиска семантических ошибок в фронтендах (binary lifters)
существующих двоичных трансляторов.

Подход к тестированию, лежащий в основе инструмента, заключается в том, что
на вход двоичным трансляторам подается некоторый машинный код.
Данный код транслируется трансляторами в свое промежуточное
представление.
Далее вводится некоторое специальное унифицированное промежуточное
представление, которое используется для объеденения каждого полученного
промежуточного представления в единую форму.
Затем все полученные промежуточные представления транслируются в
унифицированное промежуточное представление.
После чего результаты сравниваются между собой и производится проверка на
наличие семантических расхождений.
Данным инструментом можно протестировать правильность реализаций фронтендов
двоичных трансляторов, которые имеются в Qemu, Valgrind, BINSEC и т.д.

## $. RISU

Инструмент RISU (Random Instruction Sequences for Userspace) – инструмент для
проверки точности реализации набора инструкций процессора в таких виртуальных
машинах, как Valgrind и QEMU.
Он состоит из двух частей.

1) Генератор, который выводит случайный машинный код на основе
входного файла, описывающего шаблоны набора инструкций.
2) Тестовая программа, которая запускает сгенерированный код, как на
тестируемом, так и на реальном оборудовании.

Инструмент может использоваться для тестирования программ, которые реализуют
только пользовательское пространство, например, Valgrind и QEMU linux-user.
Для архитектуры ARM RISU поддерживает тестирование 32-битных наборов команд
A32 (ARM) и T32 (Thumb), а также 64-битного набора команд A64.
Инструмент также поддерживает архитектуры PPC и m68k.

## $. MicroTESK

Инструмент MicroTESK (Microprocessor TEsting and Specification Kit) – среда
генерации тестовых программ на языке ассемблера целевой процессорной
архитектуры для функциональной верификации микропроцессоров.
Также данный инструмент предоставляет возможность автоматизированного
конструирования генераторов тестов на основе формальных спецификаций
необходимой процессорной архитектуры.
Такие тесты можно, по идее, запускать в Qemu и на реальном процессоре с целью
выявления расхождений в их поведении.

В рассмотренных работах можно выделить ряд эталонов, которые используются для
сравнения при тестировании реализации процессорной архитектуры в Qemu.
Такими эталонами являются реальный процессор, виртуальная машина с большей
точностью эмуляции, а также другая реализация двоичного динамического
транслятора.
Все они той же процессорной архитектуры, что и тестируемая реализация.
Однако не всегда есть доступ к таким эталонам.
Это обучловлено недоступностью необходимого реального оборудования, отсутствием
эталонной виртуальной машины или другой реализации двоичного динамического
транслятора нужной процессорной архитектуры.
Для решения этой проблемы в данной работе предлагется подход к тестированию.
Суть подхода описана в следующем разделе.

# $. Предлагаемый подход к тестированию

В основе предлагаемого в данной работе подхода к тестированию фронтендов TCG
различных процессорных архитектур, также как и в рассмотренных подходах, лежит
сравнение с эталоном.
Однако идея предлагаемого подхода заключается в том, что программа, написанная
на языке программирования высокого уровня, должна одинаково выполняться
независимо от процессорной архитектуры.
<!--
Однако, тут не всё так просто.
Автор тестовых программ должен учитывать многие тоности.
Например, часто при программировании микроконтроллеров тип `int` языка Си
имеет длину 16 бит, в то время как Си-программисты под IA32 и AMD64 привыкли,
к длине 32 бита.
В данном случае рекомендуется использовать подходящий тип из `<stdint.h>`:
`int32_t` или `int16_t` — в зависимости от того, какая длина
на самом деле нужна.
При этом, явное указание длины переменной может влиять на выбор компилятором
определённых вариантов инструкций, а так же правильность реализации в
эмуляторе поведения при переполнении.
Рассмотрение всех особенностей, выходит за рамки данной работы.
-->
Данные программы выступают в качестве тестовых сценариев.
Это необходимо для ухода от процессорной зависимости тестов, которые, в
существующих решениях, пишутся на языке ассемблера или генерируются в виде
машинного кода, что является архитектурно-зависимым.
Наиболее подходящим для решения данной проблемы является использование для
написания тестовых сценариев высокоуровневого языка программирования Си.
Это обусловлено тем, что данный язык является кроссплатформенным и используется
в разработке системного программного обеспечения, в некоторой мере вытеснив
язык ассемблера.
Немаловажным также является наличие для языка Си множества компиляторов с
открытым исходным кодом, что предоставляет важные возможности, для тестирования
новых фронтендов TCG.
Таким образом, достигается возможность использования для сравнения
фиксированного эталона -- персонального компьютера.
Что является важным по причине того, что не всегда есть доступ к необходимому
реальному процессору.

Для тестируемого фронтенда TCG создается ряд тестов, написанных, как было
указано ранее, на языке программирования Си.
Однако, уйдя от архитектурной зависимости тестов, возникает проблема: нельзя
протестировать реализацию многих процессорных инструкций, например, таких как
циклические сдвиги.
Таким образом, тестирование направлено на проверку правильности реализации
некоторой арифметики, логики, битовых операций, ветвлений и других, не
связанных с периферией, инструкций процессора, другими словами то, что возможно
покрыть тестами на языке Си.

Достигается это за счет одинаковой логики работы с переменными (переменная
используется, как понятие языка программирования Си) тестовых сценариев,
несмотря на отличие архитектурных особенностей эталона и тестируемой
виртуальной машины.
Таким образом, в ходе проведения тестирования на каждом его шаге сравниваются
не счетчик команд, состояние регистров и т.д., как это происходит в
EmuFuzzer и KEmuFuzzer, а состояние переменных и позиция выполнения тестового
сценария.
Для сравнения используется отладчик.

Так как сравнение состояний всех переменных после выполнения каждой строки
теста в ходе проведения тестирования является избыточным, то необходим
механизм указания определенных строк и имен переменных для сравнения.
Другими словами, механизм тонкой настройки тестирования.
Данный механизм реализован путем добавления специальных управляющих
комментариев напротив необходимых строк исходного кода теста
[$](#approach.png).

![Рисунок <a name="approach.png">$</a> --- Схема осуществления тестирования
](approach.png)

<!-- А рисунок сразу идёт в PNG? иначе лучше добавить исходник и команду в
Makefile -->

Сам факт наличия такого комментария к строке означает, что на данной строке
будет приостановлено выполнение теста эталоном и тестируемой виртуальной
машиной, и будут получены состояния переменных для дальнейшего сравнения.
Другими словами, комментарии указывают отладчику места, на которые необходимо
поставить точки останова, а также указывает имена переменных, значения которых
необходимо проверить.
Получение отладчиком состояний переменных обеспечивается путем добавления
отладочной информации стандартного формата DWARF при компиляции тестового
сценария.

Стоит отметить, что для проверки корректности функционирования фронтенда TCG,
сравнение значений переменных и позиции выполнения является практически
достаточным для большинства случаев.
Архитектурные особенности основной и целевой системы отличаются, но логика
работы с переменными у них одинаковая.
Немаловажным является то, что предложенный подход к тестированию
автоматизируется.

Также стоит отметить, что создание тестов, которые обеспечивают наибольшее
покрытие по инструкциям, реализованных в тестируемом фронтенде TCG, является
отдельной сложной задачей и выходит за рамки данной работы.
<!--
Ты писал, что архитектурно зависимые инструкции не тестируются.
Следовательно, это замечание про то, что не всегда можно проверить арифметику,
логику, ветвления и т.д.?
Тогда нужно пояснить, в чём же проблема: какие-то тесты же всё-таки написаны
в ходе данной работы.
Что ты вообще понимаешь под покрытием в этом тексте?
Нужно явно обозначить, что арх. зав. инструкции не учитываются воовсе.
И привести примеры таких иснтрукций.
Желатально такие, которые в принципе не могут быть написаны на языке Си без
ассемблерных вставок.
-->

# $. Реализация автоматизированного тестирования

Предложенный подход к тестированию предполагает для сравнения значений
переменных использование отладчика и добавление отладочной информации на этапе
компиляции.
В Qemu реализован сервер внешней отладки гостевого кода по
протоколу удаленной отладки GDB (GDB Remote Serial Protocol), основными
возможностями которого являются:
* чтение/запись значений регистров процессора;
* чтение/запись в оперативную память;
* установка точек останова по управлению (breakpoint);
* установка точек останова по обращению к памяти (watchpoint).

Это означает, что для отладки гостевого кода может быть использован отладчик,
поддерживающий данный протокол.
Например, отладчик GDB.
Однако использование отладчика GDB для проведения тестирования
фронтенда Qemu, как и любого другого полноценного отладчика, усложняет процесс
подготовки к проведению тестирования.
Это обусловлено высокой трудоемкостью процесса модификации отладчика GDB,
как и любого другого полноценного отладчика.
Таким
образом, необходимо использовать средство отладки, предоставляющее большую
гибкость.
В качестве решения данной проблемы выступает отладочное API QDT.
QDT является инструментом автоматизации разработки моделей устройств и
вычислительных машин для Qemu, написанный на языке программирования Python.
Исходный код QDT является открытым.
Отладочное API QDT использует модуль "pyrsp" [[$](#ref.pyrsp)] с открытым
исходным кодом, также написанный на языке Python.
Модуль "pyrsp" реализует API как для взаимодействия по протоколу RSP.
Также отладочное API QDT использует модуль "pyelftools" [[$](#ref.pyelftools)]
для работы с отладочной информацией в формате DWARF.
На основе данного API реализовано программное средство
автоматизированного тестирования фронтенда транслятора Qemu.
Оно называется c2t (CPU Testing Tool) и входит в состав QDT.

Ниже представлена схема осуществления тестирования с использованием
разработанного программного средства.

![Рисунок <a name="system.png">$</a> --- Схема проведения тестирования
](system.png)

<!--
Не обязательно указывать на рисунке, что pyrsp модифицирован, загромождает.
Это можно сказать в тексте.
-->

Конфигурация тестирования реализуется путем добавления управляющих
комментариев в исходном коде теста, которые являются выражениями на языке
Python, выполняемыми штатными средствами в окружении, настроенном нужным
образом.
Данные комментарии пишутся человеком, проводящим тестирование, и содержат
команды специального вида, задающие проверки, которые будут выполнены во время
тестирования.
На данный момент программным средством поддерживаются следующие команды:
* br – установка точки останова для однократной проверки соответствия позиций
выполнения тестового сценария;
* brc – установка точки останова для многократной проверки соответствия позиций
выполнения тестового сценария;
* bre – завершить тестирование;
* ch – установка точки останова для однократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;
* chc – установка точки останова для многократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;

Пример теста и конфигурации тестирования, с использованием управляющих
комментариев, представлен следующим кодом.

<!--это нужно обозвать рисунком или, не уверен, листингом-->

+-----------------------------------------------------------------------------+
|```                                                                          |
|int main(void) {                                                             |
|    volatile uint32_t a = 0xABCDEF, b = 0x12345678, c = 0, i;                |
|                                                                             |
|    for(i = 0; i < 20; i++) {                                                |
|        if(i % 2) {                                                          |
|            // однократная проверка позиций выполнения                       |
|            c = b - a; //$br                                                 |
|        }                                                                    |
|        else {                                                               |
|            // многократная проверка позиций выполнения                      |
|            c = b + a; //$brc                                                |
|        }                                                                    |
|                                                                             |
|        // однократная проверка значений всех переменных                     |
|        c = b & a; //$ch                                                     |
|                                                                             |
|        // однократная проверка значений переменной `c`                      |
|        c = b | a; //$ch.c                                                   |
|                                                                             |
|        // многократная проверка значений переменной `c`                     |
|        c = b ^ a; //$chc.c                                                  |
|                                                                             |
|        /* Также есть возможность комбинировать команды:                     |
|          - однократная проверка позиций выполнения и                        |
|            значений переменных `a` и `b`                                    |
|          - многократная проверка значений переменной `c`                    |
|        */                                                                   |
|        c = 0; //$br, chc.c, ch.a, ch.b                                      |
|    }                                                                        |
|                                                                             |
|    // завершить тестирование                                                |
|    return 0; //$bre                                                         |
|}                                                                            |
|```                                                                          |
+-----------------------------------------------------------------------------+

Для поддержки тестирования в Qemu необходимо добавить код, предоставляющий
возможность отладчику читать и писать в регистры процессора, а также отвечающий
за поддержку установки отладочных точек останова (вставка транслятором
необходимого кода tcg транслятором, реализующего точки останова).

# $. Оценка покрытия

Под покрытием в данной работе подразумевается количество выполненных Qemu
уникальных инструкций гостевого процессора.
Инструкции получаются из имеющихся на момент написания работы 145 тестов
на Си (они входят в состав QDT).
Данные тесты содержат следующие операции, предоставляемые языком Си:
1. Арифметические: присваивание (=), сложение (+), вычитание (-), умножение (*)
и деление (/).
2. Побитовые: умножение (&), сложение (|), сложение по модулю 2 (^),
отрицание (~), сдвиги вправо (>>)/влево (<<).
3. Сравнения: равенство (==), неравенство (!=), больше (>), меньше (<), больше
или равно (>=), меньше или равно (<=).

Также имеются тесты, которые содержат условные конструкции, циклы, вызовы
функций с небольшим и большим количеством параметров.
Данными тестами можно проверить реализации инструкций передачи, возврата
управления и работы со стеком.
Последнее относится к тестам, содержащим вызовы переменных с большим
количеством параметров.
Чтобы проверить реализации различных вариаций одной и той же инструкции
процессора, тесты выполнены в вариантах, содержащих 8, 16, 32 и 64 разрядные
знаковые и беззнаковые переменные.

Как было написано выше, данным подходом нельзя покрыть специфичные для
конретного процессора инструкции.

Продтверждение работоспособности (применимости) предложенного в рамках данной
работы подхода было произведено тестированием существующих в "офф-стриме" Qemu
реализаций процессорных архитектур ARM32 и MIPS32.
И еще двух реализаций, не находящихся в "офф-стриме", процессорной архитектуры
MSP430 (далее MSP430_1 и MSP430_2).
Реализация MSP430_1 доступна по адресу
https://github.com/draperlaboratory/qemu-msp.
Однако для того, чтобы протестировать данную реализацию потребовалось внести
в нее изменения, описанные в предыдущем разделе.
Также потребовалось сократить количество тестов.
Это сделано по причине того, что в архитектуре MSP430 такие арифметические
инструкции, как умножение и деление, реализуются аппаратно.

Реализация MSP430_2 является собственной реализацией, в которой были умышленно
допущены ошибки с целью выявления их программным средством тестирования.

В таблице [$](#tbl.isa_cover_num) содержатся полученные результаты по
покрытию тестированием инструкций.
Представлено отношение количества выполненных Qemu инструкций от общего
количества инструкций определенной процессорной архитектуры, реализованной в
Qemu.

Таблица <a name="tbl.isa_cover_num">$</a>. Количество покрытых инструкций

+----------+---------+-------+-----+
|   ISA    | Покрыто | Всего |  %  |
+==========+=========+=======+=====+
|  ARM32   |   76    | 1251  |  6  |
+----------+---------+-------+-----+
|  MIPS32  |   46    |  92   | 50  |
+----------+---------+-------+-----+
| MSP430_1 |   37    |  79   | 47  |
+----------+---------+-------+-----+
| MSP430_2 |   23    |  60   | 38  |
+----------+---------+-------+-----+

Инструкции ARM32 были подсчитаны без учета суффиксов c, f, s, x.
Реализация архитектуры ARM32 была протестирована путем запуска тестов на
виртуальных процессорах cortex-m3 и arm926.
Реализация архитектуры MIPS32 была протестирована путем запуска тестов на
виртуальных процессорах r4000 и 4kc.

Для тестирования ARM32 и MIPS32 было использовано все 145 тестов, для MSP430_1
— 69 тестов, а для MSP430_2 — 49 тестов.

Инструкции процессора можно разбить на следующие классы:
1. Обработка данных и операции с памятью.
2. Арифметические и логические операции.
3. Операции изменения потока управления.
4. Инструкции сопроцессора.
5. Специфичные для процессора.

В таблице [$](#tbl.isa_cover) представлены по классам все инструкции покрытые и
не покрытые тестированием.

Таблица <a name="tbl.isa_cover">$</a>. Список покрытых/не покрытых инструкций

+---------+-----+------------------------------+------------------------------+
|   ISA   |Класс|     Покрытые инструкции      |    Не покрытые инструкции    |
+=========+=====+==============================+==============================+
|  ARM32  |  1  | ldrb, pop, ldr, mov, movs,   | pop + cc, mrs + cc, msr + cc,|
|         |     | str, movge, movcc, mvns,     | swp, swpb, ldm + cc,         |
|         |     | strh, stmdb, movne, stm,     | ldmda + cc, ldmdb + cc       |
|         |     | ldrh, moveq, ldmia, ldrsh,   | ldmib + cc, stmia + cc,      |
|         |     | ldrsb, strb, push, mvn       | stmib + cc, stmda +cc        |
|         |     |                              |                              |
|         |  2  | sub, subs, lsl, lsr, eor,    | ror(s) + cc, cmn + cc,       |
|         |     | orrcs, subcs, cmpeq, lsls,   | teq + cc, bic(s) + cc,       |
|         |     | rsbmi, asreq, add, adc, ands | rrxs + cc, rscs + cc         |
|         |     | lsrne, rsb, asr, rsbs, cmpcc,|                              |
|         |     | adcs, mul, orrs, tst, mla,   |                              |
|         |     | lsrs, cmp, and, sbcs, rrx,   |                              |
|         |     | adds, lsrsne, orreq, orr,    |                              |
|         |     | lsrcs, eors, lslcc, sbc,     |                              |
|         |     | lsleq, rsc, umull, smulbb    |                              |
|         |     |                              |                              |
|         |  3  | b, bl, bmi, beq, bcs, ble,   | bpl, bvs, bvc, svc/swi + cc  |
|         |     | blt, bhi, bne, bls, bcc, bgt,|                              |
|         |     | bge                          |                              |
|         |     |                              |                              |
|         |  4  |                              | cdp, mrc, mcr                |
+---------+-----+------------------------------+------------------------------+
| MIPS32  |  1  | movn, movz, lb, lw, ll, slt, | mthi, mtlo, lh, lwl, lwr,    |
|         |     | sltiu, slti, sltu, lbu, mflo,| swl, swr, sc, pref, sync     |
|         |     | mfhi, lui, sw, lhu, sh, sb   |                              |
|         |     |                              |                              |
|         |  2  | subu, addiu, mul, nor, sllv, | madd, maddu, msub, msubu,    |
|         |     | srlv, multu, and, sll, addu, | xori                         |
|         |     | xor, srav, ori, andi, divu,  |                              |
|         |     | div, mult, sra, srl, or      |                              |
|         |     |                              |                              |
|         |  3  | bltz, beqz, jal, bne, bal,   | blez, bgtz, bgez, bltzal,    |
|         |     | beq, bnez, teq, jr           | bgezal, beql, bnel, blezl,   |
|         |     |                              | bgtzl, bltzl, bgezl, bltzall,|
|         |     |                              | bgezall, j, jalr, syscall,   |
|         |     |                              | break                        |
|         |     |                              |                              |
|         |  4  |                              | mtc0, mfc0, eret             |
|         |     |                              |                              |
|         |  5  |                              | t + cc (trap)                |
+---------+-----+------------------------------+------------------------------+
|MSP430_1 |  1  | mov(.b), push, br, sxt       | push.b, pop(.b), nop, clr(.b)|
|         |     |                              | swpb                         |
|         |     |                              |                              |
|         |  2  | add(.b), addc, inc(.b), incd,| inv.b, sbc(.b), tst.b        |
|         |     | sub(.b), subc, decd, cmp(.b),| subc.b, addc.b, incd.b,      |
|         |     | and(.b), bis(.b), xor(.b),   | decd.b, dadc(.b), rla.b,     |
|         |     | inv, rla, rlc, rra, rrc, tst,| rlc.b, rra.b, rrc.b, tst.b,  |
|         |     | bit                          | bit.b, dint, eint, setc,     |
|         |     |                              | setn, setz, clrc, clrn, clrz,|
|         |     |                              | bic(.b), dadd(.b), adc(.b),  |
|         |     |                              | dec(.b)                      |
|         |     |                              |                              |
|         |  3  | call, ret, jnz, jge, jc, jeq,| reti, jmp, jn, jnc           |
|         |     | jl                           |                              |
+---------+-----+------------------------------+------------------------------+
|MSP430_2 |  1  | mov(.b)                      | br, pop(.b), nop, clr(.b)    |
|         |     |                              |                              |
|         |  2  | add(.b), incd, sub(.b), decd,| inc(.b), incd.b, rla.b,      |
|         |     | cmp(.b), and(.b), bis(.b),   | adc(.b), rlc(.b), bit(.b),   |
|         |     | xor(.b), rla                 | dec(.b), decd.b, inv(.b),    |
|         |     |                              | addc(.b), eint, setc, setn,  |
|         |     |                              | setz, bic(.b), clrc, clrn,   |
|         |     |                              | clrz, dint                   |
|         |     |                              |                              |
|         |  3  | call, ret, jnz, jeq, jge, jl | jc, jmp, jn, jnc             |
+---------+-----+------------------------------+------------------------------+

Из таблицы можно сделать вывод, что для всех протестированных в данной работе
архитектур покрыты основные
арифметические и логические инструкции, инструкции обработки данных и работы с
памятью, инструкции изменения потока управления.
Не покрыты некоторые инструкции, например, циклические сдвиги, инструкции
сопроцессора и инструкции, специфичные для процессора.
Это обусловлено тем, что невозможно покрыть их средствами языка Си.
Однако все же можно покрыть некоторые инструкции сопроцессора, например,
операции над числами с плавающей точкой.
В данный момент таких тестов нет.

С помощью данного пограммного средства была обнаружена специально допущенная
ошибка реализации инструкции sub в MSP430_2.

# $. Заключение

В данной работе предложен подход к автоматизированному тестированию фронтенда
транслятора TCG эмулятора Qemu, а также реализовано программное средство на его
основе, которое находится в открытом доступе.
Проведена оценка покрытия имеющихся на момент написания работы тестов и
автоматизации деятельности человека, проводящего тестирование.
<!--я верю, что будет глава с таблицами-->

# Список литературы

[$]. <a name="ref.QDTCommon"></a>Ефимов В.Ю., Беззубиков А.А., Богомолов Д.А.,
Горемыкин О.В., Падарян В.А. Автоматизация разработки моделей устройств и
вычислительных машин для QEMU. Труды ИСП РАН, том 29, вып. 6, 2017 г.,
стр. 77-104. DOI: 10.15514/ISPRAS-2017-29(6)-4

[$]. <a name="ref.TCGgen"></a>Bezzubikov A., Belov N., Batuzov K. Automatic
dynamic binary translator generation from instruction set description // 2017
Ivannikov ISPRAS Open Conference (ISPRAS). — Vol. 1. — United States: United
States, 2017.

[$]. <a name="ref.oracle_testing"></a>W. E. Howden, "Theoretical and empirical
studies of program testing", Proc. 3rd Int. Conf. Software Engineering, pp.
305-311, 1978.

[$]. <a name="ref.EmuFuzzer"></a>Lorenzo Martignoni, Roberto Paleari,
Giampaolo Fresi Roglia, Danilo Bruschi, Testing CPU emulators, Proceedings of
the eighteenth international symposium on Software testing and analysis, July
19-23, 2009, Chicago, IL, USA.

[$]. <a name="ref.KEmuFuzzer"></a>Lorenzo Martignoni, Roberto Paleari,
Giampaolo Fresi Roglia, Danilo Bruschi, Testing system virtual machines,
Proceedings of the 19th international symposium on Software testing and
analysis, July 12-16, 2010, Trento, Italy.

[$]. <a name="ref.hi_4_lo"></a>L. Martignoni, S. McCamant, P. Poosankam,
D. Song, and P. Maniatis, "Path-exploration lifting: Hi-fi tests for lo-fi
emulators," in Proc. of the International Conference on Architectural Support
for Programming Languages and Operating Systems, London, UK, Mar. 2012.

[$]. <a name="ref.pill_testing"></a>Hao Shi, Abdulla Alwabel, and Jelena
Mirkovic. 2014. Cardinal pill testing of system virtual machines. In
Proceedings of the 23rd USENIX Security Symposium (USENIX Security’14).
271-285.

[$]. <a name="ref.RISU"></a>.

[$]. <a name="ref.MeanDiff"></a>Soomin Kim, Markus Faerevaag, Minkyu Jung,
SeungIl Jung, DongYeop Oh, JongHyup Lee, Sang Kil Cha, Testing intermediate
representations for binary analysis, Proceedings of the 32nd IEEE/ACM
International Conference on Automated Software Engineering, October 30-November
03, 2017, Urbana-Champaign, IL, USA.

[$]. <a name="ref.MicroTESK"></a>Камкин А.С., Сергеева Т.И., Смолов С.А.,
Татарников А.Д., Чупилко М.М. Расширяемая среда генерации тестовых программ
для микропроцессоров. Программирование, № 1, 2014, стр. 3-14.
