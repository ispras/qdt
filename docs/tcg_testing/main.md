---
title: |
  Автоматизированное тестирование фронтенда транслятора TCG для Qemu
author:
- Д.С. Колтунов &lt;koltunov@ispras.ru>
- В.Ю. Ефимов &lt;real@ispras.ru>
- В.А. Падарян &lt;vartan@ispras.ru>
tags: []
abstract: |
  <br>

  **Аннотация.**
  Реализация новой виртуальной процессорной архитектуры в Qemu предполагает
  создание фронтенда динамического двоичного транслятора TCG для данной
  процессорной архитектуры.
  Существующие на сегодняшний день системы тестирования фронтенда TCG
  используют подход на основе сравнения с эталоном той же процессорной
  архитектуры.
  В качестве эталона могут выступать реальный процессор, виртуальная
  машина с большей точностью эмуляции или другая реализация двоичного
  транслятора.
  Однако не всегда такие эталоны доступны, зачастую они могут вообще не
  существовать.
  Данная работа нацелена на тестирование реализации процессорной
  архитектуры в Qemu в условиях отсутствия необходимого эталона для сравнения.
  Предлагаемый подход основывается на том, что даже для малораспространённой
  процессорной архитектуры, как правило, доступен пакет `binutils` и компилятор
  языка Си.
  Си-программа может одинаково выполняться на различных процессорных
  архитектурах, если удаётся избегать в ней ситуаций неопределенного или
  реализационного зависимого поведения.
  Это позволяет проводить сравнение хода
  работы двух разных исполняемых файлов на тестируемой виртуальной машине и
  машине разработчика.
  Объектами сравнения такого подхода выступают сущности языка Си, на котором
  разрабатваются тесты.
  Подход реализован в программном средстве c2t (CPU Testing Tool) и входит в
  состав программного комплекса автоматизации разработки моделей устройств и
  вычислительных машин для Qemu, исходный код которого
  доступен по адресу https://github.com/ispras/qdt.
  c2t реализовано на языке программирования Python,
  поддерживает тестирование Qemu в режиме полносистемной эмуляции и в режиме
  эмуляции уровня пользователя.
  Данное средство пригодно как для тестирования фронтендов TCG,
  полученных с использованием системы автоматизации создания фронтендов TCG,
  так и реализованных классическим способом (вручную).

  <br>

  *Работа поддержана грантом РФФИ No 16-29-09632*.

  <br>

  **Ключевые слова**:
  Qemu;
  автоматизированное тестирование фронтенда TCG;
  QDT;
  GDB RSP
...

# $. Введение

Виртуальные вычислительные машины применяются для решения разнообразных задач,
включая исследования в рамках информационной безопасности.
Одной из таких задач является динамический анализ, который нуждается в
контролируемой среде выполнения исследуемого машинного кода.
Удобный и распространённый способ реализации контролируемой среды — программный
эмулятор, поскольку он обеспечивает изоляцию средств анализа от анализируемого
кода.
На практике такой способ хорошо подходит для исследования компьютерных
вирусов и другого вредоносного ПО.

Эмулятор Qemu наиболее удобен для этой цели, поскольку обладает рядом
полезных свойств: полностью открытый исходный код (лицензия GPL), поддержка
разнообразных гостевых архитектур (Intel x86, AMD 64, ARM, MIPS, PowerPC, SPARC
и др.), реализация важных, с точки зрения динамического анализа, технологий и
возможностей [[$](#ref.QDT)].

Тем не менее, при необходимости провести динамический анализ для
малораспространенной процессорной архитектуры, скорее всего, аналитик
столкнется с тем, что готовой виртуальной машины найти не удастся.
В этом случае придется решать вопрос разработки новой виртуальной машины.

Реализация новой процессорной архитектуры в Qemu, кроме прочего, предполагает
создание фронтенда динамического двоичного транслятора TCG для данной
процессорной архитектуры.
Как правило, фронтенды TCG создаются вручную, но на данный момент уже есть
средства, предлагающие некоторую автоматизацию [[$](#ref.TCGgen)].
В любом случае для проверки корректности фронтенда транслятора необходимо
тестирование.
Оно является неотъемлемым этапом разработки ПО, который своевременно сокращает
количество допущенных программистом ошибок, что, в свою очередь, повышает
точность эмуляции и качество анализа исследуемого кода.
<!--
Благодаря чему возможно повысить точность эмуляции и, соответственно, точность
результатов анализа исследуемого кода.
-->

Самым распространённым способом тестирования реализации процессорной
архитектуры в Qemu является сравнение с эталоном ("test oracle")
[[$](#ref.oracle_testing)].
<!--
, при котором производится сравнение поведения программной модели и эталона.
-->
Чтобы провести тестирование таким способом необходима доступность эталона, а
также возможность получать от него информацию о состоянии выполняющейся на нем
программы.
<!--
и существование других видов эталонов, которые
могут использоваться для проверки правильности промежуточных/трасс значений
выбранных программных переменных.
-->
Существующие на сегодняшний день системы тестирования фронтенда TCG для
некоторой процессорной архитектуры используют подход на основе сравнения с
эталоном той же процессорной архитектуры, в качестве которого могут выступать
реальный процессор, виртуальная машина с большей точностью эмуляции, а также
другая реализация двоичного транслятора.
Оценивается корректность работы отдельной инструкции, которая выполняется в
тестируемом и эталонном окружениях, подготовленных специальным образом.
После ее выполнения сравниваются состояния заданных регистров процессора и
содержимого памяти в эмуляторе и эталоне.
<!--
Например, реальный процессор и виртуальная машина с большей точностью эмуляции
используются для сравнения состояния регистров и содержимого памяти тестируемой
виртуальной машины, которые выступают в качестве выхода, полученных в
результате подачи специальным образом полученной инструкции гостевой
архитектуры в качестве входа эталону и тестируемой реализации процессорной
архитектуры.
-->

<!-- Этот абзац есть в обзоре, т.к. во введении он не очень нужен.
Тем более, что метод хитрый и сразу выносит мозг читателю.
-->
<!--
Также в качестве эталона можно использовать другую реализацию двоичного
транслятора.
В таком случае тестируемому фронтенду TCG и эталонному транслятору (или
нескольким трансляторам) на вход подаётся специальным образом подготовленный
гостевой код, который транслируется ими в их промежуточные представления.
Далее вводится некоторое специальное унифицированное промежуточное
представление, которое используется для объединения каждого полученного
промежуточного представления в единую форму.
Затем все полученные промежуточные представления транслируются в
унифицированное промежуточное представление (выход).
После чего результаты сравниваются между собой и производится проверка на
наличие семантических расхождений.
-->
<!--
А в случае использования в качестве эталона другой реализации двоичного
транслятора, выходом является некоторое специальное промежуточное
представление, которое получается путем трансляции промежуточных представлений,
полученных подачей специальным образом полученного гостевого кода в качестве
входа эталону и тестируемому фронтенду TCG.
-->

Однако не всегда есть возможность работы с эталоном.
Это обусловлено недоступностью необходимого реального оборудования, отсутствием
у оборудования отладочных интерфейсов, недоступностью альтернативной
виртуальной машины или двоичного транслятора нужной процессорной архитектуры.

Целью данной работы является разработка подхода к тестированию
реализации процессорной архитектуры в Qemu в условиях отсутствия необходимого
эталона для сравнения и последующая реализация соответствующего программного
средства, позволяющего проводить автоматизированное тестирование.

Предлагаемый подход основывается на том, что даже для малораспространенной
процессорной архитектуры будет доступен некоторый набор программных
инструментов
разработки: пакет `binutils` или его аналог, компилятор языка Си.
Располагая такими инструментами можно проводить тестирование, не опускаясь на
уровень отдельных команд, а выполняя тестовые Си-программы и сравнивая их
поведение в терминах языка Си — на уровне значений переменных.
Один и тот же тест компилируется для двух различных машин: целевой процессорной
архитуктуры (выполняется в Qemu) и естественного эталона — машины, на которой
ведется разработка.

В данной работе сделано следующее:

* Разработан набор тестов.
* Разработан способ оценки достигнутого покрытия кода.
* Реализованы средства автоматического тестирования (обвязка).
* Проведены эксперименты.

<!--
Разработанный подход к тестированию должен решить проблему отсутствия
необходимого эталона для сравнения.
Для этого необходимо создавать некоторый машинный код, который будет подаваться
на вход существующему эталону другой процессорной архитектуры.
При выполнении этот машинный код должен в определенных точках давать выход,
одинаковый с выходом в тех же точках, но если бы оригинальный машинный код был
выполнен в отсутствующем эталоне.
В данной работе это предлагается достичь за счет применения языка
программирования высокого уровня для написания тестовых сценариев.
В данной работе был выбран язык Си, так как программу на нём можно написать
так, что её получится скомпилировать под разные процессорные архитектуры.
Таким образом, предоставляется возможность использовать фиксированный и
доступный эталон — процессор машины разработчика.

Это не является требованием, но тестирование на других машинах
не проводилось, а теоретических ограничений не известно.
Данный подход был реализован в программном средстве автоматизированного
тестирования фронтендов TCG — c2t (CPU Testing Tool),
которое входит в состав программного комплекса автоматизации разработки моделей
устройств и вычислительных машин для  Qemu [[$](#ref.QDT)].
c2t написан на языке Python.
-->

# $. Обзор работ

Существующие на сегодняшний день системы тестирования реализации процессорной
архитектуры в Qemu основываются на сравнении с эталоном данной процессорной
архитектуры.

Они делятся на следующие типы:

* Системы, которые направлены на обнаружение неточностей реализации процессорной
архитектуры x86, с целью повысить прозрачность с точки зрения динамического
анализа.
В качестве эталона для сравнения выступают реальный процессор или виртуальная
машина с большей точностью эмуляции.
Такие системы описаны в работах EmuFuzzer [[$](#ref.EmuFuzzer)],
KEmuFuzzer [[$](#ref.KEmuFuzzer)] и PokeEMU [[$](#ref.PokeEMU)].
* Системы генерации тестов для тестирования реализации не только процессорной
архитектуры x86. Эталоном является реальный процессор.
К данному типу относится системы RISU [[$](#ref.RISU)] и
MicroTESK [[$](#ref.MicroTESK)].
* Системы, использующие в качестве эталона для сравнения другую реализацию
двоичного транслятора.
Такой системой является MeanDiff [[$](#ref.MeanDiff)].

Далее кратко будет рассмотрена каждая из этих систем.

## $.$ EmuFuzzer, KEmuFuzzer и PokeEMU

EmuFuzzer — прототип, в котором реализована полностью
автоматизированная методика тестирования для эмуляторов процессора (Qemu,
Valgrind, Pin и BOCHS), основанная на фаззинге.
Данная методика может быть использована для
автоматического обнаружения расхождений конфигурации среды (т.е. состояние
регистров процессора и содержимое памяти) в эмулируемом и физическом
процессорах.
Для тестирования эмулятора создаётся большое количество тестов, которые
запускаются на эмулируемом и реальном процессорах.
В конце выполнения каждого теста сравниваются конфигурации двух сред.
Любое расхождение является признаком неправильного поведения эмулятора.
<!--
Принимаются две стратегии для генерации тестовых сценариев: только случайная
генерация и гибридная алгоритмическая/случайная генерация.
Последнее гарантирует, что каждая инструкция в наборе команд проверяется,
по крайней мере, в некоторых выбранных контекстах выполнения.
-->

KEmuFuzzer — прототип, который реализует автоматизированную методику (как и
EmuFuzzer) для тестирования четырёх современных виртуальных машин: BOCHS, Qemu,
VirtualBox и VMware.
Отличие от EmuFuzzer в том, что тестируются полносистемные эмуляторы, и что в
качестве эталона выступает KVM.

PokeEMU — инструмент тестирования эмулятора.
Он автоматически генерирует наборы тестов с большим покрытием и сравнивает
поведение эмулятора с реальной машиной, выполняя тесты на обоих из них.
Инструмент генерирует тестовые сценарии с помощью символьного выполнения.
Данным инструментом был протестирован Qemu.
PokeEMU также использует в качестве эталона KVM.

Имеются ещё работы подобного типа, такие как [[$](#ref.hi_4_lo)] и
[[$](#ref.pill_testing)].

## $.$ RISU и MicroTESK

Инструмент RISU (Random Instruction Sequences for Userspace) – инструмент для
проверки точности реализации набора инструкций процессора в таких виртуальных
машинах, как Valgrind и Qemu.
Он состоит из двух частей.

* Генератор, который выводит случайный машинный код на основе
входного файла, описывающего шаблоны набора инструкций.
* Тестовая программа, которая запускает сгенерированный код, как на
тестируемом, так и на реальном оборудовании.

Инструмент может использоваться для тестирования эмуляторов, предназначенных
для запуска пользовательских приложений, например, Valgrind и Qemu linux-user.
Для архитектуры ARM RISU поддерживает тестирование 32-битных наборов команд
A32 (ARM) и T32 (Thumb), а также 64-битного набора команд A64.
Инструмент также поддерживает архитектуры PPC и m68k.

Инструмент MicroTESK (Microprocessor TEsting and Specification Kit) – среда
генерации тестовых программ на языке ассемблера целевой процессорной
архитектуры для функциональной верификации микропроцессоров.
Также данный инструмент предоставляет возможность автоматизированного
конструирования генераторов тестов на основе формальных спецификаций
необходимой процессорной архитектуры.
Такие тесты можно запускать в Qemu и на реальном процессоре с целью
выявления расхождений в их поведении.

## $.$ MeanDiff

MeanDiff — инструмент тестирования промежуточных представлений для двоичных
трансляторов.
Он реализует идею поиска семантических ошибок во фронтендах (binary lifters)
существующих двоичных трансляторов.

Подход к тестированию, лежащий в основе инструмента, заключается в том, что
на вход двоичным трансляторам подаётся некоторый машинный код.
Данный код переводится трансляторами в своё промежуточное
представление.
Далее вводится некоторое специальное унифицированное промежуточное
представление, которое используется для объединения каждого полученного
промежуточного представления в единую форму.
Затем все полученные промежуточные представления транслируются в
унифицированное промежуточное представление.
После чего результаты сравниваются между собой и производится проверка на
наличие семантических расхождений.
Данным инструментом можно протестировать правильность реализаций фронтендов
двоичных трансляторов, которые имеются в Qemu, Valgrind, BINSEC и т.д.

## $.$ Выводы

В рассмотренных работах можно выделить ряд эталонов, которые используются для
сравнения при тестировании реализации процессорной архитектуры в Qemu.
Такими эталонами являются реальный процессор, виртуальная машина с большей
точностью эмуляции, а также другая реализация двоичного динамического
транслятора.
Все они той же процессорной архитектуры, что и тестируемая реализация.
Однако не всегда есть доступ к таким эталонам.
<!-- Эти подробности есть во введении-->
<!--
Это обучловлено недоступностью необходимого реального оборудования, отсутствием
эталонной виртуальной машины или другой реализации двоичного динамического
транслятора нужной процессорной архитектуры.
Суть подхода описана в следующем разделе.
-->
Для решения этой проблемы в данной работе предлагается подход, опирающийся на
альтернативный, но всегда доступный эталон.

# $. Предлагаемый подход к тестированию

В рассмотренных системах тестирования используется подход на основе сравнения с
эталоном.
Один и тот же машинный код запускается в тестируемой реализации процессорной
архитектуры и в эталоне. Затем сравниваются выходные значения.
В основе предлагаемого в данной работе подхода к тестированию фронтендов TCG
различных процессорных архитектур, также лежит сравнение с эталоном.
Однако идея предлагаемого подхода заключается в создании машинного кода,
который будет подаваться на вход существующему эталону другой процессорной
архитектуры (к которому имеется доступ всегда).
При выполнении этот машинный код должен в определенных точках давать выход,
одинаковый с выходом в тех же точках, но если бы оригинальный машинный код был
выполнен в отсутствующем эталоне.
<!--
(см. рис. [$](#pic.Approach_base).

![Рисунок <a name="pic.Approach_base">$</a> --- Подход к тестированию
](approach_base.png)
-->

Это предлагается достичь за счет написания тестовых сценариев на языке
программирования высокого уровня, что дает следующие возможности для
тестирования:

<!--
Стандарты таких языков дают гарантии определенности поведения некоторого кода
не зависимо от реализации компилятора.
Что позволяет писать программы, которые можно собрать под разные архитектуры.
Однако имеются ограничения, которые необходимо аккуратно соблюдать.
При этом будем считать, что процессор и компилятор реализованы без ошибок, так
как вероятность наличия в них ошибок много меньше, чем в тестируемой реализации
процессорной архитектуры.
Написание тестов на языке программирования высокого уровня дают следующие
возможности для тестирования:
-->

* Уход от машинной зависимости тестов, которые в существующих решениях пишутся
на языке ассемблера или генерируются в виде машинного кода, то есть являются
архитектурно-зависимыми.
Это предоставляет возможность использовать один раз написанный тест для
тестирования фронтендов TCG различных архитектур.
* Возможность использовать в качестве эталона для сравнения — персональный
компьютер.

Наиболее подходящим для решения данной задачи является использование
высокоуровневого языка программирования Си.
Этот язык достаточно близок к
аппаратуре и для него имеются компиляторы под большинство процессорных
архитектур.
Однако в стандарте языка Си говорится о ситуациях когда поведение
некоторых конструкций языка может быть различным в зависимости от платформы и
реализации компилятора (undefined behaviour и implementation-defined behavior).
Если аккуратно избежать попадания в данные ситуации, то скомпилированная
программа на Си должна одинаково выполняться независимо от процессорной
архитектуры и компилятора.
При этом будем считать, что процессор и компилятор реализованы без ошибок, так
как вероятность наличия в них ошибок много меньше, чем в тестируемой реализации
процессорной архитектуры.
<!--
То есть программу на Си можно написать так, что её получится скомпилировать под
разные процессорные архитектуры.
Это обусловлено тем, что данный язык является кроссплатформенным и используется
в разработке системного программного обеспечения, в некоторой мере вытеснив
язык ассемблера.
-->
Немаловажным также является наличие для языка Си множества компиляторов с
открытым исходным кодом, что предоставляет важные возможности для тестирования
новых фронтендов TCG.
<!--
Что является важным по причине того, что не всегда есть доступ к необходимому
реальному процессору.
-->
Таким образом, предлагаемый подход заключается в компиляции программы (теста),
написанной на языке Си, под гостевую архитектуру и архитектуру эталона.
А также в её запуске в Qemu и эталоне с целью сравнить поведение данной
программы.

<a name="rel.InstLimits"></a>
Для тестируемого фронтенда TCG создан ряд тестов, написанных, как было
указано ранее, на языке программирования Си.
Однако, уйдя от архитектурной зависимости тестов, возникает проблема:
не всегда возможно добиться от компилятора использования некоторых инструкций.
В некоторых случаях от разработчика тестов требуется определённая
изобретательность.
В крайнем случае, интересующую инструкцию можно внедрить ассемблерной вставкой,
а при помощи препроцессора добиться, чтобы для эталона вместо этой инструкции
выполнялся эквивалентный Си-код.
Данное решение является предметом дальнейших исследований.
Также процессоры часто обладают инструкциями, семантика которых не описывается
языком Си.
Например, инструкция остановки процессора до следующего аппаратного
прерывания (`hlt` в i386) или векторные инструкции (расширение SSE для x86).
Тестирование таких инструкций выходит за рамки данной работы.

Таким образом, средство c2t главным образом ориентировано на проверку
правильности реализации:
арифметики, логики, битовых операций, ветвлений и работы со стеком.

* арифметики — сложение, вычитание, умножение, деление;
* побитовых операций — умножение, сложение, сложение по модулю 2, инверсия,
сдвиги;
* обработки данных и операций с памятью — операции с регистрами, стеком и т.д.;
* операций изменения потока управления — вызовы подпрограмм, условная и
безусловная передача управления, возврат управления.

Другими словами то, что возможно покрыть программой, написанной на языке Си.
Достигается это за счёт одинаковой логики работы с переменными (переменная
используется, как понятие языка программирования Си) тестовых сценариев,
несмотря на отличие архитектурных особенностей эталона и тестируемой
виртуальной машины.
Получение состояний переменных обеспечивается с помощью модуля отладки, т.к.
эмулятор и эталон оперируют понятиями: память и регистр процессора.
Подробно об этом рассказано [[$](#rel.pyrsp)].

Однако при составлении таких тестовых программ необходимо учитывать
некоторые тонкости.
Например, для того, чтобы компилятор не устранил переменную как избыточную при
оптимизации, нужно использовать для данной переменной квалификатор типа
`volatile`.
Другим примером является то, что
часто при программировании микроконтроллеров тип `int` языка Си
имеет диапазон значений (размер), который отличается от того диапазона, к
которому
привыкли Си-программисты под IA32 и AMD64.
В данном случае рекомендуется использовать подходящий тип из `<stdint.h>`.
Например, `int32_t` или `int16_t` — в зависимости от того, какой диапазон
значений на самом деле нужен.
При этом, явное указание диапазона значений переменной может влиять на выбор
компилятором определённых вариантов инструкций, а также поможет проверить
правильность
реализации в эмуляторе поведения при переполнении.
Рассмотрение всех особенностей, выходит за рамки данной работы.

Важно заметить, что при сравнении пути выполнения программы на каждом шаге
сравнивается
не счётчик команд, как это происходит в
EmuFuzzer и KEmuFuzzer, а позиция в коде тестового сценария (номер строки).
Разумеется, что ни эмулятор, ни эталон не могут предоставить такую
высокоуровневую информацию: им доступно только значение своего счётчика команд.
Поэтому тут тоже задействован модуль отладки.
<!--
Он вычисляет
требуемые значения, используя отладочную информацию, полученную от компилятора.
-->

Так как сравнение состояний всех переменных после выполнения каждой строки
теста в ходе проведения тестирования является избыточным, то необходим
механизм указания определённых строк и имён переменных для сравнения.
Другими словами: механизм тонкой настройки тестирования.
Данный механизм реализован путём добавления специальных управляющих
комментариев напротив необходимых строк исходного кода теста
(см. рис. [$](#pic.Approach)).

![Рисунок <a name="pic.Approach">$</a> --- Схема осуществления тестирования
](approach.png)

<!-- А рисунок сразу идёт в PNG? иначе лучше добавить исходник и команду в
Makefile -->

Сам факт наличия такого комментария к строке означает, что на данной строке
будет приостановлено выполнение теста эталоном и тестируемой виртуальной
машиной, и будут получены состояния переменных для дальнейшего сравнения.
Другими словами, комментарии указывают c2t места, на которые необходимо
поставить точки останова, а также имена переменных, значения которых
необходимо проверить.

Стоит отметить, что для проверки корректности функционирования фронтенда TCG,
сравнение значений переменных и позиции выполнения является практически
достаточным для большинства случаев.
Архитектурные особенности основной и целевой системы отличаются, но логика
работы с переменными у них одинаковая.
Немаловажным является то, что предложенный подход к тестированию
автоматизируется.

Также стоит отметить, что создание тестов, которые обеспечивают наибольшее
покрытие по инструкциям, реализованных в тестируемом фронтенде TCG, является
отдельной сложной задачей и выходит за рамки данной работы.
<!--
Ты писал, что архитектурно зависимые инструкции не тестируются.
Следовательно, это замечание про то, что не всегда можно проверить арифметику,
логику, ветвления и т.д.?
Тогда нужно пояснить, в чём же проблема: какие-то тесты же всё-таки написаны
в ходе данной работы.
Что ты вообще понимаешь под покрытием в этом тексте?
Нужно явно обозначить, что арх. зав. инструкции не учитываются воовсе.
И привести примеры таких иснтрукций.
Желатально такие, которые в принципе не могут быть написаны на языке Си без
ассемблерных вставок.
-->

<a name="rel.pyrsp"></a>
# $. Реализация автоматизированного тестирования

Предложенный подход к тестированию предполагает для сравнения значений
переменных использование отладчика и добавление отладочной информации на этапе
компиляции.
В Qemu реализован сервер внешней отладки гостевого кода по
протоколу удалённой отладки GDB (GDB Remote Serial Protocol), основными
возможностями которого являются:

* чтение/запись значений регистров процессора;
* чтение/запись в оперативную память;
* установка точек останова по управлению (breakpoint);
* установка точек останова по обращению к памяти (watchpoint).

Это означает, что для отладки гостевого кода может быть использован отладчик,
поддерживающий данный протокол.
Например, отладчик GDB.
Однако использование отладчика GDB для проведения тестирования
фронтенда Qemu усложняет процесс
подготовки к проведению тестирования.
Это обусловлено высокой трудоёмкостью процесса модификации отладчика GDB,
как и любого другого отладчика, ориентированного на взаимодействие с
человеком и не являющегося программной библиотекой.
Таким
образом, необходимо использовать средство отладки, предоставляющее
достаточную гибкость.
В качестве решения данной проблемы выступает отладочный API QDT.
QDT является инструментом автоматизации разработки моделей устройств и
вычислительных машин для Qemu, написанный на языке программирования Python.
Исходный код QDT является открытым.
Отладочный API QDT использует модуль "pyrsp" [[$](#ref.pyrsp)] с открытым
исходным кодом, также написанный на языке Python.
Модуль "pyrsp" реализует API для взаимодействия по протоколу RSP.
Также отладочный API QDT использует модуль "pyelftools" [[$](#ref.pyelftools)]
для работы с отладочной информацией в формате DWARF.
На основе данного API и реализовано программное средство
автоматизированного тестирования фронтенда транслятора Qemu:
c2t (CPU Testing Tool).
<!--
Оно называется c2t (CPU Testing Tool) и входит в состав QDT.
Данное программное средство реализовано на языке программирования Python,
-->
c2t
поддерживает тестирование Qemu в режиме полносистемной эмуляции и в режиме
эмуляции уровня пользователя.

Обычно при тестировании TCG виртуальные устройства не представляют интереса.
Более того, их деятельность может мешать.
Т.е. поддержки эмуляции уровня пользователя достаточно.
Однако возможность эмуляции уровня пользователя имеется не для всех архитектур.
Для поддержки реализации таких архитектур (в том числе) применяется
полносистемная версия Qemu.
Хотя это уже не является, строго говоря, тестированием фронтенда TCG.
Однако необходимость в проверке реализации подобных нюансов работы остаётся.

Ниже представлена схема осуществления тестирования с использованием
разработанного программного средства.

![Рисунок <a name="pic.System">$</a> --- Схема проведения тестирования
](system.png)

Конфигурация тестирования реализуется путём добавления управляющих
комментариев в исходном коде теста, которые являются выражениями на языке
Python, выполняемыми штатными средствами в окружении, настроенном нужным
образом.
Данные комментарии пишутся человеком, проводящим тестирование, и содержат
команды специального вида, задающие проверки, которые будут выполнены во время
тестирования.
На данный момент программным средством поддерживаются следующие команды:

* br – установка точки останова для однократной проверки соответствия позиций
выполнения тестового сценария;
* brc – установка точки останова для многократной проверки соответствия позиций
выполнения тестового сценария;
* bre – завершить выполнение теста;
* ch – установка точки останова для однократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;
* chc – установка точки останова для многократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;

Пример теста и конфигурации тестирования, с использованием управляющих
комментариев, представлен следующим кодом.

<!--это нужно обозвать рисунком или, не уверен, листингом-->

+-----------------------------------------------------------------------------+
|```                                                                          |
|int main(void) {                                                             |
|    volatile uint32_t a = 0xABCDEF, b = 0x12345678, c = 0, i;                |
|                                                                             |
|    for(i = 0; i < 20; i++) {                                                |
|        if(i % 2) {                                                          |
|            // однократная проверка позиций выполнения                       |
|            c = b - a; //$br                                                 |
|        }                                                                    |
|        else {                                                               |
|            // многократная проверка позиций выполнения                      |
|            c = b + a; //$brc                                                |
|        }                                                                    |
|                                                                             |
|        // однократная проверка значений всех переменных                     |
|        c = b & a; //$ch                                                     |
|                                                                             |
|        // однократная проверка значений переменной `c`                      |
|        c = b | a; //$ch.c                                                   |
|                                                                             |
|        // многократная проверка значений переменной `c`                     |
|        c = b ^ a; //$chc.c                                                  |
|                                                                             |
|        /* Также есть возможность комбинировать команды:                     |
|          - однократная проверка позиций выполнения и                        |
|            значений переменных `a` и `b`                                    |
|          - многократная проверка значений переменной `c`                    |
|        */                                                                   |
|        c = 0; //$br, chc.c, ch.a, ch.b                                      |
|    }                                                                        |
|                                                                             |
|    // завершить тестирование                                                |
|    return 0; //$bre                                                         |
|}                                                                            |
|```                                                                          |
+-----------------------------------------------------------------------------+

<a name="rel.RSPNeed"></a>
Для поддержки тестирования в Qemu необходимо добавить код, предоставляющий
возможность отладчику читать и писать в регистры процессора, а также отвечающий
за поддержку установки отладочных точек останова (вставка транслятором
необходимого кода tcg, реализующего точки останова).
Поддержка RSP не является обязательным требованием к реализации процессорной
архитектуры в Qemu.
Однако так как ее достаточно просто добавить, и RSP используется QDT, будем
считать, что его поддержка имеется всегда.

Программное средство c2t поддерживает многопоточный режим.
Несколько тестов могут выполняться параллельно.
Также оно имеет режим вывода промежуточной информации в ходе проведения
тестирования.
На момент написания данной работы реализовано 145 тестов.
Названия тестов, которые тестировщику необходимо запустить,
задаются регулярными выражениями.

# $. Описание экспериментального стенда

В качестве эталона использовался персональный компьютер на базе процессора
архитектуры AMD64.
Версии ПО, использованного в эксперименте приведены в
таблице [$](#tbl.sw_versions).
Звёздочкой помечены реализации, находящиеся в официальной ветке "master".

Таблица <a name="tbl.sw_versions">$</a>. Версии использованного ПО

+----------+--------+-------+
| фронтенд |  Qemu  | GCC   |
+----------+--------+-------+
| ARM      | 2.5.0* | 4.9.3 |
+----------+--------+-------+
| MIPS     | 2.5.0* | 5.4.0 |
+----------+--------+-------+
| MSP430_1 |        | 7.3.2 |
+----------+--------+-------+
| MSP430_2 | 2.12.1 | 7.3.2 |
+----------+--------+-------+

<!--
Протестированы следующие версии Qemu:

* для ARM и MIPS: 2.5.0 (официальная),
* для MSP430_1*[]*: *TODO*,
* для MSP430_2: *TODO*.

Для сборки тестов были использованы следующие кросс-компиляторы: для
архитектуры ARM – `gcc` версии 4.9.3, для MIPS – `gcc` версии 5.4.0 и для
MSP430 – `gcc` версии 7.3.2.
-->
Покрытие было оценено `gcov` версии 5.4.0.

# $. Оценка покрытия

Фронтенд транслятора TCG реализован на языке Си.
Реализация фронтенда TCG представляет собой набор вложенных
конструкций `switch` (синтаксический анализатор), ветки которых содержат
семантики соответствующих машинных инструкций.
Данные семантики выражаются на промежуточном представлении TCG.
Генерация кода TCG осуществляется путём вызова специальных функций.
В данной работе было проведена оценка двух покрытий.
Под первым покрытием подразумевается количество выполненных (покрытых) ветвей
конструкций `switch` фронтенда TCG, соответствующих уникальным инструкциям
гостевого процессора.
Оценка данного покрытия была произведена с использованием утилиты `gcov` для
исследования покрытия кода.
Данная утилита входит в состав пакета GCC.
Под вторым покрытием подразумевается количество выполненных Qemu
уникальных инструкций гостевого процессора.
Для оценки данного покрытия Qemu запускалась в режиме пошагового выполнения
(`-singlestep`) и с включенной отладочной трассировкой (`-d exec,nochain`).
Затем с помощью дизассемблера был определен набор покрытых инструкций.
Результаты оценки покрытий сошлись.
Это обусловлено тем, что семантики интересующих инструкций содержатся в
отдельных ветвях конструкций `switch`.
Далее приводится разъяснение того, какие инструкции в данной работе
считаются _разными_.
Очевидно, что инструкции сложения и умножения всегда можно
назвать разными.
Но часто инструкции поддерживают разные режимы адресации операндов:

 * непосредственное значение;
 * регистр (т.н. "прямая адресация");
 * ячейка памяти, адресуемая значением в регистре (т.н. "косвенная
 адресация") и др.

Архитектура MSP430 имеет 7 режимов адресации.
Даже если семантика инструкции не меняется при изменении режима
адресации одного из операндов, то всё равно используется другой
код из реализации фронтенда.
А разработчику важно покрыть весь код фронтенда.
Вариативность не ограничивается режимами адресации и всегда зависит
от конкретной архитектуры процессора.
Таким образом, критерий одинаковости инструкций зависит как от
архитектуры, так и от решаемой разработчиком задачи.
Отдельной сложностью является то, что язык Си не позволяет явно
влиять на выбор компилятором нужного варианта инструкции.
Однако, часто не трудно подобрать оптимизации и/или переписать
код теста.
В общем случае, это — творческая задача.
Далее описываются критерии, которых придерживались авторы для
протестированных в данной работе гостевых архитектур.

## $.$ Классификация инструкций

Инструкции получаются из 145 тестов на Си, имеющихся на момент написания работы
(они входят в состав c2t).
Данные тесты содержат следующие операции, предоставляемые языком Си:

1. Присваивание (`=`).
2. Арифметические: сложение (`+`), вычитание (`-`), умножение (`*`)
и деление (`/`).
3. Побитовые: умножение (`&`), сложение (`|`), сложение по модулю 2 (`^`),
отрицание (`~`), сдвиги вправо (`>>`)/влево (`<<`).
4. Сравнения: равенство (`==`), неравенство (`!=`), больше (`>`),
меньше (`<`), больше или равно (`>=`), меньше или равно (`<=`).

Также имеются тесты, которые содержат условные конструкции, циклы, вызовы
функций и вызовы функций с большим количеством параметров.
Данными тестами можно проверить реализации инструкций передачи и возврата
управления,
а также работу со стеком.
Последнее относится к тестам, содержащим вызовы функций с большим
количеством параметров.
Это гарантируется размещением в стеке входных параметров перед вызовом функции.
Чтобы проверить реализации различных вариаций одной и той же инструкции
процессора, тесты выполнены в вариантах, содержащих 8, 16, 32 и 64 разрядные
знаковые и беззнаковые переменные.

<!--
Как было написано [$](#rel.InstLimits), данным подходом нельзя покрыть
специфичные для конкретного процессора инструкции.
-->

Для подтверждения работоспособности (применимости) предложенного в рамках
данной
работы подхода было произведено тестирование существующих в официальном
репозитории Qemu
реализаций процессорных архитектур ARM32 и MIPS32.
И ещё двух реализаций, не находящихся в официальном репозитории, процессорной
архитектуры
MSP430 (далее MSP430_1 и MSP430_2).
Тесты для данных архитектур были скомпилированы соответствующим компилятором
`gcc` с выключенными оптимизациями (`-O0`).
Реализация MSP430_1 доступна по адресу
https://github.com/draperlaboratory/qemu-msp.
Однако для того, чтобы протестировать данную реализацию, потребовалось внести
в неё поддержку RSP, согласно требованиям, обозначенным [$](#rel.RSPNeed).
Также потребовалось сократить количество тестов.
Это сделано по причине того, что в архитектуре MSP430 умножение реализуется
аппаратно: на микроконтроллере присутствует специальное периферийное устройство.
А модель соответствующего устройства в эмуляторе пока отсутствует.
<!--
А деления я там вообще не вдел...
Это сделано по причине того, что в архитектуре MSP430 такие арифметические
инструкции, как умножение и деление, реализуются аппаратно.
А реализации соответствующих устройств пока отсутствуют.
-->

Реализация MSP430_2 является собственной реализацией, в которой были умышленно
допущены ошибки с целью выявления их программным средством тестирования.
Все эти ошибки были успешно обнаружены.
Также были обнаружены и неумышленные ошибки.

Инструкции процессора можно разбить на следующие классы:

1. Обработка данных и операции с памятью.
2. Арифметические и логические операции.
3. Операции изменения потока управления.
4. Инструкции сопроцессора.
5. Специфичные для процессора.

Как было сказано [$](#rel.InstLimits), тестирование реализации инструкций 5
класса выходит за рамки данной работы и, следовательно, их нецелесообразно
включать в оценку покрытия.
Под инструкциями 4 класса в большей мере подразумеваются инструкции работы над
числами с плавающей запятой.
Некоторые из таких инструкций возможно покрыть предлагаемым подходом, но в
данный момент таких тестов нет.
К сожалению, с 4 классом может возникнуть ситуация, схожая с 5 классом.
Это обусловлено возможностью наличия в 4 классе инструкций, семантику которых
нельзя выразить языком программирования Си.
Таким образом, инструкции 4 класса также не входят в оценку покрытия.

## $.$ Покрытые инструкции

В таблице [$](#tbl.isa_cover_num) содержатся полученные результаты по
покрытию тестированием ветвей фронтенда транслятора TCG.
Представлено отношение количества покрытых ветвей конструкций `switch` от
общего количества ветвей, содержащих семантику уникальных инструкций.
Данный результат также соответствует отношению количества выполненных Qemu
инструкций от общего количества инструкций тестируемой гостевой процессорной
архитектуры, реализованных в Qemu.
В подсчёт общего количества инструкций для каждой из таких процессорных
архитектур вошли уникальные по семантике инструкции 1, 2 и 3 классов.
Те инструкции, которые возможно покрыть тестами, имеющимися на момент написания
работы.
Из полученного результата исключено число инструкций, которые предназначены для
удобства написания
программ и которые реализуются ассемблером.
Примерами таких инструкций для архитектуры ARM32 являются `adr`
(загрузить адрес в регистр, реализуется инструкцией `add` или `sub`),
`push` (положить в стек, реализуется инструкцией `stm`)
и `pop` (достать из стека, реализуется инструкцией `ldm`).
Для архитектуры MIPS32: `li` (загрузить "непосредственное" значение в регистр,
реализуется инструкциями `lui` и `ori`) и `move` (копировать значение регистра
в регистр, реализуется инструкцией `or`).
Для архитектуры MSP430: `pop` (достать из стека, реализуется инструкцией
`mov` со специальным режимом адресации), `inc` (инкрементировать,
реализуется инструкцией `add`) и `ret`
(возврат из подпрограммы, реализуется инструкцией `mov`).
<a name="rel.cover_addge"></a>
Также все различные вариации отдельно взятой инструкции при подсчёте
рассматриваются как одна инструкция.
Например, для архитектуры ARM32 в качестве таких инструкций выступают
инструкции с условным выполнением (например, `addge`), а также обновляющие
значения флагов (например, `adds`).
Не вошли в подсчет и специфичные для конкретного процессора инструкции.
Информация для подсчёта общего количества инструкций была взята из
[[$](#ref.arm_isa)], [[$](#ref.mips_isa)] и [[$](#ref.msp430_isa)].

Таблица <a name="tbl.isa_cover_num">$</a>. Количество покрытых инструкций

+----------+---------+-------+-----+
|   ISA    | Покрыто | Всего |  %  |
+==========+=========+=======+=====+
|  ARM32   |   38    |  61   | 62  |
+----------+---------+-------+-----+
|  MIPS32  |   42    |  67   | 63  |
+----------+---------+-------+-----+
| MSP430_1 |   21    |  27   | 78  |
+----------+---------+-------+-----+
| MSP430_2 |   12    |  19   | 63  |
+----------+---------+-------+-----+

Согласно таблице в среднем покрывается около 60% инструкций.
Такое покрытие не является выдающимся результатом.
Однако данное покрытие возможно достичь, приложив небольшие усилия.
Необходимо добавить поддержку процессорной архитектуры в c2t и установить
компилятор для данной архитектуры.

Тем не менее разработанный инструмент предоставляет возможность покрыть
инструкции, о которых было сказано
[$](#rel.cover_addge).
Например, инструкцию `addge` (сложить, если истинно условие "больше
или равно") можно покрыть следующим кодом.

+-----------------------------------------------------------------------------+
|```                                                                          |
|void main(void)                                                              |
|{                                                                            |
|    volatile int32_t a = 0xa, b = 0xb, c;                                    |
|    if (a >= b)                                                              |
|        c = a + b;                                                           |
|    return;                                                                  |
|}                                                                            |
|```                                                                          |
+-----------------------------------------------------------------------------+

При этом необходимо скомпилировать его, включив оптимизацию размера кода
(параметр `-Os` для компилятора gcc).
Это также актуально и для некоторых других архитектур, имеющих инструкции,
которые выполняются, если истинно условие.
Создание тестов, покрывающих различные вариации отдельных инструкций, является
архитектурно зависимой задачей и выходит за рамки данной работы.

Реализация архитектуры ARM32 была протестирована путём запуска тестов на
виртуальных процессорах cortex-m3 и arm926.
Реализация архитектуры MIPS32 была протестирована путём запуска тестов на
виртуальных процессорах r4000 и 4kc.

Для тестирования ARM32 и MIPS32 были использованы все 145 тестов, для MSP430_1
— 69 тестов, а для MSP430_2 — 49 тестов.

В таблице [$](#tbl.isa_cover) представлены все инструкции, покрытые и
непокрытые тестированием, с разбиением их по классам.
Для процессорной архитектуры ARM32 запись `bl(cc)` в непокрытых инструкциях
3 класса является сокращённой записью 14 инструкций.
Она подразумевает все условные вариации инструкции `bl`.

Таблица <a name="tbl.isa_cover">$</a>. Список покрытых/не покрытых инструкций

+---------+-----+------------------------------+------------------------------+
|   ISA   |Класс|     Покрытые инструкции      |    Не покрытые инструкции    |
+=========+=====+==============================+==============================+
|  ARM32  |  1\ | ldr, mov, str, stm, ldm, mvn\| —\                           |
|         |  \  |               \              |               \              |
|         |  2\ | sub, lsl, lsr, eor, cmp,\    | smull, smlal, umlal, cmn,\   |
|         |  \  | rsb, asr, add, adc, and,\    | teq, bic\                    |
|         |  \  | mul, orr, tst, mla, sbc,\    |               \              |
|         |  \  | rrx, rsc, umull, ror\        |               \              |
|         |  \  |               \              |               \              |
|         |  3\ | b, bl, bmi, beq, bcs, ble,\  | bpl, bvs, bvc, bl(cc)\       |
|         |  \  | blt, bhi, bne, bls, bcc,\    |               \              |
|         |  \  | bgt, bge                     |               \              |
+---------+-----+------------------------------+------------------------------+
| MIPS32  |  1\ | movn, lb, lw, slt, sltiu,\   | movz, mthi, mtlo, ll, lh,\   |
|         |  \  | slti, sltu, lbu, mflo, mfhi,\| lwl, lwr, swl, swr, sc\      |
|         |  \  | lui, sw, lhu, sh, sb\        |               \              |
|         |  \  |               \              |               \              |
|         |  2\ | addu, addiu, subu, mul,\     | add, addi, sub, clo, clz,\   |
|         |  \  | multu, mult, div, divu, nor,\| madd, maddu, msub, msubu,\   |
|         |  \  | sllv, srlv, and, sll, xor,\  | xori\                        |
|         |  \  | srav, ori, andi, sra, srl,\  |               \              |
|         |  \  | or\                          |               \              |
|         |  \  |               \              |               \              |
|         |  3\ | bltz, bgtz, jal, bne, beq,\  | blez, bgez, bltzal, j, jalr\ |
|         |  \  | jr, bgezal\                  |               \              |
+---------+-----+------------------------------+------------------------------+
|MSP430_1 |  1\ | mov, push, sxt\              | swpb\                        |
|         |  \  |               \              |               \              |
|         |  2\ | add, addc, sub, subc, cmp,\  | dadd\                        |
|         |  \  | and, bis, xor, rra, rrc, bit\|               \              |
|         |  \  | bic\                         |               \              |
|         |  \  |               \              |               \              |
|         |  3\ | call, jnz, jge, jc, jeq, jl\ | reti, jmp, jn, jnc           |
+---------+-----+------------------------------+------------------------------+
|MSP430_2 |  1\ | mov\                         | —\                           |
|         |  \  |               \              |               \              |
|         |  2\ | add, sub, cmp, and, bis, xor\| bit, addc, bic\              |
|         |  \  |               \              |               \              |
|         |  3  | call, jnz, jeq, jge, jl      | jc, jmp, jn, jnc             |
+---------+-----+------------------------------+------------------------------+

Из таблицы можно сделать вывод, что для всех протестированных в данной работе
архитектур, покрыты основные
арифметические и логические инструкции, инструкции обработки данных и работы с
памятью, инструкции изменения потока управления.
Не покрыты некоторые инструкции условного перехода.
Это обусловлено тем, что в языке Си нет выражений, имеющих семантику
соответствующих инструкций.
Некоторые инструкции не покрыты по причине отсутствия необходимых тестов.
Например, для архитектуры ARM32 инструкция `bic` (очистка определённых битов).
<!--Создание таких тестов выходит за рамки данной работы.-->

<!--
С помощью данного программного средства была обнаружена специально допущенная
ошибка реализации инструкции sub в MSP430_2.
-->
<!-- Она была специально оставлена. Допустили её случайно. -->

## $. Направления дальнейших исследований

Перспективными направлениями дальнейших исследований являются:

* Исследование влияния применения оптимизаций компилятора на покрытие
инструкций и сам подход.
Необходимо оценить, как будет улучшаться покрытие кода.
Также необходимо использовать при написании тестов различные приемы, снижающие
негативное влияние оптимизаций.
Например, оптимизации могут «перемешивать» отображения строк исходного кода на
строки машинного кода, в таком случае необходимо использовать `asm volatile`.
* Создание тестов с наибольшим покрытием инструкций, а также автоматизация
данного процесса.
* Способы принуждения компилятора к использованию определённых гостевых
инструкций.

# $. Заключение

В ходе данной работы был проведён анализ существующих решений тестирования
фронтенда транслятора TCG эмулятора Qemu.
Было установлено, что рассмотренные решения используют для сравнения эталон той
же процессорной архитектуры, что и у тестируемой реализации.
Данное требование делает неприменимыми эти решения при отсутствии такого
эталона.

В работе предложен подход к тестированию, который нацелен решить указанную
проблему.
Идея предлагаемого подхода заключается в том, что можно написать программу на
языке высокого уровня так, что её получится скомпилировать под разные
процессорные архитектуры.
Тем самым достигается возможность использовать фиксированный эталон —
процессор машины разработчика.
Однако накладывается ограничение на покрытие реализаций инструкций, специфичных
для конкретной процессорной архитектуры.
На основе данного подхода реализовано программное средство автоматизированного
тестирования.

Применимость подхода была подтверждена тестированием реализаций двух
процессорных архитектур (ARM32 и MIPS32), находящихся в официальном репозитории
Qemu.
И ещё двух реализаций (MSP430_1 и MSP430_2), не находящихся в официальном
репозитории.
В собственной реализации MSP430_2 были обнаружены как умышленно оставленные
ошибки, так и не умышленные ошибки.

Также в работе приведена оценка покрытия инструкций процессорных архитектур
для протестированных реализаций.
Согласно полученному результату в среднем покрывается около 60% инструкций.
Такое покрытие не является выдающимся результатом.
Однако данное покрытие возможно достичь, приложив небольшие усилия.
Предложенным подходом удалось покрыть основные арифметические и логические
инструкции, инструкции обработки данных и работы с памятью, инструкции
изменения потока управления.

# Список литературы

[$]. <a name="ref.QDT"></a>Ефимов В.Ю., Беззубиков А.А., Богомолов Д.А.,
Горемыкин О.В., Падарян В.А. Автоматизация разработки моделей устройств и
вычислительных машин для QEMU. Труды ИСП РАН, том 29, вып. 6, 2017 г.,
стр. 77-104. DOI: 10.15514/ISPRAS-2017-29(6)-4.

[$]. <a name="ref.TCGgen"></a>Bezzubikov A., Belov N., Batuzov K. Automatic
dynamic binary translator generation from instruction set description // 2017
Ivannikov ISPRAS Open Conference (ISPRAS). — Vol. 1. — Moscow, Russia, 2017.

[$]. <a name="ref.oracle_testing"></a>W. E. Howden, "Theoretical and empirical
studies of program testing", Proc. 3rd Int. Conf. Software Engineering, pp.
305-311, 1978.

[$]. <a name="ref.EmuFuzzer"></a>Lorenzo Martignoni, Roberto Paleari,
Giampaolo Fresi Roglia, Danilo Bruschi, Testing CPU emulators, Proceedings of
the eighteenth international symposium on Software testing and analysis, July
19-23, 2009, Chicago, IL, USA.

[$]. <a name="ref.KEmuFuzzer"></a>Lorenzo Martignoni, Roberto Paleari,
Giampaolo Fresi Roglia, Danilo Bruschi, Testing system virtual machines,
Proceedings of the 19th international symposium on Software testing and
analysis, July 12-16, 2010, Trento, Italy.

[$]. <a name="ref.hi_4_lo"></a>L. Martignoni, S. McCamant, P. Poosankam,
D. Song, and P. Maniatis, "Path-exploration lifting: Hi-fi tests for lo-fi
emulators," in Proc. of the International Conference on Architectural Support
for Programming Languages and Operating Systems, London, UK, Mar. 2012.

[$]. <a name="ref.pill_testing"></a>Hao Shi, Abdulla Alwabel, and Jelena
Mirkovic. 2014. Cardinal pill testing of system virtual machines. In
Proceedings of the 23rd USENIX Security Symposium (USENIX Security’14).
271-285.

[$]. <a name="ref.RISU"></a>Risu: random instruction sequence tester for
userspace \[Электронный ресурс\] — Режим доступа:
https://git.linaro.org/people/pmaydell/risu.git/about/
(дата обращения: 09.08.2019).

[$]. <a name="ref.PokeEMU"></a>Qiuchen Yan and Stephen McCamant. 2018. Fast
PokeEMU: Scaling
Generated Instruction Tests Using Aggregation and State Chaining.
In VEE ’18: 14th ACM SIGPLAN/SIGOPS International Conference on
Virtual Execution Environments, March 25, 2018, Williamsburg, VA,
USA. ACM, New York, NY, USA, 13 pages.

[$]. <a name="ref.MeanDiff"></a>Soomin Kim, Markus Faerevaag, Minkyu Jung,
SeungIl Jung, DongYeop Oh, JongHyup Lee, Sang Kil Cha, Testing intermediate
representations for binary analysis, Proceedings of the 32nd IEEE/ACM
International Conference on Automated Software Engineering, October 30-November
03, 2017, Urbana-Champaign, IL, USA.

[$]. <a name="ref.MicroTESK"></a>Камкин А.С., Сергеева Т.И., Смолов С.А.,
Татарников А.Д., Чупилко М.М. Расширяемая среда генерации тестовых программ
для микропроцессоров. Программирование, № 1, 2014, стр. 3-14.

[$]. <a name="ref.arm_isa"></a>ARM and Thumb-2 Instruction Set Quick Reference
Card \[Электронный ресурс\] — Режим доступа:
http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf
(дата обращения 16.07.2019).

[$]. <a name="ref.mips_isa"></a>MIPS Instruction Reference
\[Электронный ресурс\] — Режим доступа:
https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00565-2B-MIPS32-QRC-01.01.pdf
(дата обращения 16.07.2019).

[$]. <a name="ref.msp430_isa"></a>MSP430x2xx Family User's Guide
\[Электронный ресурс\] — Режим доступа:
http://www.ti.com/lit/ug/slau144j/slau144j.pdf
(дата обращения 16.07.2019).

[$]. <a name="ref.pyrsp"></a>pyrsp. \[Электронный ресурс\] — Режим
доступа: https://github.com/stef/pyrsp (дата обращения 02.08.2019).

[$]. <a name="ref.pyelftools"></a>pyelftools. \[Электронный ресурс\] — Режим
доступа: https://github.com/eliben/pyelftools (дата обращения 23.09.2018).

