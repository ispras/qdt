---
title: |
  Автоматизированное тестирование фронтенда транслятора TCG для Qemu
author:
- Колтунов Д.С. &lt;koltunov@ispras.ru>
- Ефимов В.Ю. &lt;real@ispras.ru>
tags: []
abstract: |
  <br>

  **Аннотация.**
  Реализация новой виртуальной процессорной архитектуры в Qemu предполагает
  создание фронтенда динамического двоичного транслятора TCG для данной
  процессорной архитектуры.
  Для проверки правильности реализации данного компонента транслятора
  необходимо тестирование.
  Существующие на сегодняшний день системы тестирования фронтенда TCG для
  некоторой процессорной архитектуры используют подход на основе сравнения с
  эталоном той же процессорной архитектуры.
  В качестве данного эталона могут выступать реальный процессор, виртуальная
  машина с большей точностью эмуляции и другая реализация двоичного
  динамического транслятора.
  Однако не всегда есть доступ к таким эталонам.
  Таким образом, данная работа нацелена на тестирование реализации процессорной
  архитектуры в Qemu при условии отсутсвия необходимого эталона для сравнения
  за счет применения разработанного программного средства автоматизированного
  тестирования.
  В основе программного средства лежит предложенный в данной работе подход к
  тестированию, основная идея которого заключается в том, что программа,
  написанная на языке программирования высокого уровня, должна одинаково
  выполняться независимо от процессорной архитектуры, таким образом достигается
  использование фиксированного и доступного эталона для сравнения.
  Объектами сравнения такого подхода выступают значения переменных (является
  понятием языка программирования высокого уровня, на котором пишутся тестовые
  сценарии).
  <!--
  языка высокого уровня, на котором пишутся тестовые сценарии.
  -->
  Данное программное средство реализовано на языке программирования Python,
  поддерживает тестирование Qemu в режиме полносистемной эмуляции и в режиме
  эмуляции уровня пользователя и под названием c2t (CPU Testing Tool) входит в
  состав инструмента автоматизации разработки моделей устройств и
  вычислительных машин для Qemu [[$](#ref.QDT)], исходный код которого
  доступен по адресу https://github.com/ispras/qdt.
  Разработанные скрипты пригодны как для тестирования фронтендов TCG,
  полученных с использованием системы автоматизации создания фронтендов TCG
  [[$](#ref.TCGgen)], так и реализованных классическим способом (вручную).

  **Ключевые слова**:
  Qemu;
  автоматизированное тестирование фронтенда TCG;
  QDT;
  GDB RSP
...

# $. Введение

# $. Обзор похожих работ

Во всех существующих на сегодняшний день работах по тестированию виртуальных
машин для Qemu используется подход на основе сравнения с эталоном, в качестве
<!--не столько виртуальных машин, сколько именно реализации поддержки
гостевой системы команд процессора, в частности-->
которого является реальный процессор, виртуальная машина, предоставляющая
большую точность эмуляции (например KVM) или другую реализацию двоичного
динамического транслятора.
Такие системы описаны в работах EmuFuzzer [[$](#ref.EmuFuzzer)],
KEmuFuzzer [[$](#ref.KEmuFuzzer)], PokeEMU [[$](#ref.PokeEMU)],
RISU [[$](#ref.RISU)] и MeanDiff [[$](#ref.MeanDiff)].

<!--
[[$](#ref.hi_fi_4_lo_fi)]
-->

Работы EmuFuzzer и RISU направлены на тестирование правильности реализации
процессных виртуальных машин.
<!--а бывают не"процессорные" ВМ?-->
Работы KEmuFuzzer и PokeEMU направлены на тестирование
правильности системных виртуальных машин.
<!--с этим предложением что-то не то-->
Все тестируемые в данных работах виртуальные машины эмулируют окружение под
управлением процессора архитектуры x86, а RISU также под управлением процессора
архитектуры ARM.
В работе MeanDiff [[$](#ref.MeanDiff)] представлен подход к тестированию
фронтендов двоичных динамических трансляторов, например фронтенда транслятора
<!-- например -> в том числе -->
TCG, на основе которого создан Qemu.
<!-- на основе чего создан куему лучше не уточнять, просто скажи, что тцг
входит в его состав -->
Подход состоит в трансляции одного и того же машинного кода различными
трансляторами в собственное промежуточное представление, дальнейшей трансляции
данных промежуточных представлений в одно специальное промежуточное
представление, а затем сравнении полученных специальных промежуточных
представлений.

<!--очень короткий обзор, я думаю, про каждое средство должно быть около
1 килосимвола, чтобы было понятна суть, но без лихних подробностей-->

Однако возникают ситуации, когда отсутсвует доступ к эталону для сравнения.
Для решения этой проблемы в данной работе предлагется подход к тестированию на
основе сравнения с эталоном, доступ к которму имеется всегда.
<!--вот это интрига!-->

EmuFuzzer и KEmuFuzzer -- работы направленные на обеспечение прозрачности.

# $. Предлагаемый подход к тестированию

В основе предлагаемого в данной работе подхода к тестированию фронтендов TCG
различных процессорных архитектур, также как и в рассмотренных подходах, лежит
сравнение с эталоном.
Однако идея предлагаемого подхода заключается в том, что программа, написанная
на языке программирования высокого уровня, должна одинаково выполняться
независимо от процессорной архитектуры.
<!--
Однако, тут не всё так просто.
Автор тестовых программ должен учитывать многие тоности.
Например, часто при программировании микроконтроллеров тип `int` языка Си
имеет длину 16 бит, в то время как Си-программисты под IA32 и AMD64 привыкли,
к длине 32 бита.
В данном случае рекомендуется использовать подходящий тип из `<stdint.h>`:
`int32_t` или `int16_t` --- в зависимости от того, какая длина
на самом деле нужна.
При этом, явное указание длины переменной может влиять на выбор компилятором
определённых вариантов инструкций, а так же правильность реализации в
эмуляторе поведения при переполнении.
Рассмотрение всех особенностей, выходит за рамки данной работы.
-->
Данные программы выступают в качестве тестовых сценариев.
Это необходимо для ухода от процессорной зависимости тестов, которые, в
существующих решениях, пишутся на языке ассемблера или генерируются в виде
машинного кода, что является архитектурно-зависимым.
Наиболее подходящим для решения данной проблемы является использование для
написания тестовых сценариев высокоуровневого языка программирования Си.
Это обусловлено тем, что данный язык является кроссплатформенным и используется
в разработке системного программного обеспечения, в некоторой мере вытеснив
язык ассемблера.
Немаловажным также является наличие для языка Си множества компиляторов с
открытым исходным кодом, что предоставляет важные возможности, для тестирования
новых фронтендов TCG.
Таким образом, достигается возможность использования для сравнения
фиксированного эталона -- персонального компьютера.
Что является важным по причине того, что не всегда есть доступ к необходимому
реальному процессору.

Для тестируемого фронтенда TCG создается ряд тестов, написанных, как было
указано ранее, на языке программирования Си.
Однако, уйдя от архитектурной зависимости тестов, возникает проблема: нельзя
протестировать реализацию многих процессорных инструкций, например, таких как
циклические сдвиги.
Таким образом, тестирование направлено на проверку правильности реализации
некоторой арифметики, логики, битовых операций, ветвлений и других, не
связанных с периферией, инструкций процессора, другими словами то, что возможно
покрыть тестами на языке Си.

Достигается это за счет одинаковой логики работы с переменными (переменная
используется, как понятие языка программирования Си) тестовых сценариев,
несмотря на отличие архитектурных особенностей эталона и тестируемой
виртуальной машины.
Таким образом, в ходе проведения тестирования на каждом его шаге сравниваются
не счетчик команд, состояние регистров и т.д., как это происходит в
EmuFuzzer и KEmuFuzzer, а состояние переменных и позиция выполнения тестового
сценария.
Для сравнения используется отладчик.

Так как сравнение состояний всех переменных после выполнения каждой строки
теста в ходе проведения тестирования является избыточным, то необходим
механизм указания определенных строк и имен переменных для сравнения.
Другими словами, механизм тонкой настройки тестирования.
Данный механизм реализован путем добавления специальных управляющих
комментариев напротив необходимых строк исходного кода теста
[$](#approach.png).

![Рисунок <a name="approach.png">$</a> --- Схема осуществления тестирования
](approach.png)

<!-- А рисунок сразу идёт в PNG? иначе лучше добавить исходник и команду в
Makefile -->

Сам факт наличия такого комментария к строке означает, что на данной строке
будет приостановлено выполнение теста эталоном и тестируемой виртуальной
машиной, и будут получены состояния переменных для дальнейшего сравнения.
Другими словами, комментарии указывают отладчику места, на которые необходимо
поставить точки останова, а также указывает имена переменных, значения которых
необходимо проверить.
Получение отладчиком состояний переменных обеспечивается путем добавления
отладочной информации стандартного формата DWARF при компиляции тестового
сценария.

Стоит отметить, что для проверки корректности функционирования фронтенда TCG,
сравнение значений переменных и позиции выполнения является практически
достаточным для большинства случаев.
Архитектурные особенности основной и целевой системы отличаются, но логика
работы с переменными у них одинаковая.
Немаловажным является то, что предложенный подход к тестированию
автоматизируется.

Также стоит отметить, что создание тестов, которые обеспечивают наибольшее
покрытие по инструкциям, реализованных в тестируемом фронтенде TCG, является
отдельной сложной задачей и выходит за рамки данной работы.
<!--
Ты писал, что архитектурно зависимые инструкции не тестируются.
Следовательно, это замечание про то, что не всегда можно проверить арифметику,
логику, ветвления и т.д.?
Тогда нужно пояснить, в чём же проблема: какие-то тесты же всё-таки написаны
в ходе данной работы.
Что ты вообще понимаешь под покрытием в этом тексте?
Нужно явно обозначить, что арх. зав. инструкции не учитываются воовсе.
И привести примеры таких иснтрукций.
Желатально такие, которые в принципе не могут быть написаны на языке Си без
ассемблерных вставок.
-->

# $. Реализация автоматизированного тестирования

Предложенный подход к тестированию предполагает для сравнения значений
переменных использование отладчика и добавление отладочной информации на этапе
компиляции.
В Qemu реализован сервер внешней отладки гостевого кода по
протоколу удаленной отладки GDB (GDB Remote Serial Protocol), основными
возможностями которого являются:
* чтение/запись значений регистров процессора;
* чтение/запись в оперативную память;
* установка точек останова по управлению (breakpoint);
* установка точек останова по обращению к памяти (watchpoint).

Это означает, что для отладки гостевого кода может быть использован отладчик
на основе данного протокола, например, отладчик GDB.
Однако использование отладчика GDB для проведения тестирования
фронтенда Qemu, как и любого другого полноценного отладчика, усложняет процесс
подготовки к проведению тестирования.
Это обусловлено высокой трудоемкостью процесса модификации отладчика GDB, таким
образом, необходимо использовать средство отладки, предоставляющее большую
гибкость.
В качестве решения данной проблемы выступает отладочное API QDT, которое
использует модуль "pyrsp" [[$](#ref.pyrsp)] с открытым исходным кодом и описано
в работе [[$](#ref.qemu_debugger)], написанный на языке программирования
Python.
Модуль "pyrsp"  реализует API как для взаимодействия по протоколу RSP,
так и для работы с отладочной информацией в формате DWARF
[[$](#ref.qemu_debugger)].
Для поддержки работы с отладочной информацией "pyrsp" использует модуль
"pyelftools" [[$](#ref.pyelftools)].

На основе этих двух модулей реализовано программное средство
автоматизированного тестирования фронтенда Qemu.

Ниже представлена схема осуществления тестирования с использованием
разработанного программного средства.

![Рисунок <a name="system.png">$</a> --- Схема проведения тестирования
](system.png)

<!--
Не обязательно указывать на рисунке, что pyrsp модифицирован, загромождает.
Это можно сказать в тексте.
-->

Конфигурация тестирования реализуется путем добавления управляющих
комментариев в исходном коде теста, которые являются выражениями на языке
Python, выполняемыми штатными средствами в окружении, настроенном нужным
образом.
Данные комментарии пишутся человеком, проводящим тестирование, и содержат
команды специального вида, задающие проверки, которые будут выполнены во время
тестирования.
На данный момент программным средством поддерживаются следующие команды:
* br – установка точки останова для однократной проверки соответствия позиций
выполнения тестового сценария;
* brc – установка точки останова для многократной проверки соответствия позиций
выполнения тестового сценария;
* bre – завершить тестирование;
* ch – установка точки останова для однократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;
* chc – установка точки останова для многократной проверки соответствия позиций
выполнения и равенства значений переменных тестового сценария;

Пример теста и конфигурации тестирования, с использованием управляющих
комментариев, представлен следующим кодом.

<!--это нужно обозвать рисунком или, не уверен, листингом-->

+-----------------------------------------------------------------------------+
|```                                                                          |
|int main(void) {                                                             |
|    volatile uint32_t a = 0xABCDEF, b = 0x12345678, c = 0, i;                |
|                                                                             |
|    for(i = 0; i < 20; i++) {                                                |
|        if(i % 2) {                                                          |
|            // однократная проверка позиций выполнения                       |
|            c = b - a; //$br                                                 |
|        }                                                                    |
|        else {                                                               |
|            // многократная проверка позиций выполнения                      |
|            c = b + a; //$brc                                                |
|        }                                                                    |
|                                                                             |
|        // однократная проверка значений всех переменных                     |
|        c = b & a; //$ch                                                     |
|                                                                             |
|        // однократная проверка значений переменной `c`                      |
|        c = b | a; //$ch.c                                                   |
|                                                                             |
|        // многократная проверка значений переменной `c`                     |
|        c = b ^ a; //$chc.c                                                  |
|                                                                             |
|        /* Также есть возможность комбинировать команды:                     |
|          - однократная проверка позиций выполнения и                        |
|            значений переменных `a` и `b`                                    |
|          - многократная проверка значений переменной `c`                    |
|        */                                                                   |
|        c = 0; //$br, chc.c, ch.a, ch.b                                      |
|    }                                                                        |
|                                                                             |
|    // завершить тестирование                                                |
|    return 0; //$bre                                                         |
|}                                                                            |
|```                                                                          |
+-----------------------------------------------------------------------------+

# $. Оценка покрытия

Для поддержки тестирования в Qemu необходимо добавить код, предоставляющий
возможность отладчику читать и писать в регистры процессора, а также отвечающий
за поддержку установки отладочных точек останова (вставка транслятором
необходимого кода tcg транслятором, реализующего точки останова).

Под покрытием в данной работе подразумевается количество выполненных Qemu
инструкций гостевого процессора, которые были получены имеющимися на момент
написания работы 80-ю тестами на Си. Данные тесты содержат арифметические
(сложение, вычитание, умножение и деление), логические (умножение, сложение,
сложение по модулю 2 и отрицание) операции над 8, 16, 32 и 64 разрядными
знаковыми и беззнаковыми переменными, а также различные условные конструкции и
циклы.

Для ARM32 покрыты некоторые инстукции сложения, вычитания, умножения,
логического умножения/сложения, исключающего сложения,
арифметического сдвига вправо, логического сдвига влево/вправо, работы с
памятью, условных и безусловных переходов. Не покрыты инструкции

Для MIPS покрыты некоторые инстукции сложения, вычитания, умножения, деления,
логического умножения/сложения, исключающего сложения,
арифметического сдвига вправо, логического сдвига влево/вправо, работы с
памятью, условных и бузусловных переходов. Не покрыты инструкции

Для MSP430

+----------+---------+-------+-----+
|   ISA    | Покрыто | Всего |  %  |
+==========+=========+=======+=====+
|  ARM32   |   73    | 1251  |  6  |
+----------+---------+-------+-----+
|   MIPS   |   45    |  92   | 49  |
+----------+---------+-------+-----+
|  MSP430  |   25    |  79   | 32  |
+----------+---------+-------+-----+
|  MSP430X |         |       |     |
+----------+---------+-------+-----+

ARM cortex-m3 = 51, arm926 = 63
MIPS r4000 = 44, 4kc = 45
MSP430
MSP430 общее кол-во инструкций без суффиксов = 42, а с суффиксами = 79

Тестировались реализации MSP430 и MSP430X

<!---
MIPS r4000
тесты: 80 из 80
покрытие: 44 из 134

set(['and', 'bltz', 'subu', 'lbu', 'mflo', 'bltuc', 'bnez', 'move', 'mfhi', 'negu', 'srl', 'beqz', 'teq', 'sltu', 'addu', 'andi', 'li', 'addiu', 'lw', 'mult', 'lui', 'bne', 'sltiu', 'jr', 'b', 'ori', 'xor', 'divu', 'nop', 'bal', 'nor', 'sra', 'sllv', 'sw', 'slti', 'sll', 'lhu', 'sh', 'srlv', 'sb', 'div', 'beq', 'or', 'multu'])


MIPS 4kc
тесты: 80 из 80
покрытие: 45 из 107

set(['and', 'bltz', 'subu', 'lbu', 'mflo', 'bltuc', 'bnez', 'move', 'mfhi', 'negu', 'mult', 'beqz', 'teq', 'sltu', 'addu', 'andi', 'lui', 'li', 'lw', 'nor', 'mul', 'bne', 'sltiu', 'jr', 'sra', 'ori', 'xor', 'divu', 'nop', 'bal', 'addiu', 'b', 'sllv', 'slti', 'srl', 'or', 'sll', 'lhu', 'sh', 'srlv', 'sb', 'div', 'beq', 'sw', 'multu'])


ARM cortex-m3
тесты: 80 из 80
покрытие: 64 из 119

set(['bhi', 'sbcs', 'bx', 'subs', 'cmpeq', 'negs', 'lsl', 'it', 'pop', 'ldr', 'cbnz', 'lsr', 'movw', 'movs', 'adcs', 'eors', 'adds', 'uxtb', 'eor', 'blt', 'bls', 'uxth', 'add', 'adc', 'clz', 'ble', 'mul', 'sxtb', 'sdiv', 'bne', 'mvns', 'bl', 'beq', 'orr', 'mov', 'rsb', 'ldrb', 'sbc', 'mla', 'ldmia', 'ldrd', 'orrs', 'nop', 'sub', 'and', 'b', 'umull', 'bcs', 'ldrh', 'stmdb', 'movne', 'bcc', 'mls', 'lsrs', 'strh', 'ands', 'str', 'sxth', 'push', 'strb', 'udiv', 'strd', 'mvn', 'cmp'])


ARM arm926ej-s
тесты: 80 из 80
покрытие: 65 из

set(['and', 'sbcs', 'rsb', 'subcs', 'cmpeq', 'lsl', 'pop', 'ldr', 'lsr', 'rrx', 'moveq', 'orrcs', 'movs', 'subs', 'adds', 'sub', 'nop', 'movge', 'orreq', 'rsbmi', 'bls', 'blt', 'bxeq', 'add', 'adc', 'ble', 'mul', 'tst', 'movcc', 'bne', 'asr', 'lsrcs', 'lsrsne', 'bl', 'mla', 'orr', 'mov', 'lsleq', 'rsc', 'ldrb', 'sbc', 'b', 'lslcc', 'ldrd', 'ldrh', 'bx', 'asreq', 'rsbs', 'lsrne', 'cmpcc', 'umull', 'smulbb', 'stm', 'movne', 'bcc', 'eor', 'lsrs', 'strh', 'str', 'strd', 'push', 'strb', 'beq', 'mvn', 'cmp'])

MSP430x
тесты: 24 из 80 (-t .+((add)|(br)|(and)|(sub)|(or)|(xor)).+((8)|(16)).+\.c)
покрытие: 9 из 27 (реализовано 27 инструкций)
реализовано 62 инструкций (с суффиксами)
или 43 без суффиксов

set(['AND', 'XOR', 'SUB', 'MOV', 'ADD', 'SXT', 'JNE', 'BIS', 'CMP'])
-->

Инструкции, возвращающие управление, не покрываются данными тестами по причине
завершения тестирования до выполнения данных инструкций.

# $. Заключение

В данной работе предложен подход к автоматизированному тестированию фронтенда
транслятора TCG эмулятора Qemu, а также реализовано программное средство на его
основе, которое находится в открытом доступе.
Проведена оценка покрытия имеющихся на момент написания работы тестов и
автоматизации деятельности человека, проводящего тестирование.
<!--я верю, что будет глава с таблицами-->

# Список литературы

[$]. <a name="ref.QDTCommon"></a>Ефимов В.Ю., Беззубиков А.А., Богомолов Д.А.,
Горемыкин О.В., Падарян В.А. Автоматизация разработки моделей устройств и
вычислительных машин для QEMU. Труды ИСП РАН, том 29, вып. 6, 2017 г.,
стр. 77-104. DOI: 10.15514/ISPRAS-2017-29(6)-4

[$]. <a name="ref.TCGgen"></a>Bezzubikov A., Belov N., Batuzov K. Automatic
dynamic binary translator generation from instruction set description // 2017
Ivannikov ISPRAS Open Conference (ISPRAS). — Vol. 1. — United States: United
States, 2017.
