---
title: |
  Автоматизированное тестирование фронтенда транслятора TCG для Qemu
author:
- Колтунов Д.С. &lt;koltunov@ispras.ru>
- Ефимов В.Ю. &lt;real@ispras.ru>
tags: []
abstract: |
  <br>

  **Аннотация.**

  <br>

  *Работа поддержана грантом*.

  <br>

  **Ключевые слова**:
  Qemu;
  автоматизированное тестирование фронтенда TCG;
  QDT;
  GDB RSP
...

# $. Введение

# $. Предлагаемый подход к тестированию
# $. Подход к тестированию

<!-- верхнее лучше -->

В основе предлагаемого в данной работе подхода к тестированию фронтендов TCG
различных процессорных архитектур также лежит сравнение с эталоном.
<!-- "также" предполагет наличие ранее соответствующего текста -->
Однако предлагается использовать фиксированный эталон -- персональный
компьютер.
<!-- ошарашивающее заявление, не мешало бы подготовить читателя, рассказав,
про гипотезу о переносимости Си программ -->
Это обусловлено тем, что не всегда есть доступ к необходимому реальному
процессору.
Возможность сравнения с фиксированным эталоном предлагается достичь за счет
использования высокоуровневого языка программирования для написания тестовых
сценариев.
<!-- вот это лучше писать сначала, подводя к тому, что мы будем исползовать
ПК -->
Это необходимо для ухода от процессорной зависимости тестов, которые, в
существующих решениях, пишутся на языке ассемблера или генерируются в виде
машинного кода, что является архитектурно-зависимым.
Наиболее подходящим для решения данной проблемы является использование для
написания тестовых сценариев высокоуровневого языка программирования Си.
Это обусловлено тем, что данный язык является кроссплатформенным и используется
в разработке системного программного обеспечения, в некоторой мере вытеснив
язык ассемблера.
Немаловажным также является наличие для языка Си множества компиляторов с
<!--
открытым исходным кодом, что предоставляет важные, с точки зрения тестирования
фронтендов TCG новых процессорных архитектур, возможности.
-->
открытым исходным кодом, что предоставляет важные возможности, для тестирования
новых фронтендов TCG.

Идея предлагаемого подхода заключается в том, что программа, написанная на
языке Си, должна одинаково выполняться эталоном и виртуальной машиной,
независимо от процессорной архитектуры последней.
<!-- С ЭТОГО НАДО НАЧАТЬ -->

<!--
Для тестирования фронтенда TCG необходимой процессорной архитектуры создается
-->
Для тестируемого фронтенда TCG создается
ряд тестов, написанных, как было указано ранее, на языке программирования Си.
Они направлены на проверку реализации арифметики, логики, битовых операций,
ветвлений и других, не связанных с периферией, инструкций процессора.
Достигается это за счет одинаковой логики работы с переменными (переменная
используется, как понятие языка программирования Си) тестовых сценариев,
несмотря на отличие архитектурных особенностей эталона и тестируемой
виртуальной машины.
Таким образом, в ходе проведения тестирования на каждом его шаге сравниваются
не счетчик команд, состояние регистров и т.д., как это происходит в
EmuFuzzer [[$](#ref.EmuFuzzer)] и KEmuFuzzer [[$](#ref.KEmuFuzzer)], а
<!-- ссылка указывается у первого упоминания, когда оно появится во
введении -->
состояние переменных и позиция выполнения тестового сценария.
<!--
Для сравнения значений переменных используется отладчик.
-->
Для сравнения
<!-- всего и вся -->
используется отладчик.

Ниже представлена схема осуществления тестирования.

![Рисунок <a name="approach.png">$</a> --- Схема осуществления тестирования
](approach.png)

<!-- А рисунок сразу идёт в PNG? иначе лучше добавить исходник и команду в
Makefile -->

Так как сравнение состояний всех переменных после выполнения каждой строки
теста в ходе проведения тестирования является избыточным, то необходим
механизм указания определенных строк и имен переменных для сравнения.
Другими словами, механизм конфигурации тестирования.
<!-- конфигурации -> тонкой настройки / управления -->
Данный механизм реализован путем добавления специальных комментариев напротив
необходимых строк исходного кода теста [$](#approach.png).
<!-- ссылка на рисунок должна идти раньше рисунка по госту -->
Сам факт наличия такого комментария к строке означает, что на данной строке
будет приостановлено выполнение теста эталоном и тестируемой виртуальной
машиной, и будут получены состояния переменных для дальнейшего сравнения.
Другими словами, комментарии указывают отладчику места, на которые необходимо
поставить точки останова, а также указывает имена переменных, значения которых
необходимо проверить.
Получение отладчиком состояний переменных обеспечивается путем добавления
отладочной информации при компиляции тестового сценария.
<!-- в стандартном формате DWARF -->

Стоит отметить, что для проверки корректности функционирования фронтенда TCG,
сравнение значений переменных и позиции выполнения является достаточным.
<!-- это стоит доказать на нобилевку.
На самом деле нужно уточнить, что *практически* достаточным
*для большинства случаев*.
Так правдоподобнее будет.
-->
Архитектурные особенности основной и целевой системы отличаются, но логика
работы с переменными у них одинаковая.
Немаловажным является то, что предложенный подход к тестированию
автоматизируется.
Автоматизированное тестирование обладает большей скоростью выполнения тестов,
отсутствием влияния человеческого фактора в процессе выполнения тестирования,
способностью собирать, сохранять, анализировать и представлять в удобной для
восприятия человеком форме результаты тестирования, что значительно упрощает и
делает безошибочным процесс проведения тестирования.
<!-- мощно задвинул, внушает -->
<!--
большей скоростью - по сравнению с?
отсутствием влияния человеческого фактора - а тесты на Си тоже комп. пишет?
анализировать - чем-то ещё?
удобной для восприятия человеком форме - текстом?
тестирование не бывает "безошибочным", нужно приводить статистику по
ложноположительным и другим видам срабатываний.
Там целая теория, короче... лучше не заострять внимания.
-->

Также стоит отметить, что создание тестов, которые обеспечивают наибольшее
покрытие по инструкциям, реализованных в тестируемом фронтенде TCG, является
отдельной сложной задачей и выходит за рамки данной работы.
<!--
Ты писал, что архитектурно зависимые инструкции не тестируются.
Следовательно, это замечание про то, что не всегда можно проверить арифметику,
логику, ветвления и т.д.?
Тогда нужно пояснить, в чём же проблема: какие-то тесты же всё-таки написаны
в ходе данной работы.
Что ты вообще понимаешь под покрытием в этом тексте?
Нужно явно обозначить, что арх. зав. инструкции не учитываются воовсе.
И привести примеры таких иснтрукций.
Желатально такие, которые в принципе не могут быть написаны на языке Си без
ассемблерных вставок.
-->

# $. Реализация автоматизированного тестирования

Предложенный подход к тестированию предполагает для сравнения значений
переменных использование отладчика и добавление отладочной информации на этапе
компиляции.
В Qemu реализован сервер внешней отладки гостевого кода по
протоколу удаленной отладки GDB (GDB Remote Serial Protocol), основными
возможностями которого являются:
* чтение/запись значений регистров процессора;
* чтение/запись в оперативную память;
* установка точек останова по управлению (breakpoint);
* установка точек останова по обращению к памяти (watchpoint).

Это означает, что для отладки гостевого кода может быть использован отладчик
на основе данного протокола, например, отладчик GDB.
Однако использование отладчика GDB для проведения тестирования
фронтенда Qemu, как и любого другого полноценного отладчика, усложнит
архитектуру программного средства автоматизированного тестирования.
Это обусловлено трудностью автоматизации данного процесса, наличием у данного
отладчика большего функционала, чем необходимо, а также трудностью расширения
списка поддерживаемых процессорных архитектур.
<!--Не очень убедительное обоснование. Нужно топить за то, что модифицировать
GDB тяжело и долго, а написать упрощённый аналог на Python быстрее и
легче. Тем более, что (в твоём случае) уже есть реализация (QDT + pyrsp +
pyelftools) -->
<!--Адаптация такого решения под свои нужды предоставляет большую гибкость,
нежели внесение изменений в отладчик GDB. -->
В качестве решения данной проблемы выступает модуль "pyrsp" [[$](#ref.pyrsp)]
с открытым исходным кодом, написанный на языке программирования Python.
Модуль "pyrsp"  реализует API как для взаимодействия по протоколу RSP,
так и для работы с отладочной информацией в формате DWARF
[[$](#ref.qemu_debugger)].
Для поддержки работы с отладочной информацией "pyrsp" использует модуль
"pyelftools" [[$](#ref.pyelftools)].

На основе этих двух модулей реализовано программное средство
автоматизированного тестирования фронтенда Qemu.

<!--
Это обеспечивается за счет открытости исходного кода, удобства разработки
на языке Python, возможностью реализации только необходимого функционала и
простотой добавления поддержки новых процессорных архитектур.
Данное решение упрощает архитектуру системы, автоматизирующей тестирование
(рисунок 3.5).
По причине того, что модуль PyRSP написан на языке программирования Python,
и из-за удобства разработки на данном языке, система тестирования также
реализована на языке Python и предназначена для работы под управлением
UnixUNIX-подобных операционных систем.
-->
<!--
Python к выбору UNIX отношения не имеет.
Проблема в том, что под виндой мы не можем пока достать
отладочную инфу из PE файла. А то, что указал прекрасно и под виндой
будет работать (и под маком, наверно, тоже)
-->

Ниже представлена схема осуществления тестирования с использованием
разработанного программного средства.

![Рисунок <a name="system.png">$</a> --- Схема проведения тестирования
](system.png)

<!--
Не обязательно указывать на рисунке, что pyrsp модифицирован, загромождает.
Это можно сказать в тексте.
-->

Конфигурация тестирования реализуется средствами языка Python по интерпретации
строки, а именно специальных комментариев в исходном тексте.
<!--эта фраза будет непонятна, лачше сказать, что управляющие комментарии
являются выражениями на языке Python, выполняемыми шатными средствами в
окружении, настроеном нужным образом -->
Данные комментарии пишутся человеком, проводящим тестирование, и содержат
команды специального вида, задающие проверки, которые будут выполнены во время
тестирования.
На данный момент программным средством поддерживаются следующие команды:
* br – установка точки останова для однократной проверки соответствия позиций
выполнения тестового сценария;
* brc – установка точки останова для многократной проверки соответствия позиций
выполнения тестового сценария;
* bre – завершить тестирование;
* ch – установка точки останова для однократной проверки соответствия позиций
выполнения и эквивалентности значений переменных тестового сценария;
* chc – установка точки останова для многократной проверки соответствия позиций
выполнения и эквивалентности значений переменных тестового сценария;
<!--Тут всплывает понятие "эквивалентности" это не тог же самое, что и
"равенство". Нужно вводить чёткое определение. -->

Пример теста, содержащего специальные комментарии, конфигурирующие
тестирование, представлен ниже.

<!--это нужно обозвать рисунком или, не уверен, листингом-->

+-----------------------------------------------------------------------------+
|```                                                                          |
|int main(void) {                                                             |
|    volatile uint32_t a = 0xABCDEF, b = 0x12345678, c = 0, i;                |
|                                                                             |
|    for(i = 0; i < 20; i++) {                                                |
|        if(i % 2) {                                                          |
|            // однократная проверка позиций выполнения                       |
|            c = b - a; //$br                                                 |
|        }                                                                    |
|        else {                                                               |
|            // многократная проверка позиций выполнения                      |
|            c = b + a; //$brc                                                |
|        }                                                                    |
|                                                                             |
|        // однократная проверка значений всех переменных                     |
|        c = b & a; //$ch                                                     |
|                                                                             |
|        // однократная проверка значений переменной `c`                      |
|        c = b | a; //$ch.c                                                   |
|                                                                             |
|        // многократная проверка значений переменной `c`                     |
|        c = b ^ a; //$chc.c                                                  |
|                                                                             |
|        /* Также есть возможность комбинировать команды:                     |
|          - однократная проверка позиций выполнения и                        |
|            значений переменных `a` и `b`                                    |
|          - многократная проверка значений переменной `c`                    |
|        */                                                                   |
|        c = 0; //$br, chc.c, ch.a, ch.b                                      |
|    }                                                                        |
|                                                                             |
|    // завершить тестирование                                                |
|    return 0; //$bre                                                         |
|}                                                                            |
|```                                                                          |
+-----------------------------------------------------------------------------+

Программное средство автоматизированного тестирования фронтенда TCG реализовано
на языке программирования Python, поддерживает тестирование Qemu в режиме
полносистемной эмуляции и в режиме эмуляции уровня пользователя, и под
названием c2t (CPU Testing Tool) входит в состав инструмента автоматизации
разработки моделей устройств и вычислительных машин для Qemu [[$](#ref.QDT)],
исходный код которого доступен по адресу https://github.com/ispras/qdt.
<!--Это для введения/аннотации-->

# $. Заключение

В данной работе предложен подход к автоматизированному тестированию фронтенда
транслятора Qemu TCG, а также реализовано программное средство на его основе,
<!--много существительных, кажется, что "Qemu" - транслятор, а "TCG" просто
так написали-->
которое находится в открытом доступе.
Проведена оценка покрытия имеющихся на момент написания работы тестов и
автоматизации деятельности человека, проводящего тестирование.
<!--я верю, что будет глава с таблицами-->

# Список литературы

[$]. <a name="ref.QDTCommon"></a>Ефимов В.Ю., Беззубиков А.А., Богомолов Д.А.,
Горемыкин О.В., Падарян В.А. Автоматизация разработки моделей устройств и
вычислительных машин для QEMU. Труды ИСП РАН, том 29, вып. 6, 2017 г.,
стр. 77-104. DOI: 10.15514/ISPRAS-2017-29(6)-4
