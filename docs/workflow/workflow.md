# Процесс разработки модели вычислительной машины для эмулятора Qemu

Модель вычислительной машины (далее, виртуальная машина (ВМ)) в эмуляторе
Qemu состоит из большого числа программных компонентов.
Следовательно, процесс разработки ВМ является совокупностью меньших процессов
разработки.

Самыми трудозатратными компонентами являются:

- система команд процессора,
- периферийные устройства.

Каждый компонент является программой, взаимодействующей с эмулятором через
внутренний API.
Процесс разработки любого компонента начинается с реализации стартовой
работоспособной программы.
Затем начинается цикл итеративной разработки, состоящий из тестирования,
отладки и доработки.
Этот цикл, в теории, не прекращается никогда.
Но на практике он приостанавливается, когда
все существенные ошибки исправлены, а модель обеспечивает достаточную
точность эмуляции, согласно требованиям заказчика.

В теории, все составные процессы <!--разработки компонентов--> могут
выполняться параллельно и независимо.
Но, например, протестировать реализацию системы команд или устройство
значительно легче, если все компоненты собраны воедино.
Т.е. часть этапов в разных процессах происходит параллельно, а часть
выгодней выполнять совместно и последовательно.

На притяжении всего процесса разработки важна _автоматизация_, т.к. она
повышает производительность труда разработчика, а, значит, и качество, и
максимальный размер ВМ.
Поэтому целью работ, проводимых в ИСП РАН, являлось выделение в процессе
разработки этапов, поддающихся автоматизации, и непосредственно сама
автоматизация.
Для разработки всех обозначенных выше компонент были созданы
специализированные инструменты.
Большинство из них входит в единый
Пакет инструментов разработчика Qemu[[$](#ref.QDT)]
(англ. Qemu Development Toolkit, QDT).

Ниже рассматриваются процессы создания компонентов ВМ с точки зрения
трудностей, возникающих в течение классической ручной разработки.
Приводятся способы их автоматизации.
В конце описан предлагаемый процесс разработки ВМ с использованием
инструментов автоматизации.

## Система команд

Система команд процессора представлена передним планом (англ. frontend)
динамического двоичного транслятора TCG[[$](#ref.TCG)].
Передний план принимает на вход данные, являющиеся машинными командами,
и возвращает программу на промежуточном представлении TCG.
Эта программа изменяет состояние виртуальной машины так, как изменилось
бы состояние настоящей вычислительной машины, если бы не ней был выполнен
соответствующий машинный код.
Поскольку приоритет для Qemu — скорость, то допустимая часть подробностей
опускается.
Иными словами, передний план TCG содержит _семантику_ команд процессора.

Семантика машинной команды — программа на промежуточном представлении TCG,
выполняющаяся вместо команды и совершающая над моделью вычислительной машины
действия, эквивалентные действиям, выполняемым командой при выполнении на
настоящей машине.

Разработчик переднего плана должен:
 * реализовать анализатор машинного кода,
 * выделить важные подробности работы команд,
 * разработать на языке TCG семантику каждой команды,
 * реализовать на языке Си программу, которая вернёт разработанную семантику,
 * протестировать работу всего переднего плана.

Наконец, для того чтобы поддержку системы команд можно было использовать,
нужно создать модель процессора.

### Анализатор машинного кода

Анализатор машинного кода совмещает в себе лексический и синтаксический
анализ, где токенами являются последовательности бит (коды операций,
операнды, и т.д.), из которых собираются машинные команды.
Для человека придумать оптимальный способ разбора — задача долгая, скучная и
чревата не очевидными опечатками, поиск которых может потребовать много
времени.

Однако, по совокупности описаний кодировок машинных команд можно
автоматически сгенерировать анализатор [[$](#ref.Zuban)].
Задать кодировки машинных команд значительно проще, чем придумать
анализатор.
На практике эта задача сводится к переписыванию таблиц из документации.

Сгенерированный анализатор состоит из вложенных блоков `switch-case`, где
выбор каждого следующего блока `case` происходит путём выделения
подпоследовательности бит в машинном слове.
В конце выполняется вызов функции, соответствующей распознанной машинной
команде.
В течение вызова этой функции должна быть создана программа на промежуточном
представлении TCG, выполняющая действия, подразумеваемые соответствующей
командой, — семантика команды.
Но после работа автоматического генератора требуемые функции создаются с
пустыми телами, куда разработчику следует вписать код, выражающий
семантику команд.

Вместе с анализатором по специальному описанию генерируется модель
процессора.
Описание процессора включает перечень регистров, длину адреса,
порядок байт в машинном слове и др.
Эти параметры также учитываются при генерации анализатора.

### Формальное описание семантики машинных команд

Описание семантики команд предоставляется производителем процессора
на естественном языке.
При этом не существует единого формата описания, которого бы придерживались
многие производители.
Также в описаниях часто бывают неточности и ошибки, обработка которых
требует умственных усилий человека.
Т.е. формализация описания семантики не поддаётся автоматизации в настоящее
время.
Но можно облегчить работу разработчика следующим способом.

Составление программы на промежуточном представлении TCG выполняется
путём вызова специальных функций из API Qemu.
Другими словами, разработчик пишет не непосредственно на
промежуточном представлении, а на
языке Си, составляя программу, которая вернёт требуемую программу.

Промежуточное представление является низкоуровневым, напоминающим язык
ассемблера, поэтому даже простая программа (напр., реализация команды
сложения с выставлением флагов в регистре состояния процессора)
получается длинной и трудно читаемой.

Для упрощения написания семантики был разработан инструмент
I3S [[$](#ref.I3S)] — Instruction Set Semantics Specification
(англ. Описание семантики системы команд).
I3S принимает описание семантики машинных команд на одноимённом языке,
основывающемся на языке Си, и возвращает программу на языке Си, возвращающую
программу на промежуточном представлении TCG.

Т.е. результат работы — готовый к работе набор функций, вызываемых из
анализатора машинного кода.

### Тестирование

Чтобы подтвердить корректность реализации переднего плана разработчик
должен его протестировать.

На практике заказчик обычно предоставляет набор двоичных файлов, содержащих
примеры кода.
Однако с помощью этих файлов нельзя покрыть всю реализацию переднего плана.
Кроме этого часто заказчик не может предоставлять примеры по соображениям
конфиденциальности.

Более надёжным способом тестирования является сравнение с
эталоном — настоящим процессором.
Однако доступ к такому эталоны не всегда возможен.
Как по экономическим причинам, так и по соображениям конфиденциальности.

В таких случаях вместо эталона может быть использован произвольный
процессор[[$](#ref.TCGTesting)] (в том числе и процессор АРМ разработчика).
В основе такой замены лежит тот факт, что достаточно большое множество
программ на языке Си должно одинаково выполняться независимо от
архитектуры процессора.
Поиск несоответствий происходит на уровне терминов языка Си (значение в
переменной, номер строки в пути выполнения).
При обнаружении несоответствия разработчик самостоятельно разбирается,
чем вызвана проблема: ошибкой в машинной команде или отличиями в системах
команд.
Поскольку тесты изначально разрабатываются с учётом возможных различий,
несоответствия второго вида на практике не встречаются.
Хотя у данного подхода есть множество ограничений, он позволяет
покрыть значительную (более 60%) часть реализации.
Кроме того, тесты обладают высокой универсальностью, и, как следствие,
могут быть повторно использованы при разработке следующей ВМ без изменении.

## Периферийные устройства

Периферийные устройства задаются в событийно ориентированном стиле.
Модель устройства — набор функций на языке Си (обработчиков событий) и
набор структур данных, описывающих состояние времени выполнения.

Наиболее часто случающимися событиями являются:

* создание (инициализация) независимо от окружения,
* _осознание_ (англ. realization) себя в составе ВМ,
* сброс в начальное состояние,
* чтение и запись в регистр.

Также устройства могут издавать и принимать запросы прерываний.

Многие устройства поддерживают настройку через интерфейс командной строки.
Например, можно указать файл образ для ПЗУ, реальный сетевой интерфейс для
виртуального сетевого адаптера и мн. др.

Разработчик модели устройства должен:

* описать состояние устройства в терминах языка Си,
* реализовать настройку устройства пользователем,
* выбрать необходимые события,
* реализовать на языке Си реакцию модели устройства на каждое событие,
* протестировать работу устройства.

### Описание работы устройства

С описаниями устройств от производителей дела обстоят также как и с
описаниями систем команд — они предоставляются на естественном языке
и не поддаются автоматической формализации.
В особо трудных случаях нет даже описания, а только доступ к драйверу
устройства на машинном языке в составе образа исследуемого ПО.
В таких случаях в цикле итеративной разработки появляется
задача обратной разработки драйвера [[$](#ref.iEMU)].
На каждой итерации удаётся продвинуться дальше по ходу выполнения
исследуемого ПО до следующего сбоя или отказа.
Обнаружение настоящего места проблемы — отдельная нетривиальная, в чём-то
творческая, задача.
Затем происходит определение причины и корректировка соответствующей
модели устройства.

Реализация устройства сводится к написанию функций и структур данных на
языке Си.
API Qemu накладывает множество формальных требований к тому,
как должен быть написан этот код.
Эти требования естественным образом следуют из языка Си.
Например, в API определены структуры данных, куда должны быть
занесены указатели на функции-обработчики событий.
И эти функции должны обладать конкретной сигнатурой.
Фактически, часть кода модели изначально определена API Qemu.
Эту часть будем называть _интерфейсной_.
Остальную же часть кода, реализующую индивидуальные особенности работы
конкретной модели устройства, будем называть _индивидуальной_.

### Автоматизированная генерация заготовок

Создание интерфейсной части кода хорошо поддаётся автоматизации.
Достаточно составить список событий и сформулировать высокоуровневые
данные об устройства (такие как имя модели), чтобы стало возможно
сгенерировать заготовку устройства.

Заготовка устройства состоит из различных конструкций языка Си.
Многие из которых взаимосвязаны.
Например, обработчик записи в банк регистров регистрируется в
структуре данных, описывающих этот регистр.
Эта структура данных, в свою очередь, регистрируется функцией
инициализации устройства в служебной структуре, сообщая эмулятору,
что у данного устройства есть такой-то банк регистров.
Эту цепочку можно продолжать и дальше.

В общем случае, зависимости между конструкциями образуют ациклический граф.
Чтобы код устройства был синтаксически корректным, нужно правильно
расставить идентификаторы, расположить конструкции языка в синтаксически
корректном порядке, подключить нужные заголовки (причём минимизировать
их количество включения одних другими) и др.
При этом следует соблюсти требования к стилю написания кода,
принятыми в сообществе разработчиков Qemu, и мн. др. особенности.

При классической разработке это всё приходилось учитывать разработчику
вручную.
Поскольку крайне трудно удерживать в памяти все требования API Qemu,
разработка сводилась к поиску похожих по функционалу кусков кода в
готовых моделях устройств.
В QDT реализован инструмент, позволяющий по описанию устройства сгенерировать
заготовку для устройства и зарегистрировать её в инфраструктуре эмулятора.
Описание формализуется с помощью API QDT на языке Python и в десятки раз
меньше, чем получаемая из него заготовка.
Кроме того, в формальном описании сложнее допустить ошибку.

### Описание регистров устройства

Наибольшая часть индивидуальной части устройства заключается в обработчиках
чтения и записи в банк регистров.
Принцип разбиения банков регистров на отрезки, выровненные по границе байта,
т.е. регистры с индивидуальным назначением, был использован при
автоматизированной генерации заготовок.
Помимо кода в обработчике доступа, регистр присутствует в состоянии
времени выполнения устройства, а также упоминается других частях кода
модели.
Это создаёт определённые трудности разработчику.

Регистры могут быть описаны в одном месте в описании для
генератора заготовок с использованием специально разработанного расширения
для API QDT [[$](#rel.IvannikovArmenia)].

В течение разработки разнообразных устройств удалось выделить некоторые
часто используемые виды регистров устройств:

- регистры только для чтения;
- регистры для чтения и записи;
- регистры-пустышки;
- регистры только для записи.

Указание вида регистра позволяет сгенерировать для него дополнительный код
в заготовке.
Аналогичным образом может быть описан каждый бит в регистре.

Использование формального описания регистров сокращает объём кода, написанного
вручную в два раза.
Однако основное преимущество в удобстве, т.к.
на практике описание регистров сводится к переписывании таблицы из
документации, без необходимости редактировать код по разным местам
модели устройства.

## Виртуальная машина

Виртуальная машина — совокупность процессора и устройства.
Здесь процессор включает в себя передний план TCG.
ВМ в значительной степени представлена своей функцией инициализации,
которая создаёт все компоненты и связывает их между собой.

Если ВМ большая, то функция инициализации может содержать сотни строк, а
при расстановке связей вручную между устройствами легко допустить ошибку.
Чтобы упростить создание ВМ в QDT был разработан графический интерфейс
пользователя (ГИП), отображающий ВМ в виде схемы из связанных блоков.
ГИП реализован с использованием модели ВМ на языке Python.
Вместе с ним разработан генератор, позволяющий создавать заготовку кода
машины с необходимой функцией инициализации.
Полученная заготовка в большинстве случаев требует минимальной доработки, в
отличие от заготовок для устройств, с генерации которых разработка только
начинается.

## Предлагаемый процесс разработки ВМ

TODO

# Источники

$. <a name="ref.QDT"></a>Статья про QDT.

$. <a name="ref.TCG"></a>Какая-нибудь статья про TCG.

$. <a name="ref.Zuban"></a>Статья Беззубикова.

$. <a name="ref.I3S"></a>https://github.com/ispras/I3S
   Статьи Олега по этому поводу, помнится, нет.

$. <a name="ref.TCGTesting"></a>Статья Димы.

$. <a name="ref.iEMU"></a>Статья про iEMU.

$. <a name="rel.IvannikovArmenia"></a>Статья для конфы в Армении.

