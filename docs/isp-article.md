[//]: # (make)

<!--
Перед подачей в pandoc статься должна быть предобработана сценарием
md-preprocessor.py. Он осуществляет автоматизацию ссылок. Ниже приводятся
некоторые пояснения по поводу оформления ссылок. Подробные сведения и нюансы:
см. код сценария. Примеры оформления см. в тексте.

Типы ссылок:
ref.MyRefName     - ссылки на источники
rel.MyText        - ссылки на такст, которые будут заменены на "выше" или "ниже"
pic.MyPictureName - ссылка на картинку
tbl.MyTable       - ссылка на таблицу
без приставки     - ссылка никак не обрабатывается

Для каждой ссылки должен быть объявлен "якорь" - позиция, на которую эта ссылка
ссылается. Якори расставляются так.

$. <a name="preffix.MyName">$</a>

где $ - ставится только в том случае, если предполагается автоматическая
замена этого символа на что-то другое (в соответствии с типом ссылки). Якорь
должен быть ПЕРЕД соответствующим текстом.
-->

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

В.Ю. Ефимов &lt;real@ispras.ru>

О.В. Горемыкин &lt;goremykin@ispras.ru>

Институт системного программирования им. В.П. Иванникова РАН,

109004, Россия, г. Москва, ул. А. Солженицына, д. 25.


# Обозначения и сокращения

* API Application programming interface
* ABI Application binary interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* EEPROM Electrically erasable programmable ROM
* GNU GNU's Not Unix!
* GPIO general purpose input/output
* GPL General Public License
* ICH I/O Controller Hub
* ICMP Internet control message protocol
* IRQ Interrupt request
* JSON JavaScript Object Notation
* LPC Low pin count
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* MSI-X Extended MSI
* PCap Packet Capture
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* TCG Tiny code generator
* TCP Transmission control protocol
* UDP User datagram protocol
* USB Universal serial bus
* АСД абстрактное синтаксическое дерево
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* ПО программное обеспечение
* УАПП универсальный асинхронный приёмо-передатчик

# Аннотация
TODO

**Ключевые слова**:
программный эмулятор, бинарный код, разработка виртуальных машин.

**DOI:**
TODO

**Для цитирования:**
TODO

# <a name="Introduction"></a>Введение

Виртуальные вычислительные машины (ВВМ) применяются для решения разнообразных
задач: включая исследования в рамках информационной безопасности.
Одной из задач является организация контролируемого окружения для
исследуемого машинного кода во время динамического анализа.
Устоявшийся подход совмещает дизассемблер IDA Pro и интерактивную отладку,
когда сервером удаленной отладки выступает эмулятор.
Эмулятор дает дополнительный «рубеж» изоляции между исследуемым кодом и
инструментами анализа [[$](#ref.Dovgaluk)] и хорошо подходит для
исследования компьютерных вирусов и другого вредоносного ПО.
Одним из программных средств для организации ВВМ является эмулятор QEMU
[[$](#ref.QEMU)].

QEMU --- наиболее подходящий эмулятор для данной цели ввиду ряда свойств:

* открытый исходный код (лицензия GPL);
* поддержка разнообразных процессорных архитектур для ВВМ (Intel x86, AMD 64,
ARM, MIPS, PowerPC, SPARC и др.);
* реализация важных, с точки зрения динамического анализа, технологий и
возможностей:

    * динамическая двоичная трансляция (принципиально снижает относительное
    замедление[[$](#ref.DBT)]);
    * интерфейс отладки ВВМ (по протоколу remote GDB [[$](#ref.remote_GDB)]);
    * сохранение и загрузка состояния ВВМ (_snapshot_);
    * дублирование сетевого трафика в PCap;
    * программный интерфейс контроля работы ВВМ --- QMP (QEMU Monitor Protocol),
    основанный на JSON;
    * ручной командно-ориентированный интерфейс контроля работы ВВМ --- HMP
    (Human Monitor Protocol);

* работоспособность в окружении распространённых операционных систем (ОС):

    * Microsoft Windows XP и новее,
    * GNU Linux (семейства Debian, Fedora и др.).
    * Mac OS;

* модульная архитектура, допускающая расширение перечня эмулируемых
процессорных архитектур, вычислительных машин (ВМ) и устройств.

При динамическом анализе машинного кода для узкоспециализированных и
малораспространённых ВМ необходимо реализовать в эмуляторе соответствующую ВВМ.
Существенной проблемой становится подготовка необходимого окружения, т.е. ВВМ
требуемой конфигурации, в котором будет работать исследуемое ПО.
Не имея законченной ВВМ, невозможно задействовать всю мощь динамического
анализа.
Даже самые простые ВМ состоят из десятков устройств.
Ввиду огромного разнообразия устройств в богатой библиотеке устройств QEMU
редко удаётся обнаружить требуемое устройство.
Особенно, когда речь идёт об узкоспециализированных ВМ.
Т.е. необходимо реализовывать большое количество моделей устройств.
Несмотря на то, что QEMU архитектурно приспособлен к добавлению новых моделей,
процесс их разработки --- трудоёмкая задача.
В связи с этим возникает необходимость исследовать процесс разработки
моделей ВМ и устройств с целью его ускорения.
Используемый в настоящее время подход к реализации моделей для QEMU сводится к
выполнению рутинной ручной работы.
Он заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию.
При этом применяется непосредственное копирование кода, с последующими его
правками и дополнениями.
С опытом всё большую часть кода можно писать по памяти, следя за изменениями в
QEMU.
В данной работе разработан метод ускорения, основывающийся на выявлении и
автоматизации рутинных этапов данного процесса.
Метод был реализован в программном инструменте на языке
Python[[$](#ref.Python)].

Дальнейший текст организован следующим образом:

* рассматриваются работы, ориентированные на решение схожих проблем;
* рассматривается подход, используемый в QEMU для эмуляции устройств и ВМ;
приводится используемая при этом объектная модель;
* с учётом рассмотренных подхода к эмуляции и модели более подробно
рассматривается разработанный подход к автоматизации;
* отдельно рассматривается разработанный ГИ;
* приводятся примеры заготовок;
* рассматривается процесс разработки устройств и ВМ с использованием
разработанного инструмента;
* приводятся экспериментальные данные об использовании инструмента с оценкой
целесообразности.


# Обзор близких работ
ТУДУ


<!--- QEMU , ООП (парадигма), Си (язык) --->
# Объектная модель QEMU

Основой использованного в QEMU подхода к моделированию ВМ и их компонент
является "объектная модель QEMU" (англ. _QEMU Object Model_ или,
далее по тексту, _QOM_). Данная модель применяется не только для моделирования
ВМ и их
компонент, но и для реализации вспомогательных возможностей. QOM является
реализацией парадигмы ООП на языке Си.
<!--+ QOM +-->

<!--- QOM, наследование (ООП) --->
QOM организует иерархию _типов_ (type).
Каждый тип имеет уникальное строковое _имя_.
Тип описывает _класс_ (class) и _экземпляр_ (instance).
Экземпляров может быть много, в то время как класс один.
Иерархия QOM получается путём _наследования_ (по аналогии с ООП) ---
установления отношения между двумя типами, таким образом, что один тип
называется _ребёнком_, а другой --- _родителем_.
Ребёнок копирует всю информацию из родителя --- _наследует_.
Множественное наследование не поддерживается.
Тип может быть _абстрактным_: такой тип не может иметь экземпляров.
<!--+ тип, класс, экземпляр, (тип-)родитель, (тип-)ребёнок, наследование,
абстрактный тип +-->

<!--- QOM, структура (Си), функция (Си), конструктор (ООП), экземпляр (QOM),
класс --->
<a name="rel.QOM_type_structs"></a>
Экземпляр описывается структурой (конструкция языка Си) и функцией
её инициализации. Для QOM существенен только размер этой
структуры, так как он используется для выделения под неё памяти. Эту структуру
будем называть _структурой экземпляра_, а функцию ---
_конструктором экземпляра_ (по аналогии с ООП). Класс тоже описывается
структурой (её размером) и функцией с аналогичными назначениями:
_структура класса_ и _конструктор класса_.
В начале каждой структуры типа-ребёнка должно быть зарезервировано место под
соответственную структуру родительского типа.
<!--+ структура экземпляра, конструктор экземпляра, структура класса,
конструктор класса +-->

<!--- конструктор экземпляра, конструктор класса --->
Инициализация как экземпляра, так и класса происходит путём вызова
конструкторов в порядке от родителя к ребёнку: явный вызов соответственного
конструктора родителя не требуется.
<a name="overridance_in_QOM"></a>
Изменение поля любой из структур родителя (_перегрузка_) должно выполняться
в соответственном конструкторе.
Поскольку структура класса у каждого типа своя, перегрузка не повлияет
ни на родителя, ни на братьев <!-- этот термин не вводится явно: предполагается,
что читатель сам сможет догадаться --> и _их_ потомков <!-- этот, кстати,
тоже -->. Но она повлияет на потомков перегружающего типа, поскольку
конструктор будет вызван в течение каждой инициализации соответственной
структуры каждого потомка. Это справедливо и для перегрузки полей структуры
экземпляра.
<!--+ порядок инициализации экземпляра и класса, перегрузка +-->

<!--- стиль программирования QEMU, структура экземпляра, конструктор экземпляра,
структура класса, конструктор класса --->
Согласно принятому в QEMU стилю программирования, все описанные выше
структуры, функции, строковые константы (имена типов) и т.д. имеют в своём
названии имя типа. Оно принимает различные формы, в том числе, чтобы
быть синтаксически корректным. Далее по тексту, для ссылок на типы
будут использоваться строковые имена типов в оригинальном виде. Некоторые из
них удобнее использовать переведёнными на Русский язык. В таком
случае при первом упоминании типа будет указано и его оригинальное имя.
<!--+  соглашение о способе упоминания тиnа QOM +-->

<!--- QOM, экземпляр, класс, тип --->
## Объекты в QOM

Несмотря на название QOM, _объект_ (object) не является её базовым понятием, а
только одним из типов. Данный тип добавляет <a name="QOM_object_property">
_свойства_</a> к экземплярам и классам.
Свойство описывается строковым именем (уникальным в пределах объекта или
класса), функциями доступа (присваивания (set) и разыменования (get)) и типом.
Со свойством связана и другая информация, но её рассмотрение выходит за
рамки данной работы.
Тип свойства ограничивает область его допустимых значений. Несмотря на то, что
функции доступа дают большую свободу действий со значением, в большинстве
случаев значению соответствует поле структуры, соответственно, экземпляра или
класса. Так как свойства не входят в базовую часть QOM, их добавление
возлагается
на конструкторы соответствующих структур (т.е. на программиста).
<!--+ объект, свойство, функция доступа к свойству +-->


<!--- QOM, объект, ВВМ, шина, устройство, прерывание, запрос прерывания,
память --->
## Виртуальные вычислительные машины и их компоненты в QOM
Моделирование ВВМ и её элементов основано на потомках типа _объект_ (object).
К ним относятся:

* машина (machine),
* устройство (device),
* шина (bus),
* запрос прерывания (irq),
* участок памяти (qemu:memory-region).

Модели ВВМ, шин и устройств должны быть, соответственно, потомками machine, bus
и device.
Типы irq и участка памяти являются инфраструктурными, они используются в
общем API и их уточнение обычно не требуется.
Дальнейшее наследование шин и устройств происходит по принадлежности к
стандарту шины.
При этом вводятся промежуточные типы, реализующие общий функционал.
Конкретная модель устройства наследуется от типа соответствующего стандарту
её шины.
При реализации модельного ряда устройств добавляется промежуточный тип с общими
для всего ряда особенностями.
<!--+ основные типы ВВМ, соглашение о наследовании от основных типов ВВМ +-->


<!--- основные типы ВВМ, отрезок (лин.ал.), целые числа, неотрицательные
числа, наложение отрезков? (лин.ал.), функция (язык Си), ОЗУ, ПЗУ, регистр
устройства, шина --->
### Моделирование памяти

Моделирование памяти основано на покрытии её _участками_ (англ. _region_).
Участок памяти описывает непрерывный отрезок _адресного пространства_
(англ. _address space_).
В QEMU адресное пространство --- это отображение целых неотрицательных чисел на
участки памяти.
Участки памяти бывают следующих видов: контейнер, псевдоним, RAM, ROM, ROMD и
IO.

Контейнер содержит в себе участки любых видов.
Вложенный участок сопровождается _смещением_ относительно начала контейнера и
_приоритетом_ относительно других участков, вложенных в этот контейнер.
При наложении выбирается участок с наибольшим приоритетом.
<!-- Приоритет является целым числом. -->

Псевдоним отображает свой отрезок адресов на участок любого вида со _смещением_
относительно начала того участка.

Участок RAM соответствует ячейкам памяти доступным как на чтение, так и на
запись.
ROM --- только на чтение.
ROMD --- это ROM, запись в который обрабатывается функцией.
IO и чтение, и запись обрабатывает функциями.
<!--
Последний тип ранее назывался "MMIO" по историческим причинам: первоначально
он использовался для эмуляции MMIO.
-->

На практике RAM соответствует ОЗУ; ROM и ROMD --- соответственно, не
перепрограммируемым и перепрограммируемым ПЗУ; IO --- регистрам устройств,
контейнер --- адресному пространству; псевдоним используется для
доступа к одному и тому же участку памяти с разных адресов или для отображения
адресного пространства одной шины в адресное пространство другой.
В общем случае возможны и другие применения.
<!--+ участок памяти, адресное пространство, контейнер, псевдоним,
участок RAM, участок ROM, участок ROMD, участок IO, приоритет в контейнере,
смещение в контейнере, смещение псевдонима +-->


<!--- основные типы ВВМ, QEMU --->
### Моделирование шин

Шина в QEMU --- это элемент ВВМ, связывающий устройства. Одно из устройств
называется _родителем_ (parent) шины, а остальные --- _детьми_ (children).
Симметрично, устройства соединяется с одной или более шиной. При этом
выделяется шина-_родитель_, а остальные шины называются _детьми_.
Устройство имеющие хотя бы одну шину-ребёнка называется _мостом_ или
_контроллером шины_.
Таким способом происходит связывание всех элементов ВВМ в единое дерево.

Особым образом моделируется системная шина.
В каждой ВВМ имеется единственная системная шина, которая является корнем
дерева устройств.
Ей не соответствует никакого экземпляра, а все её функции закреплены в API.
Все экземпляры устройств системной шины считаются подключенными к ней.
<!--+ устройство-родитель, устройство-ребёнок, шина-родитель, шина-ребёнок,
мост (устройство), контроллер шины, системная шина +-->


<!--- основные типы ВВМ, IRQ, API, обратный вызов (парадигма
программирования), структура экземпляра,  целые числа, неотрицательные числа,
устройство, указатель (Си), структура (Си), IRQ, запрос прерывания,
двоичный сигнал --->
### <a name="rel.IRQ_modeling"></a>Моделирование запросов прерывания

Запрос прерывания есть передача бинарного сигнала от устройства-_источника_ к
устройству-_приёмнику_.
Передача реализуется при помощи обратного вызова, которому передаётся текущее
значение двоичного сигнала на линии.
<!--
Обратный вызов не обязательно сопровождается изменением сигнала.
Об этом важно помнить при разработке модели устройства.
Вызов без изменения сигнала, хоть и избыточен, но не является ошибкой.
-->
Параметры обратного вызова хранятся в структуре `IRQState`.
Данная структура является структурой экземпляра типа "irq".
Для ссылки на эту структуру определён специальный тип указателя `qemu_irq`.
<!--
Одним из параметров обработчика является индекс входа на который пришел сигнал.
Поэтому один обработчик может использоваться для нескольких входных сигналов.
Структура IRQState` содержит описание одного входа:

* обработчик;
* индекс;
* указатель на `void`, через который в обработчик можно передать
произвольные данные.

Симметрично, указатель `qemu_irq` соответствует одному выходу.
-->
Источник содержит поле типа `qemu_irq` в своей структуре экземпляра.
Приёмник инициализирует `IRQState`<!--, память под которую
обычно выделяется из _кучи_ в процессе создания прерывания-->.
Для формирования одной линии в поле типа `qemu_irq` источника записывается
адрес структуры `IRQState` приёмника.
<!--+ IRQState, qemu_irq, источник IRQ, приёмник IRQ +-->


<!--- устройство (QOM), принцип чёрного ящика, свойства (QOM),
мост (устройство), регистры устройств, шина, шина-родитель, устройство-родитель,
MMIO, PMIO, PIO, адресное пространство, гостевое ПО, стандарт шины, ЦП, MMU, IO
участок памяти, BAR, PCI, IBM PC, приёмник IRQ, источник IRQ, целые числа,
неотрицательные числа --->
### Моделирование устройств

Подход к моделированию устройств использует принцип _чёрного ящика_: API
определяет какие действия можно совершать над устройством снаружи, и как
устройство должно выполнять свои функции изнутри.

_Снаружи_ устройство:

* подключается к шине-родителю;
* может являться родителем одной или нескольких шин (мостом);
* может допускать настройку через свойства (QOM);
* может иметь входы и/или выходы _GPIO_ (англ. _General Purpose Input/Output_
--- ввод-вывод общего назначения).

_Изнутри_ устройство:

* имеет состояние;
* может взаимодействовать с внешней средой;
* реализует взаимодействие с устройствами на дочерней шине (если является
мостом);
* _реализует внутреннюю поддержку функционала, предоставляемого наружу_.

Данные возможности поддерживаются на базовом уровне.
Реальные стандарты шин предусматривают дополнительные возможности:

* обмен данными;
* передача запросов прерываний.

Этот перечень основан на изучении поддержки шины стандарта PCI и системной шины.
Вторая отличаются тем, что, несмотря на многообразие
стандартов системных шин, варьирующихся от процессора к процессору,
все системные шины реализуют один и тот же функционал.
Это позволило реализовать в QEMU поддержку устройств системной шины без
привязки к конкретному стандарту.
<!-- Однако ощущается влияние архитектуры IBM PC.
У этого исторические предпосылки. -->

Подробное рассмотрение других реализованных в QEMU стандартов шин и способа
реализации новых выходит за рамки данной работы.
<!--
В реализации стандарта шины должно быть задействовано минимум три новых типа:

* тип устройства;
* тип шины;
* тип моста.

При этом происходит добавление новых или уточнение существующих возможностей:
в соответствии со стандартом.
Новый тип устройства является промежуточным.
Модели конкретных устройств должны быть его потомками.
Чтобы новую ветку типов можно было использовать в ВВМ должен быть определён
хотя бы один мост.
Мост является устройством одного из _реализованных_ стандартов.
Он предоставляет доступ к шине добавляемого стандарта по шине реализованного.
Минимальные требования стандарта к мосту, как правило, достаточно высоки, что
позволяет использовать базовый тип моста в ВВМ, не прибегая к реализации
на его основе моделей реальных устройств.
Это во многом зависит от требовательности гостевого ПО.
Хорошим тоном считается определение вспомогательных функций и макросов,
упрощающих работу типами реализуемого стандарта.
-->

#### Обмен данными

Обмен данными по шине осуществляется через _регистры_.
Согласно модели QEMU, регистры --- это относящиеся к устройству участки
памяти, с которыми возможен обмен данными.
Для обмена данными регистры добавляются в адресное пространство соответственной
шины.
Доступ к адресному пространству реализует мост.
Исключением является системная шина: мост не используется, а его функции
реализуются ЦП, MMU и связанным системным кодом.
Подробное рассмотрение этой части эмулятора выходит за рамки данной работы.

Примерами регистров являются:

 * MMIO системной шины;
 * PMIO (PIO) системной шины у IBM PC совместимых машин;
 * BAR шины PCI.

Для реализации регистров используются IO участки памяти.
Логика чтения и записи программируется в функциях-обработчиках.
В API определены вспомогательные функции для объявления регистров изнутри
устройства и для работы с ними снаружи.

#### Запросы прерывания

Помимо обмена данными шины поддерживают передачу запросов прерываний от
устройств к мосту.
А иногда и между устройствами.
Мост может предать запрос дальше: шине-родителю.
В случае системной шины последним приёмником запросов является ЦП.
Перед ЦП обычно встраивается _контроллер прерываний_, управляющий запросами от
других устройств.

Принцип передачи запроса прерывания рассмотрен [$](#rel.IRQ_modeling).
Базовый класс устройств предоставляет API, обобщающий работу с прерываниями
до GPIO.
Этот интерфейс реализует адресацию точек подключения сигнальных линий в
пределах устройства.
Одна точка может быть или входом, или выходом.
Точки собраны в именованные группы:
т.е. _все_ точки имеют _имя_.
API позволяет объявлять точки без указания имени.
Таким точкам неявно присваивается имя "unnamed" (англ. _безымянная_).
Каждая точка внутри именованной группы имеет _индекс_ --- неотрицательное целое
число.
Входы и выходы индексируются раздельно.

При реализации точек подключения именно для линий запроса прерывания выбирается
специальное имя. Например, "sysbus" --- линии, используемые для подключения
прерываний системной шины.

<!--
Реализация API GPIO основана на [свойствах] (#QOM_object_property)(от
родительского типа "object").
-->
<!--+ подход к моделированию устройств, GPIO, адресация GPIO, имя GPIO,
индекс GPIO +-->


<!--- подход к моделированию устройств,
запрос прерываний, GPIO, свойства устройства, регистр устройства,
внешняя среда, поведение устройства, структура экземпляра,
поле структуры (Си) --->
#### Состояние устройства

Поведение устройства в течение времени определяется:

* записью и _чтением_ в/из регистров;
* входящими запросами прерываний и другими GPIO;
* взаимодействием с внешней средой и др.

Если вышеописанное влияет не только на текущее, но и на последующее
поведение устройства, то устройство имеет _состояние_.
Технически, состояние является множеством полей структуры экземпляра, которые
по совокупности влияют на результат работы кода модели устройства.
Состояние устройства является частью _состояния_ всей ВВМ.
<!--
Под состоянием понимается такое множество всех данных, используемых алгоритмами
эмуляции, что _при условии изолированности ВВМ от внешних воздействий_
мгновенная совокупность значений этих данных однозначно определяет дальнейшее
развитие эмуляции.
-->
В QEMU реализована возможность сохранения состояния ВВМ в файл.
Для этого каждое устройство должно зарегистрировать своё состояние.
Используя эту информацию, эмулятор может, приостановив работу, сохранить
состояние всей ВВМ.
Сохранённое состояние называется _снимком_ (англ. _snapshot_).
<!--+ состояние устройства, состояние (ВВМ), снимок (ВВМ) +-->


<!--- свойства объекта (QOM), поле структуры (Си), структура (Си),
тип QOM, конструктор экземпляра, ВВМ --->
#### Свойства устройства

Базовый тип устройств реализует упрощённый механизм добавления свойств к
экземплярам.
В основе механизма лежит допущение, что большинство свойств устройства
может быть представлено одним полем структуры экземпляра.
Механизм позволяет задать соответствие между полем и строкой: именем свойства.
Также вводится ограничение, не позволяющее снаружи изменять значения многих
свойств устройства после того, как оно было создано.
Ограничение состоит в разбиении процесса создания на _инициализацию_ и
_реализацию_.
Инициализация соответствует конструированию экземпляра типа QOM.
В ходе инициализации конструктором экземпляра в устройство добавляются свойства.
В результате получается законченный, с точки зрения QOM, экземпляр, и
начинается реализация.
В ходе реализации происходит внешняя настройка устройства: присваивание
значений свойствам.
В последнюю очередь булеву свойству "realized" присваивается "истина", что
является завершением реализации.
Менять значения свойств реализованного устройства нельзя.
После реализации происходит встраивание устройства в ВВМ.

<!--
Способ регистрации полей структуры устройства в качестве его свойств усложняет
их определение и задание им начальных значений, но предоставляет следующие
возможности:

* Прозрачное преобразование инвариантных строковых идентификаторов
объектов в указатели. Идентификаторы удобно использовать при
создании устройства. При написании кода ВМ это снимает с
программиста необходимость писать код, получающий указатели.
Код получается короче и понятнее.
Кроме того, только таким способом можно определить значение
свойства через CLI. Указатели же оптимизируют доступ к памяти
внутри реализации устройства.

* Контроль корректности значений.
-->
<!--+ свойство устройства, инициализация устройства, реализация устройства +-->


<!--- QOM, тип (QOM), тип-родитель, конструктор модуля (язык Си), правило (GNU
Make), макрос (Си), деструктор класса, деструктор экземпляра  --->
## <a name="rel.QOM_type_inheritance"></a>Наследование типа QOM

Минимальный код, который должен быть написан, чтобы наследовать тип в QOM,
включает в себя:

* инициализацию структуры `TypeInfo`, где должны быть указаны
строковые имена родительского типа и наследуемого типа;

* функцию `register_types` --- конструктор модуля, вызывающую
`type_register_static` для всех `TypeInfo` в модуле;

* применение макроса `type_init`, указывающего компилятору, что
`register_types` является конструктором модуля<!--: её следует вызвать
неявно (не помню, что я этим хотел сказать)-->;

* правило в `Makefile`, регистрирующее модуль в системе сборки.

Добавленный таким образом тип не будет обладать новой
функциональностью. А если родитель _абстрактный_, то новый тип даже
нельзя будет создать.
<!--+ TypeInfo, register_types, type_register_static, type_init, минимальный код
при наследовании типа +-->

<!--- структура экземпляра, конструктор экземпляра, структура класса,
конструктор класса, TypeInfo, минимальный код при наследовании типа --->
На практике код чаще всего содержит, среди прочего, следующее.

* Структуры экземпляра и класса. В них _первым_ полем обязательно присутствует
структура экземпляра родительского типа. <!-- Это повтор, см.
[$](#rel.QOM_type_structs). -->

* Указание размеров структур экземпляра и класса в `TypeInfo`.

* Указание в `TypeInfo` адресов функций, выполняющих роли конструкторов и
деструкторов экземпляра и класса.
<!--+ практический код при наследовании типа +-->


<!--- тип QOM, практический код при наследовании типа, свойство устройства,
реализация устройства, состояние устройства, стиль программирования,
перегрузка (QOM), сброс устройства --->
## Определение модели устройства

Модель устройства является типом QOM и должна содержать соответствующий код.
Кроме этого код модели устройства обычно содержит:

* регистрацию состояния устройства,
* регистрацию свойств устройства,
* функцию реализации устройства,
* функцию сброса устройства,

Регистрация состояния устройства заключается в следующем.

* Инициализируется структура `VMStateDescription`.
Важным полем этой структуры является массив `fields`.
Помощи макросов вида `VMSTATE_*` в этом массиве должны быть перечислены поля
структуры экземпляра составляющие состояние устройства.

    * Выбор макроса зависит от типа поля;
    * Если поле является структурой, то для неё должна быть инициализирована
    отдельная структура `VMStateDescription`.
    * Последним элементом массива должен быть признак конца:
    `VMSTATE_END_OF_LIST()`.
    * Допускается указание _версии_ поля, которая используется для
    совместимости снимков разных версий модели устройства.

* Перегрузка поля `vmsd` структуры класса указателем на структуру
`VMStateDescription`.
[Напомним](#overridance_in_QOM), что перегрузка производится в
соответствующем конструкторе: конструкторе класса.

Регистрация свойств устройства выполняется следующим образом.

* Создаётся массив описателей свойств.
Описателем является структура `Property`.
Определение элементов массива осуществляется с помощью макросов вида
`DEFINE_PROP_*`.
Выбор макроса зависит от типа свойства.
При этом для каждого свойства указывается:

    * строковое имя,
    * поле этой структуры, которое будет хранить значение свойства;
    * значение по умолчанию (в случае, когда оно не фиксировано API QEMU).

Последним элементом должен быть признак конца массива:
`DEFINE_PROP_END_OF_LIST()`.

* Определение в заголовочном файле устройства макросов со
строковыми именами свойств (требование стиля программирования).

* Перегрузка поля `props` структуры класса указателем на массив описателей
свойств.

Функция сброса устройства должна устанавливать структуру экземпляра в
определённое начальное состояние.
Причём обработку полей, которые не меняются в процессе работы устройства
следует оставить функции реализации или конструктору.

Функция реализации устройства должна выполнять действия, которые зависят от
значений свойств. Остальные действия (кроме сброса) желательно размещать в
конструкторе.
<!--+ минимальный код определения модели устройства +-->


<!--- тип QOM, практический код при наследовании типа, конструктор экземпляра
конструктор класса, компоненты ВМ, ВВМ, ОС, Linux,
микропрограммное обеспечение --->
## Определение модели вычислительной машины

Виртуальная вычислительная машина является типом QOM и должна содержать
соответствующий код.
Важной особенностью является то, что имя типа должно иметь суффикс `-machine`.
Кроме этого код модели обычно содержит следующее.

* Функцию инициализации. Её не следует путать с конструктором экземпляра.
Основная задача функции инициализации --- создание и связывание компонентов.
Первоначально, она может быть пустой.

* Регистрация функции инициализации и определение строкового имени ВМ.
Используя это имя, пользователь может выбрать эту ВМ при старте эмулятора.
Эти действия выполняются в конструкторе класса. Использование этой информации
осуществляется в конструкторе экземпляра базового типа "machine".

Основную часть кода ВВМ составляет функция инициализации.
В ней создаются процессор, память, мосты, периферийные устройства и т.д.

В некоторых случаях ВВМ может допускать настройку через свойства.
Чтобы добавить свойства в ВВМ, необходимо определить конструктор экземпляра,
который выполнит соответствующие действия.
Конструктор экземпляра базового типа предусматривает ряд свойств, которых
достаточно для большинства ВВМ:

* `kernel`, `initrd` и `append`: используются, если в функции
инициализации ВВМ предусмотрена загрузка ядра ОС Linux;

* `firmware`: предусматривает загрузку микропрограммного обеспечения;

* `usb`: даёт возможность включить поддержку USB в ВВМ; и др.

Реальная работоспособность этих свойств зависит от реализации функции
инициализации ВВМ.

Кроме того, структура экземпляра базовго типа, содержит следующие
поля, не оформленные как свойства:

* `cpu_model`: имя QOM типа процессора;

* `ram_size`: объём ОЗУ.

Однако, функция инициализации может игнорировать и их: реальная
ВВМ может существовать с фиксированной моделью процессора и объёмом
ОЗУ.
<!--+ минимальный код определения ВВМ, свойства ВВМ +-->


<!--- QEMU --->
# Подход к автоматизации

На рисунке [$](#pic.main) изображены основные принципы работы разработанного
инструмента.
Вручную или с помощью разработанного графического интерфейса (ГИ) разработчик
указывает основные параметры разрабатываемых моделей.
Для указания параметров инструмент предоставляет человеко-ориентированный
интерфейс программирования.
На основе указанных параметров инструмент автоматически генерирует заготовки
программного кода моделей.
Эти заготовки не обладают законченной функциональностью, но готовы к компиляции.
Генерация основана на шаблонах --- фрагментов программного кода, которые
подстановками строковых параметров приводятся в синтаксически корректный код
на языке Си.
При этом используется информация, получаемая об эмуляторе автоматически, с
применением специализированного анализа программного кода.
Дальнейшая работа разработчика заключается во внесении в заготовку кода,
соответствующего не формализованным особенностям работы устройства, согласно
документации на него.
Важной особенностью является то, что объём кода, формулирующего параметры
устройства, на порядок меньше, чем объём генерируемого кода.
Таким образом, инструмент ускоряет разработку модели за счёт сокращения
объёма кода, написанного вручную.
В случае разработки ВВМ, принципиальной разницы в количестве кода нет.
Отличие заключается в представлении ВВМ в виде схемы средствами ГИ.
Схематичное представление облегчает восприятие ВВМ, что снимает с разработчика
умственную нагрузку.
Кроме этого исключаются лексические, синтаксические и некоторые семантические
ошибки.

![Рисунок <a name="pic.main">$</a> --- Метод автоматизации разработки моделей
устройств и вычислительных машин](main.png)

Метод шаблонов основан на следующей особенности кода QEMU.
Любая модель, как устройство, так и машина, является частью эмулятора.
Следовательно, её код, среди прочего, содержит фрагменты, обусловленные
требованиями эмулятора, а не особенностями оригинала.
Таким образом, условно код модели можно разделить на две части:
_индивидуальную_ и _интерфейсную_.

В первую очередь рассмотрим это разделение для устройств.
Индивидуальная часть задает поведение устройства в его программной реализации.
Именно эта часть определяет то, как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройства является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя возможности,
предоставленные посредством API QEMU. В модели всегда можно
выделить часть кода,
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и остальным кодом
эмулятора.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных. Т.е. её параметры хорошо
формализуемы.

Отдельно нужно сказать о применимости данного подхода к ВМ.
В QEMU присутствует развитое API для интеграции устройств в единое целое
(то есть в ВМ).
Разработанный API во многом похож на API из QEMU.
С помощью разработанного API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть, реализованную в
полном соответствии с принятым в QEMU подходом к написанию моделей устройств.
Иначе несоответствие придётся компенсировать вручную.

2. Сгенерированная машина не поддаётся настройке, так как все её параметры
зафиксированы на уровне исходного кода. Реализация возможности настраивать
машины требует внесения кода вручную.

Первое ограничение не существенно, если преобладающая часть устройств ВМ
реализуется вместе с ней по формальному описанию с помощью разработанного
инструмента.
Такие устройства будут иметь совместимую интерфейсную часть.
Но в QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к написанию моделей устройств.
На данный момент не все из них были переписаны в соответствии с этим подходом.
То есть они реализуют свою индивидуальную часть в обход новейших возможностей
API для интерфейсной части.
Если же нужно использовать подобную модель устройства, то возможно
использовать разработанный
инструмент, сгенерировав с его помощью новую интерфейсную часть.
В противном случае интеграцию такого устройства придётся производить
вручную, что менее эффективно.

Второе ограничение заключается в следующем.
Часть параметров машины задается пользователем только в момент запуска
эмулятора через CLI (Command Line Interface --- англ. интерфейс командной
строки):

* файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
* оконечную точку УАПП (виртуальный терминал, файл, и т.п.),
* способ подключения сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.)
и т.д.

Поддержка CLI требует внесения в код заготовки машины специального кода.
Автоматизация этого процесса для наиболее распространённых опций CLI является
направлением дальнейших исследований.
<!--+ интерфейсная часть, индивидуальная часть +-->


## Метод шаблонов
<!--- интерфейсная часть, индивидуальная часть, QEMU, эмулятор, интерфейс,
язык Си, функция (Си), аргумент функции, структура (Си) --->
Состав интерфейсной части устройства определяется:

* задаваемым эмулятором формальным минимумом;
* потребностями индивидуальной части.

QEMU предоставляет ряд интерфейсов, из которых в интерфейсную часть
выбираются нужные.
Код, соответствующий отдельно взятому интерфейсу, единообразен.
Его можно получать из некоторого набора строковых заготовок, путём подстановки
параметров.
Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов.
Это требование следует из синтаксиса языка Си.
Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.
Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов.
<!--+ шаблон +-->
<!--- шаблон, QOM, конструктор устройства, регистр устройства,
участок памяти IO, --->
Например, конструктор устройства является частью шаблона, встраивающего
устройство в иерархию типов QOM.
Если же устройство имеет регистры, то для их реализации применяется шаблон
участка памяти типа IO.
Но регистры должен быть зарегистрирован конструктором.
А значит, имя переменной, описывающей регистры, является параметром
шаблона конструктора.
<!--+ +-->

<!--- шаблон --->
Таким образом, между шаблонами существуют следующие виды связей:

* порядковая --- один шаблон должен следовать за другим;
* параметрическая --- когда в нескольких шаблонах используются связанные по
значению параметры.
<!--+ связь между шаблонами +-->

<!--- шаблон, связь между шаблонами, модуль (Python)  --->
## Программный модуль шаблонов

Связи между шаблонами происходят или от эмулятора, или от языка Си.
Это значит, что связи могут быть или получены автоматически, или быть
определены вручную однократно и тиражироваться.
С учётом этого был разработан программный модуль автоматизирующий работу со
связями.
Модуль предоставляет два интерфейса:

* по _использованию_ шаблонов;
* по _добавлению_ шаблонов связей между ними.
<!--+ интерфейс использования шаблонов, интерфейс добавления шаблонов  +-->

<!--- интерфейс использования шаблонов, QEMU, иерархия классов QOM, ВМ,
PCI, MSI, QEMU, PCI Express, устройство PCI, функция PCI --->
### Интерфейс использования шаблонов
Интерфейс использования шаблонов ориентирован на получение от пользователя
перечня перечня интерфейсов QEMU, требуемых разрабатываемой моделью, и их
параметров.
Для этого интерфейс использования предоставляет иерархию классов.
Она построена по тому же принципу, что и иерархия классов QOM.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначен для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство QEMU.

Напомним, что PCI-_устройство_ в QEMU соответствует одной _функции_ реального
устройства.
А поскольку QEMU не моделирует физические взаимодействия по шине,
поддержка MSI (а именно реакция на запись сообщения в память) реализуется
мостом или контроллером прерываний, обычно являющимися устройствами.
Как следствие, и PCI, и PCI Express устройство может быть описано через этот
класс.

Перечисленные классы выполняют роль контейнеров для параметров.
При генерации кода на основе этих параметров создаются объекты внутренних
классов модуля, непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно
одного объекта перечисленных классов, для описания ВМ требуется ещё
одна иерархия, рассмотренная [$](#rel.machine_hierarchy).
Объект класса `MachineNode` служит контейнером для объектов последней иерархии
и прочих параметров генерации.

Совместно объекты этих классов-потомков `QOMDescription` образуют
_проект_ (`QProject`), аккумулирующий данные для генератора кода.
<!--+ QOMDescription, SysBusDeviceDescription, PCIExpressDeviceDescription,
MachineNode, QProject +-->

<!-- MachineNode, мост, дочернее устройство, иерархия QOM, дочерняя шина,
устройство-родитель шины, свойства устройства, GPIO, инкапсуляция (ООП),
источник прерывания, приёмник прерывания, адресация GPIO, GPIO,
двоичный сигнал, участок памяти, участок-контейнер, участок-псевдоним,
участок-RAM, участок-ROM, участок-IO, графический интерфейс инструмента -->
#### <a name="rel.machine_hierarchy"></a>Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа.
Все дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для ручной работы с программным интерфейсом.
При использовании графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода для шины этого типа. И
только следующие параметры определяют место шины в ВМ:

* ссылка на мост;
* ссылки на дочерние устройства.

`DeviceNode` описывает параметры, присущие любому устройству:

* модель устройства (тип в иерархии QOM);
* ссылку на родительскую шину;
* ссылки на дочерние шины, если устройство является мостом;
* список значений свойств устройства;
* ссылки на подключённые GPIO с параметрами их подключения.

Классы наследуемые от `DeviceNode` расширяют этот список в соответствии с
шаблонами устройств для конкретных стандартов шин.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
инкапсулирована в шину).
Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два конца).
Линия содержит информацию об источнике и приёмнике прерывания.
Причём для каждой точки подключения, являющейся устройством, определены:

* ссылка на устройство;
* имя GPIO;
* индекс GPIO.

Если концом является концентратор, то достаточно только ссылки.

Исходя из используемого в QEMU обобщения прерываний до GPIO, данные связи могут
использоваться для обмена любыми двоичными сигналами, а не только прерываниями.

Следующие классы используются для явного создания участком памяти.
Большую часть адресного пространства ВМ определяют сами устройства.
Участки памяти, соответствующие ОЗУ, некоторм ПЗУ и т.п., должны быть добавлены
явно.
Кроме этого, некоторые мосты не создают адресное пространство для своих шин, а
требуют его передачи извне.
В таблице [$](#tbl.memory_region_correspondence) приведено соответствие классов
узлов ВМ и типов участков памяти, шаблоны которых создаются для этих узлов.

Таблица <a name="tbl.memory_region_correspondence">$</a>.
Соответствие узлов ВМ и описываемых ими участков памяти.

+-------------------+--------------------+
|       Узел        | Тип участка памяти |
+===================+====================+
|    `MemoryNode`   |      контейнер     |
+-------------------+--------------------+
| `MemoryAliasNode` |      псевдоним     |
+-------------------+--------------------+
|  `MemoryRAMNode`  |         RAM        |
+-------------------+--------------------+
|  `MemoryROMNode`  |         ROM        |
+-------------------+--------------------+

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять участки в участки, не являющиеся контейнерами.
Для участков IO специального узла не предусмотрено.
Это обусловлено тем, что IO участки используются для реализации регистров.
А все регистры должны быть распределены по устройствам.

Каждый из классов, описывающих участок памяти, предусматривает следующие
параметры:

* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
разрешения;

<!--
`MemoryNode` _может_ иметь не пустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы, и ссылку на него.
-->

Основными функциями всех классов, предоставляемых интерфейсом использования
шаблонов (включая потомков `QOMDescription`), являются:

* хранение параметров генератора,
* сохранение параметров в файл и обратно.
<!--+ Node, BusNode. SystemBusNode, PCIExpressBusNode, ISABusNode, IDEBusNode,
I2CBusNode, DeviceNode, SystemBusDeviceNode, PCIExpressDeviceNode`,
IRQLine, IRQHub, MemoryNode, MemoryLeafNode, MemoryAliasNode, MemoryRAMNode,
MemoryROMNode +-->

<!--- QProject, Python, аттрибут объекта (Python), "простой тип" (Python),
None (Python) --->
### Формат файла проекта

<!--
При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.
-->

Формат файла, хранящего проект, основывается на возможности интерпретатора
языка Python динамически добавлять код в программу.
Сохранённый проект представляет собой код на языке Python.
В данном случае код загружается из файла.
Поскольку инструмент сам написан на языке Python, данное решение существенно
упростило разработку.
Результатом выполнения кода проекта является определение переменной,
ссылающейся на объект класса `QProject`, _эквивалентный_ объекту,
сохранённому в этом коде.
Генератор файлов сохранений изначально разрабатывался таким образом, чтобы
файлы выводились в удобном для человека форматировании.

Под _эквивалентностью_ сохранённого и восстановленного объектов понимается:

* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект, эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте<!-- (ссылки на `None` восстанавливаются как ссылки на
`None`) (излишняя техническая деталь) -->.

Однако при сохранении _не_ гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически незначащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность имён переменных;
* использование тех же самых конструкций языка (например, программист может
создавать несколько объектов в цикле, в то время как инструмент сгенерирует для
этих объектов развёрнутый код);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является одним из направлений дальнейших исследований.
<!--+ формат файла проекта, эквивалентный объект (Python) +-->


<!--- шаблоны, .format (Python), % (Python), форматная строка (концепция),
АСД, препроцессор (Си), стиль программирования QEMU, printf,
интерфейсная часть, индивидуальная часть, цикл (Си), ветвление (Си),
конструктор экземпляра, конструктор класса, принцип чёрного ящика,
функции (Си), макрос, функция реализации устройства,
функция инициализации ВВМ --->
###Интерфейс добавления шаблонов

Шаблоны реализованы с помощью форматных строк.
Генерация кода заключается в подстановке параметров в форматные строки.
Из полученных фрагментов кода затем составляются файлы.
Для форматирования используются следующие способы:

* `printf`-подобный, реализуемый оператором `%`, для простых подстановок;
* расширенный, поддерживаемый методом `format`.

Второй вариант используется для написания более сложных шаблонов, так как
за счёт именования позиций подстановок в форматных строках легче
ориентироваться, однако они получаются избыточней.

Форматные строки являются самым низкоуровневым способом определения
шаблонов.
Изначально все шаблоны разрабатывались в виде форматных строк.
Сложность их написания сравнима со сложностью программирования на языке Си.
Однако форматные строки ограничены в программной обработке.
Кроме этого было замечено что у них есть много общего, так как они являются
кодом на языке Си.
В связи с этим для разработки шаблонов был введён вспомогательный интерфейс.
Будем называть его _интерфейсом добавления шаблонов_.
Он основан на форматных строках, но предоставляемые им инструменты
ориентированы на генерацию базовых конструкций языка Си.
Поэтому интерфейс напоминает программную реализацию АСД, однако
есть принципиальное отличие: он поддерживает и язык препроцессора.

Параллельно была предпринята попытка использовать для определения
шаблонов АСД языка Си. Библиотека PyCParser[[$](#ref.PyCParser)],
реализует двустороннее преобразование. Однако у применения АСД имеются
следующие недостатки:

* не поддерживается препроцессор, макросы которого активно используются
в интерфейсной (и не только) части кода устройства;

* не учитываются незначащие символы (пробелы, переносы строк,
комментарии), что требует доработки генератора PyCParser, таким образом,
чтобы он генерировал код, не противоречащий стилю программирования QEMU.

В настоящее время модель смешанного языка Си и препроцессора является
одним из основных объектов дальнейших исследований.
Текущая версия успешно описывает такие макроскопические конструкции как
структуры, переменные и их инициализацию, макросы и объявления функций.
Заметным упущением является отсутствие описания тел функций.
Они задаются первоначальным способом: форматными строками.
Ввиду того, что инструмент не ставит своей целью генерацию индивидуальной
части моделей устройств, тела функций, в большинстве случаев, могут
рассматриваться модулем шаблонов как чёрные ящики.
Исключением является конструкторы, функция реализации устройств и функция
инициализации ВВМ.
Но эти функции суть последовательность инициализаций: такие конструкции как
циклы и ветвления в таких функциях не используются.
То есть практической надобности в детальной проработке этой части модели пока
не было.
<!--+ общие сведения об интерфейсе добавления шаблонов +-->


<!--+ общие сведения об интерфейсе добавления шаблонов,
двоичный транслятор QEMU, PyCParser, макрос  +-->
#### Модель языков Си и препроцессора

Основой интерфейса добавления шаблонов является модель _гибридного языка_,
сочетающего язык Си и подмножество языка препроцессора.
Эта модель описывает содержимое заголовков и модулей языка Си.
Разработчик описывает содержимое шаблона с точки зрения того, какие
конструкции должны быть добавлены в файл в соответствии с этим шаблоном.
Причём один шаблон может касаться нескольких файлов, ровно как и один файл
может содержать конструкции из нескольких шаблонов.
Некоторые конструкции из шаблонов связаны с уже существующими в QEMU
конструкциями.
Поэтому интерфейс позволяет определять содержимое существующих файлов.
Описание существующих конструкций носит декларативный характер.
Многие подробности могут быть пропущены, так как генерация не предполагается.
Иными словами используется принцип минимально достаточной информации.

При описании содержимого файла используются следующие классы.

* `Type`
    * `Structure`
    * `Function`
    * `Enumeration`
    * `Pointer`
    * `Macro`
    * `TypeReference`
* `Initializer`
* `Variable`
* `Usage`

_Тип_ (класс `Type`), как можно заметить из перечня подклассов, тут
понимается как нечто большее, чем тип в языке Си.

Объект класса `Type` обладает следующими свойствами:

* `name` --- уникальное имя типа;
* `incomplete` --- незавершенный тип, нельзя создать _переменную_
такого типа;
* `definer` --- идентификатор файла, где этот тип _определён_;
* `base` --- базовый тип, который имеется в языке, для его использования
не нужно подключать заголовки.

Уникальность имени типа даёт возможность находить тип только по имени:
не требуется сначала искать файл, где этот тип определён. Это облегчает
работу разработчика шаблонов, но имеет _теоретический_ недостаток,
заключающийся в следующем.
Совместное хранение макросов вместе с типами языка Си, строго говоря, делает
требование уникальности имени невыполнимым в общем случае.
Однако данная проблема не возникает в QEMU благодаря принятому стилю
программирования.
Известно, что в QEMU реализации двоичного транслятора для разных
целевых архитектур имеют пересекающиеся множества имён символов языка Си
и препроцессора. Но устройства и ВМ реализуются архитектурно независимо,
и, обычно, не связаны с реализацией транслятора.
Кроме этого разные реализации транслятора не используются вместе.

Класс `Type` не предусматривает шаблона для генерации кода. Это значит,
что нельзя сгенерировать файл, где есть хоть одна сущность, описываемая
этим классом. Фактически, этот класс применяется для ручного определения
списка типов, присутствующих в существующих файлах QEMU, в тех
случаях, когда достаточно только имени типа для подключения нужного
заголовка.

Одним из направлений дальнейших исследования является синтаксический
анализ файлов QEMU с целью автоматического создания объектов,
описывающих существующие типы. В настоящий момент такая функциональность
реализована только для макросов препроцессора и опирается на функционал
модифицированного препроцессора из библиотеки PyCParser.

Объект `TypeReference` (ссылка на тип) используется для ссылок на типы
из других файлов. Любой тип может присутствовать непосредственно только
в файле, где он объявлен. Но, когда один файл включается в другой с помощью
директивы `#include`, второй косвенно содержит все типы первого.
Чтобы отличить включённые типы от непосредственно определённых в данном файле
применяется `TypeReference`. Ссылка создаётся для каждого включённого типа,
включая те, которые уже были ссылками.
Такой подход даёт возможность при генерации кода
однозначно определить следует ли сгенерировать непосредственное
определение типа по шаблону, или сгенерировать включение заголовочного
файла, где он определён.

Если необходимо объявить переменную типа из другого файла, используется
`TypeReference`. То есть создаётся ещё один тип с тем же именем, но
особым способом обработки:

* имя такого типа не индексируется реализацией интерфейса и, следовательно,
требование уникальности игнорируется;
* шаблоном для генерации кода `TypeReference` является директива
`include` препроцессора.

Тут важно заметить, что в отличие от Си, модель не делает разграничения
на _объявление_ и _определение_. То есть объявление функции (или
внешней переменной) в заголовке
и её определение в модуле --- два разных _определения_ в данной модели.
Синтаксическая необходимость обеспечить объявление функции до
её определения достигается добавлением в объект типа, представляющего
её определение, ссылки (`TypeReference`) на тип, представляющий её
объявление. Таким образом, будет сгенерирована директива `include`,
подключающая соответствующий заголовочный файл до определения функции.

Класс `Variable` (переменная) описывает пару: "тип, имя". В данной модели
_переменная_ нечто большее, чем переменная в языке Си. Суть этого
класса раскрывается при описании нижеизложенных классов API. Для случая,
когда этот класс используется для описания переменной языка Си,
предусмотрены следующие поля:

* `static` --- соответствует одноимённому слову языка Си;
* `initializer` --- инициализатор, начальное значение переменной;
* `array_size` --- используется для определения массивов, в том числе и
безразмерных (когда размер определяется компилятором по инициализатору,
или когда нужно определить переменную-указатель, используя `[]` вместо
`*`).

Класс `Structure` (структура) используется для объявления составного типа.
По представленному в нём описанию создаётся конструкция `struct` языка Си.
Объект класса содержит список полей (`fields`), определяемых объектами
класса `Variable`.
<!--
Иногда часть полей структуры в языке Си определяется
макроподстановкой. В данной модели такие поля описываются одной
_переменной_, тип которой является соответствующим макросом (`Macro`), а
имя игнорируется.
-->

Класс `Function` (функция) используется для описания конструкций языка
Си, связанных с функциями этого языка:

* объявление функции;
* определение функции, в том числе статических (`static`) и/или
встраиваемых (`inline`);
* определение типа указателя на функцию (применяется совместно с
классом `Pointer`);

Объект `Function` содержит следующие дополнительные поля:

* `ret_type` --- тип возвращаемый функцией;
* `args` --- список аргументов функции (аналогично полям структуры);
* `static` и `inline` --- фактически определяют наличие соответствующих
ключевых слов в генерированном коде;
* `body` --- текст тела функции;
* `used_types` и `used_globals` --- список, соответственно, типов и
глобальных переменных, использованных в теле функции; данная информация
необходима, так как на данный момент модель не поддерживает тела
функций.

При определении тела функции разработчик должен, используя
вспомогательные средства интерфейса, сконструировать тело функции, сохраняя
списки использованных в нём типов и глобальных переменных.
Затем он передаёт эти списки в объект функции.

Важно заметить, что под понятие "использованный тип" подпадают
также такие сущности как:

* вызванные функции;
* структуры, использованные при объявлении переменных;
* использованные макросы; и т.п.

Класс `Pointer` (указатель) применяется для создания указателей
различного вида:

* именованных типов указателей (например, `typedef int* intptr;`),
включая указатели на функции;
* определение переменных-указателей на другие типы (в том числе
полей структур и аргументов функций).

При определении переменной-указателя создаётся _безымянный_ тип
указателя. На самом деле имя ему формально генерируется путём
подстановки '`*`' к основному типу, согласно синтаксису языка
Си. Но имя такого типа не индексируется реализацией интерфейса и, следовательно,
может не быть уникальным. Кроме того, этот тип не привязывается
к какому-либо файлу, то есть наличие где-нибудь переменной такого
типа не вызывает генерации директивы `include` само по себе.
Однако тип под указателем, если он не является базовым, должен быть
обеспечен либо директивой `include`, либо непосредственным
определением.

Класс `Macro` (макрос) соответствует директиве `define`
препроцессора. Поддерживаются как параметризованные макросы, так
и не параметризованные макросы. Однако поддержка параметров
ограничивается только генерацией вызова макроса: раскрытие же не
требуется для генерации файла (ровно как и выполнение
сгенерированного Си-кода, чем, по сути, и является раскрытие макроса,
с точки зрения данной модели).

Класс `Initializer` (инициализатор) используется для определения
начальных значений
переменных или параметров вызова макроса. Поле `code` содержит
данные, используемые для генерации кода инициализатора, а поля
`used_types` и `used_variables` хранят ссылки на, соответственно,
типы и переменные, использованные в коде инициализатора. Модель
инициализатора схожа с моделью тела функции, и обе они пока не
развиты, являясь объектами дальнейших исследований.

Класс `Usage` (использование) применяется, когда при генерации
переменной некоторого
типа не достаточно использовать в шаблоне имя типа непосредственно.
Т.е. имя типа должно быть преобразовано некоторым образом перед
вставкой в шаблон. `Usage`
добавляет инициализатор (`Initializer`) к _типу_ переменной, на
основании которого и происходит видоизменение имени типа.
Единственным примером в настоящее время является макрос.
Инициализатор используется для расстановки
значений при генерации вызова макроса. Имя переменной и _её_
инициализатор при этом игнорируются.

Рассмотренная модель не является законченной. Но даже в таком варианте
она позволяет с достаточно гибкостью описывать шаблоны устройств и ВМ,
используемые при генерации интерфейсной части их кода. Развитие
этой модели является направлением дальнейших исследований.
<!--+ модель Си и препроцессора, элементы интерфейса добавления шаблонов +-->


<!--- шаблон, форматная строка, модель Си и препроцессора,
двоичный транслятор QEMU --->
##<a name="Codegeneration"></a>Генерация кода

Генерация кода заключается в получении из шаблонов фрагментов кода и
объединение их в файлы.

Получаемые при генерации фрагменты кода не являются независимыми. Язык
Си требует, чтобы многие имена были объявлены до их использования.
В том числе с использованием директивы `include` препроцессора.
Аналогичное требование есть для препроцессора.
То есть генератор должен не только сгенерировать фрагменты кода, но
и расположить их в правильном порядке. Также требуется сгенерировать
включение требуемых заголовков, причём желательно, минимизировать
количество включений. Не стоит забывать, что порядок включения заголовков
иногда существенен.

Для учёта этих особенностей была разработана модель файла с исходным кодом
Она оперирует неделимыми текстовыми
фрагментами, из которых состоит файл, и порядковыми связями между ними.
Элементы этой модели конструируются из элементов модели языка Си и
препроцессора.

### Модель файла с исходным кодом

Описанная выше модель языка Си и препроцессора не обеспечивает генерацию
синтаксически корректного файла. Её задача: сгенерировать законченные
_фрагменты_ генерируемого файла. При этом остаётся решить следующие
задачи:

* расположить фрагменты в синтаксически корректном порядке;
* обеспечить смысловую группировку фрагментов;
* соблюсти требования стиля программирования QEMU к форматированию кода
(длина строки 80 символов, отступы, правила переноса и т.д.);
* устранить дублирующиеся фрагменты;
* минимизировать количество директив включения заголовков.

Далее эти задачи рассматриваются подробнее.

### Сортировка фрагментов

Язык Си накладывает жесткие ограничения на порядок
определения различных символов. Например, тип должен быть объявлен
до того, как будет создана переменная этого типа, или будет
объявлена функция, принимающая аргумент такого типа. Подробное
рассмотрение всех возможных примеров выходит за пределы данной статьи.
Важно заметить, что почти все фрагменты связаны друг с другом, образуя
ациклический граф, и для обеспечения синтаксически корректного порядка
используется топологическая сортировка.

Помимо требований синтаксиса есть требования стиля программирования и
здравого смысла, согласно которым, фрагменты должны следовать в
следующем порядке:

1. включение заголовков;
2. объявление типов языка Си и макросов;
3. объявления функций;
4. определение функций, глобальных переменных и прочий код.

### Соблюдение стиля программирования

Стиль программирования требует, чтобы строки были не длиннее
80 символов. Удовлетворение этого требования было снято с модели
модели языков Си и препроцессора, чтобы не усложнять её. Требуемая длина
строки обеспечивается переносом строк по словам, при этом применяется
экранирование непечатного символа конца строки символом "`\`". Это
консервативный подход, обеспечивающий корректность в случае макросов и
строковых литералов.

В настоящее время эта проработана недостаточно: не редко на выходе инструмента
получается код, нарушающий стиль программирования.
Это является одним из важнейших направлений дальнейших исследований, так как
качественная генерация кода освобождает разработчика от необходимости
внесения ряда правок в конечный код.
То есть она ускоряет разработку новых устройств и машин, что является основной
целью данной работы.

### Устранение дубликатов

При генерации фрагментов из модели языка не отслеживаются уже созданные
фрагменты. Это сделано для упрощения алгоритма генерации фрагментов
файла из модели языка. При генерации фрагментов осуществляется обход
графа использования типов, последовательно, начиная с каждого
типа, определяемого в генерируемом файле. Если типы одного файла
используют для определения себя типы из этого же файла, то для
использованных многократно типов будет сгенерировано несколько
клонов.

Для определения клонов, каждый фрагмент хранит ссылку на тип, из
которого он получен. Таким образом для каждого типа можно найти все
клоны и оставить один. Важно учесть, что каждый клон содержит свою
часть зависимостей от других фрагментов, ровно как и разные
фрагменты зависят от разных клонов. При устранении клонов эти
зависимости объединяются. Для ускорения алгоритма объединения
зависимостей хранятся обратные ссылки (на зависимые фрагменты).

### Учёт зависимостей и взаимосвязь с существующим кодом

Как уже отмечалось, для обеспечения видимости символов, объявленных в
других файлах, генерируются директивы `include`. При этом имеются следующие
тонкости:

1. заголовочные файлы сами используют `include` для подключения других
файлов, поэтому подключение одного файла может заменить подключение
нескольких;

2. иногда важен порядок включения заголовков:

    * один заголовок может определять макросы, влияющие на поведение
    макросов в другом заголовке;
    * заголовок может не обеспечивать видимость определённых в других
    заголовках типов требуемых для определения своих типов, возлагая
    задачу включения тех заголовков на файлы, которые будут включать его
    (эта возможность активно используется в сообществе QEMU для
    облегчения работы препроцессора <!--(экономия дискового пространства,
    занимаемого исходным кодом, и электрической энергии, расходуемой на
    конкатенацию более длинных строк)--> и усложнения работы программиста).
    <!--(а шоб жизнь мёдом не казалась)-->

3. перед подключением некоторых заголовков, подключающий файл должен
сам определить некоторые макросы и/или типы языка Си; подобный случай не
встречается при написании моделей устройств и ВМ, но известно, что он
используется в коде, относящемся к двоичному транслятору.

Первая особенность используется инструментом для сокращения количества
подключаемых заголовков на основе анализа графа включения заголовков.
Граф строится автоматически с использованием модифицированного
препроцессора из библиотеки PyCParser.

Чтобы учесть вторую особенность для заголовка можно указать список
зависимостей. Каждая зависимость это тип (`Type` из модели Си и препроцессора).
Когда для
определения своего типа заголовку требуются другие типы, то можно
поступить следующими способами:

1. подключить необходимые заголовки, при этом:

    * рекурсивно подключая заголовки, удовлетворяющие зависимости
    подключаемых заголовков;
    * или добавляя зависимости подключаемых заголовков к своим зависимостям;

2. добавить требуемые типы в список зависимостей.

При генерации заголовков инструмент придерживается первого способа, подключая
все необходимые заголовки. А поскольку модификация существующих заголовков не
применяется, то для них остаётся только второй подход.
<!--+ детали генерации кода +-->


<!--- GNU Make, bash, QEMU --->
### Встраивание кода в QEMU

Для добавления заготовки устройства или платформы в QEMU кроме создания
соответствующего исходного кода на Си, нужно зарегистрировать новые
модули компиляции в системе сборке. Система сборки QEMU реализована
распространённым методом: связкой bash-сценария `configure` и набора
правил для утилиты `GNU Make`. Модули QEMU разбиты на папки
по семантике, содержащегося в них кода. В каждой папке присутствует
`Makefile` с правилами сборки специального вида, которые перечисляют
модули и вложенные папки. Инструмент имеет функциональность, позволяющую
добавить модуль-заготовку в заданную папку, убедившись, что модуль включён в
список сборки.
<!--+ детали встраивания в QEMU +-->


<!--- QEMU, Git, SHA1, граф, Python, шаблон, целое число, модуль (Python),
класс (Python) --->
## Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие шаблоны несовместимыми с
новой версией.

Для решения этой проблемы используется эвристический подход. Все аспекты
поведения инструмента, зависящие от версии QEMU, называются _эвристиками_.
Так как один аспект работы может меняться многократно, то каждая эвристика
представлена одной или несколькими записями в базе данных.

Код инструмента получает доступ к требуемой эвристике по _строковому
ключу_ --- уникальному имени эвристики.
Значением эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая запись об эвристике имеет как минимум два значения: _новое_ и _старое_.
Запись привязывается к SHA1-идентификатору изменения в Git-графе
[[$](#ref.Git)] истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.

* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик записью о новом и старом значениях, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей. Хранение обоих значений в каждой записи об эвристике избыточно. Но эта
избыточность используется для проверки непротиворечивости записей.
<!--+ эвристика, ключ эвристики, значение эвристики,
запись об изменении значения эвристики +-->


<!-- интерфейс использования шаблонов, лексическая ошибка (Python),
имя переменной, синтаксическая ошибка (Python), QEMU, марос, параметр шаблона
стиль программирования QEMU, виджет, ВВМ, аббревиатура ГИ -->
# Графический интерфейс пользователя

Все возможности инструмента доступны разработчику посредством интерфейса
использования шаблонов.
Для описания устройств и ВВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с этим
интерфейсом, имеет следующие преимущества.

* Исключены лексические в именах переменных, названиях элементов интерфейса, а
также синтаксические ошибки: разработчик вводит только значения параметров.

* Для многих значений параметров в QEMU определены макросы, использование
которых предпочтительнее, согласно стилю программирования QEMU.
ГИ интерфейс, проанализировав код QEMU, может предоставить разработчику
список доступных макросов, обычно применяемых с данным типом параметра.
Например:

    * идентификатор PCI,
    * имя типа QOM,
    * список свойств выбранного устройства и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как разработчик волен написать всё, что угодно в текстовом редакторе).
Имеется возможность дополнить ГИ средствами поиска менее очевидных
семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ и сопровождаются
названиями на естественном языке.
В большинстве случаев знания QEMU достаточно, чтобы понять суть параметра,
не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.
Эта возможность особенно актуальна при разработке многоэлементных ВВМ с
большим количеством связей, так как на схеме легче ориентироваться, чем в
тексте.

Для реализации ГИ инструмент использует API Tkinter[[$](#ref.Tkinter)].
Данный интерфейс содержит всё необходимую функциональность и прост в
развёртывании, так как включён в дистрибутивы Python.

<!--+ ГИ, Tkinter +-->


<!--- ВМ, ГИ, формат файлов проекта --->
## Схема вычислительной машины

ВМ состоит из множества элементов, которые связаны между собой
различными способами. Схема позволяет разработчику видеть основные
связи в ВМ, не прибегая к интерпретации текстового описания в воображении.

Полезной функцией является экспорт схемы в векторное изображение.
Это экономит значительное количество времени разработчика при
написании отчётной документации. Например, иллюстрации, представленные
в этой статье, получены автоматизированно с использованием данной
функции.
<!--+ схема ВМ +-->


<!--- ГИ, проект, устройство, шина, схема ВВМ, эвристика (общий смысл) --->
## Обратимые операции

Современный ГИ должен предоставлять средства по работе с изменениям.
Минимальный перечень возможностей: _отмена_ и _повторение_.
В разработанном ГИ контроль изменений разработчика реализован с использованием
концепции _обратимых операций_.

Обратимая операция содержит следующую информацию:

* данные, необходимые для осуществления действия;
* данные, необходимые для возврата к состоянию до осуществления действия;
* флаг совершения операции;
* ссылки на предшествующие и последующие операции, позволяющие перемещаться
вдоль истории изменений;
* описание выполняемого операцией действия для разработчика на естественном
языке.

ГИ построен таким способом, что любые изменения в проекте должны
быть осуществлены через абстракцию "_трекер истории_" (`HistoryTracker`).
Для выполнения действия ГИ передаёт трекеру параметры операции.
Трекер создаёт операцию, добавляет её в историю и выполняет.
Многие действия разработчика являются высокоуровневыми и выполняются серией
операцией.
Для выполнения таких действий определены вспомогательные функции, которые
автоматизируют создание серии операций и контролируют корректность
последовательности их выполнения.
Например, нельзя удалить устройство, не отсоединив его от шины.
Если при добавлении устройства сразу присоединять его к ближайшей (на схеме)
шине соответствующего стандарта, то разработчик будет избавлен от
необходимости явного выполнения данной операции.
Это далеко не полный список небольших эвристических автоматизаций, которые
позволяет внедрить специализированный ГИ.

В памяти всегда присутствует состояние проекта, соответствующее перечню
выполненных операций. Поддержание этого соответствия --- задача трекера.
Действия по отмене и повторению операций выполняются с использованием его
методов.
<!--+ обратимая операция, отмена операции, повторение операции,
история операций, трекер истории, серия операций +-->

<!--
Часто сделанная в прошлом операция не связана с операциями, сделанными после
неё. Такая операция может быть отменена без отмены последующих операций.
Формально, в будущем не должно быть операций, _зависящих_ от отменяемой
операции. Операция называется зависящей от _предшествующей_ операции, если
предшествующая операция:
1. изменяет то, что операция потом изменяет повторно;
2. создаёт то, что операция потом использует (для выполнения своего
действия), изменяет или удаляет;
3. удаляет то, что операция потом создаёт.

Операция, изменяющая что-то перед его удалением, здесь считается
независимой относительно удаляющей с тем условием, что при отмене
изменяющей операции будут обновлены данные в удаляющей, т.к., очевидно,
что удаляющая операция содержит в себе последнюю копию утрачиваемых
данных удаляемого объекта.
-->


<!--- проект, виджет, свойство (QOM), ВВМ, элемент ВВМ, дочерняя шина, шина,
устройство, мост, обратный вызов (Python), метод класса (Python),
обратимая операция, трекер --->
## Обратная связь при изменениях

Текущие значения параметров проекта влияют на многое:

* значения, представленные в виджетах;
* выбор типа виджета (тип свойства QOM объекта определяет, какой виджет
должен быть использован для представления его значения);
* существование виджета (при удалении элемента ВВМ должны исчезать
виджеты для его редактирования);
* перечень допустимых значений (выпадающий список выбора дочерней
шины для устройства должен отображать список всех допустимых шин,
имеющихся в ВВМ, и он должен корректироваться при добавлении или
удалении очередной шины);
* формулировка допустимых значений (если был изменён индекс шины
в мосте, все списковые виджеты должны скорректировать текст в
соответствующих строках).

Это не полный перечень зависимостей.
При этом, любое значение может быть изменено _минимум_ двумя способами:

* через соответствующий виджет;
* отменой или повторением правки разработчика.

Для учёта зависимостей в ГИ применяются _события_.
Событие соответствует выполнению или отмене операции.
Генерация событий выполняется трекером истории.
Каждый виджет добавляет свой метод обратного вызова в список
_наблюдателей_ трекера.
При выполнении операции трекер уведомляет всех наблюдателей о выполнении
операции.
Наблюдатель должен определить, относится ли данная операция к нему, и
среагировать соответствующим образом.
<!--+ событие, наблюдатель +-->


<!--- ГИ, стандарт де-факто, событийно-ориентированное программирование,
Python, QEMU, эвристика (QEMU), узел ВВМ, схема ВВМ, процесс, нить
эвристика (общий смысл)  --->
## Сопрограммы и фоновые вычисления

Стандартом _де-факто_ при разработке ГИ является применение
событийно-ориентированного программирования, при котором непозволительно
выполнять вычислительно нагруженные действия при обработке событий, так как это
приводит к ухудшению отзывчивости интерфейса и общему снижению удобства его
использования.

Встраивание длительных вычислений в ГИ принято производить следующими
способами:

* вынос вычислений в отдельный процесс или нить;
* фрагментация (вычисления разбиваются на малые фрагменты, которые
могут быть быстро выполнены при обработке события, и выполняются
в течение обработки специализированных событий).

С целью упрощения разработки выбор был сделан в пользу фрагментации.
Упрощение разработки заключается в следующем:

* исключено состояние гонки, не требуется синхронизация, нет параллельных
ошибок, легче отладка;
* в Python нити выполняются синхронно, причём встроенный
планировщик не различает приоритетных вычислений при обработке событий
ГИ в реальном времени от фоновых вычислений, что приводит к
снижению отзывчивости ГИ;
для реальной параллельности требуется использовать сторонние библиотеки;
* для реализации параллельности требуется больше кода;
* в инструменте отсутствуют _регулярные_ сложные вычисления: достаточно
одного процесса. <!--(нити?) здесь не важен размер контекста, предлагается
использовать более общий термин -->

Для реализации фрагментации удобно использовать _сопрограммы_ --- функции
позволяющие, _сохраняя_ значения локальных переменных, приостановить
своё выполнение на не определённый срок. При возврате управления сопрограмме
она продолжает работу с места, где была приостановлена.

Python, в свою очередь, имеет языковую поддержку так называемых
 _генераторов_ --- сопрограмм способных дополнительно вернуть значение
при очередной остановке управления (инструкцией `yield`).

В ГИ длительные вычисления реализуются генераторами. Долго работающие
функции реализуются как сопрограммы, снабжаясь операторами `yield` через
небольшой интервал вычислений.
Время между сопрограммами распределяется _диспетчером_, который
встраивается в обработку событий ГИ.
Величина интервала между остановками выбирается вручную.
При этом ищется баланс между:

* возрастающим общим временем выполнения сопрограмм за счёт увеличения доли
накладных расходов при уменьшении длины интервала;
* снижением отзывчивости ГИ при увеличении длины интервала с целью
уменьшения доли накладных расходов и ускорения сопрограмм.

ГИ в фоне выполняет следующие задачи:

* анализ исходного кода QEMU;
* предварительное вычисление эвристик о текущей версии QEMU;
* генерация кода;
* уведомления о _сигналах_ --- событиях, не требующих синхронной обработки;
* динамическое размещение узлов на схеме ВММ (эвристика позволяющая
избегать взаимного перекрытия изображений узлов).

<!--+ сопрограмма, генератор (Python), диспетчер сопрограмм, сигнал
дилемма выбора длины интервала сопрограммы, сигнал +-->


<!--- виджет, ГИ, Tkinter, форматная строка (концепция), модуль (Python),
обратимая операция --->
## Динамический текст, интернационализация

При разработке ГИ иногда возникает возможность изменять статический текст в уже
созданных виджетах.
Современные API для разработки ГИ (в том числе и используемый в данном
инструменте Tkinter) имеют необходимый функционал.
Однако способ отличается у разных классов виджетов.
Отображаемый текст может быть результатом подстановки значений в форматную
строку.
Подставляемые значения тоже могут являться результатом подстановки.
В общем случае зависимости формируют ациклический граф.


Для работы с таким текстом в ГИ реализован вспомогательный модуль со
следующими функциями:

* отслеживание зависимостей между строками;
* динамическое обновление производных строк при изменении подставляемых;
* классы-оболочки для библиотечных виджетов, расширяющие перечень параметров,
в качестве которых могут быть использованы динамические строки.

Отслеживание зависимостей основано на уже имеющемся в библиотеке классе
`Variable` (переменная).
Потомки этого класса позволяют работать со строками (`StringVar`), целыми
числами (`IntVar`), дробными числами (`DoubleVar`) и булевыми значениями
(`BoolernVar`).
Класс `Variable` имеет методы `set` и `get` для доступа к значению переменной
и метод `trace_variable`, позволяющий назначить функцию обратного вызова на
изменение переменной.
Для реализации динамически обновляемого форматирования строк были реализованы
следующие классы:

* `FormatedStringVar` --- потомок `StringVar`, соответствующий производной
строке и связывающий её с форматной строкой и параметрами форматирования.
* `FormatVar` --- потомок `StringVar` добавляющий поддержку оператора
форматирования (`%`). Оператор возвращает `FormatedStringVar`.

Форматная строка и её параметры могут быть переменными (потомками `Variable`).
`FormatedStringVar`, используя `trace_variable`, отслеживает их изменения,
переформатирует и обновляет производную строку, используя `set`.
Причём `FormatedStringVar` наследован от `FormatVar`, поэтому производная
строка может быть использована как форматная.

Классы-оболочки для виджетов позволяют использовать `StringVar`
(а следовательно, и `FormatedStringVar`) для ряда текстовых параметров.
Они используют `trace_variable` для реакции на изменение переменных.
В проекте повсеместно используются виджеты классов-оболочек.
Это упрощает реализацию следующего функционала:

* динамическое изменение языка интерфейса, в том числе и при использовании
интернационализированной строки в качестве форматной;
* обновление подсказок о клавишах быстрого доступа;
* обновление текстов, зависящих от значений параметров проекта.

Распространённым способом интернационализации интерфейса является
составление базы соответствия между текстом, использованным непосредственно,
и переводом этого текста на каждый поддерживаемый язык. Стандартом _де-факто_
является применение библиотеки `gettext` (или её аналога для соответствующего
языка). Она работает именно таким образом. Для перевода текстов в данном
инструменте используется её оболочка для языка Python. Многие приложения
используют функционал `gettext` для перевода текстов непосредственно при
создании виджетов. При этом изменение языка требует перезагрузки ГИ после
изменения выбранной локализации. Применение динамических строк в ГИ данного
инструмента исключает эту необходимость.
<!--+  Variable, StringVar, IntVar, DoubleVar, FormatedStringVar,
FormatVar +-->


<!--- интерфейсная часть, шаблон --->
# Примеры заготовок

Основой генерации кода интерфейсной части моделей являются шаблоны.
В настоящее время инструмент поддерживает генерацию заготовок для
машин, устройств системной шины и шины PCI.
А также для наиболее часто используемых программных интерфейсов QEMU.

Далее приводятся примеры заготовок кода, возвращаемых разработанным
инструментом.
Для повышения изобразительности заготовки при подготовке текста работы снабжены
комментариями, которые на самом деле не генерируются.
Такие комментарии только многострочные и начинаются с двух звёздочек
(`/** **/`) вместо одной, необходимой по синтаксису.
В целях экономии места повторяющиеся фрагменты кода заменены их названием в
комментариях следующего вида: `/** -= заменённый фрагмент =- **/`.
Все остальные комментарии следует считать генерируемыми инструментом.

Во многих примерах не приведены директивы `include`.
Это сделано для экономии места.
Стоит отметить, что для реальной модели ВМ количество заголовков
с учётом реализованной оптимизации достигает нескольких десятков.
Это в первую очередь связано с тем, что почти каждое устройство имеет свой
заголовок.
<!--+ оформление листингов +-->


<!--- оформление листингов, функция инициализации, конструктор класса,
конструктор экземпляра, устройство, ВВМ, тип (QOM), тип-родитель (QOM),
конструктор модуля (Си), макрос --->
## Вычислительная машина

Следующий код определяет минимальную ВВМ.

```c
/** Пустая функция инициализации машины (её не следует путать с конструктором
экземпляра). В этой функции должно происходить создание и связывание
устройств. **/
static void init_q35_test(MachineState* machine) {}

/** Конструктор класса. Он определяет имя машины и описание, а также
регистрирует функцию инициализации. **/
static void machine_q35_test_class_init(ObjectClass* oc, void* opaque)
{
    MachineClass *mc = MACHINE_CLASS(oc);

    mc->name = "q35_test";
    /** Описание генерируется равным имени. Это технически верно, но
    разработчику следует вручную его изменить. Например так:
    "Test implementation of Q35 chipset". **/
    mc->desc = "q35_test";
    mc->init = init_q35_test;
}

/** Описание нового типа. Для машины требуется минимум информации: имя нового
типа, имя родительского типа и конструктор класса. **/
static TypeInfo machine_type_q35_test = {
    /** TYPE_MACHINE_SUFFIX - обязательный суффикс для имён типов машин **/
    .name = "q35_test" TYPE_MACHINE_SUFFIX,
    .parent = TYPE_MACHINE,
    .class_init = machine_q35_test_class_init
};

/** Обеспечивает регистрацию описания нового типа в QOM. **/
static void machine_init_q35_test(void)
{
    type_register(&machine_type_q35_test);
}

/** Макрос, раскрывающийся в конструктор модуля согласно синтаксису компилятора.
Конструктор обеспечивает вызов machine_init_q35_test. **/
type_init(machine_init_q35_test)
```
<!--+ пример заготовки ВМ +-->


<!--- конструктор экземпляра, адресация GPIO --->
## Входящие GPIO и прерывания

Реализация входящего GPIO (в том числе прерывания) требует:

* функции обработчика;
* регистрации входящего GPIO в конструкторе экземпляра.

Пример заготовки для организации входящих безымянных GPIO приведён ниже.

```c
/** Обработчик входящего прерывания. **/
static void a20_line_irq_handler(void* opaque, int n, int level)
{
    /** Аттрибут unused добавляется для обхода ошибок компиляции. В QEMU
    наличие неиспользованной переменной считается ошибкой компиляции. Когда
    разработчик реализует логику этой функции, переменная скорее всего будет
    использована, и этот атрибут должен быть удалён вручную. **/
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
}

static void a20_line_instance_init(Object* obj)
{
    /** -= другой код =- **/
    /** При регистрации обработчика указывается количество входящих прерываний.
    Макрос A20_LINE_IN_IRQ_NUM, определяющий их количество, определен в
    заголовке устройства. **/
    qdev_init_gpio_in(DEVICE(obj), a20_line_irq_handler, A20_LINE_IN_IRQ_NUM);
    /** -= другой код =- **/
}
```
<!--+ пример GPIO, применение атрибута unused +-->


<!--- устройства системной шины, заголовок (Си), модель (Си), ВВМ, тип QOM --->
## Устройства системной шины

Модель устройства системной шины состоит из заголовочного файла и файла модуля.
Пример заготовки модели системного устройства приведён ниже.
<!--+ файлы устройства системной шины +-->


<!--- оформление листингов, файлы устройства системной шины --->
### Заголовок устройства системной шины
Заголовок устройства обеспечивает доступность модели остальному коду QEMU и,
в особенности, использующим его ВВМ.
```c
#ifndef INCLUDE_IO_PORT_80_H /* Защита от двойного включения заголовка. */
#define INCLUDE_IO_PORT_80_H
/** В sysbus.h опредлена структура SysBusDevice, используемая при определении
   структуры объекта нового типа. **/
#include "hw/sysbus.h"

/** Макрос, используемый для динамического приведения типов QOM. **/
#define IO_PORT_80(obj) OBJECT_CHECK(IOPort80State, (obj), TYPE_IO_PORT_80)
/** Макроподстановка идентификатора модели устройства. **/
#define TYPE_IO_PORT_80 "io_port_80"
typedef struct _IOPort80State {
    /** Структура объекта родительского класса всегда первая. **/
    SysBusDevice parent_obj;
    /** -= другие поля =- **/
} IOPort80State;

#endif /* INCLUDE_IO_PORT_80_H */
```
<!--+ пример заголовка устройства системной шины +-->


<!--- оформление листингов, файлы устройства системной шины,
применение атрибута unused --->
### Модуль устройства системной шины
Модуль содержит реализацию устройства.
```c
/** Конструктор экземпляра. **/
static void io_port_80_instance_init(Object* obj)
{
    /** В данном случае переменная s не используется, поэтому ей присвоен
    атрибут unused. Но использование других шаблонов совместно с этим приводит
    к наполнению этой функции кодом, использующим s. В этом случае атрибут
    не генерируется. **/
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(obj);
}

static void io_port_80_realize(DeviceState* dev, Error** errp)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

/** Функция предусматривает сброс устройства в начальное состояние.
Например, при перезагрузке ВМ. **/
static void io_port_80_reset(DeviceState* dev)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

static void io_port_80_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);

    dc->realize = io_port_80_realize;
    dc->reset   = io_port_80_reset;
}

static TypeInfo io_port_80_info = {
    .name          = TYPE_IO_PORT_80,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(IOPort80State),
    .instance_init = io_port_80_instance_init,
    .class_init    = io_port_80_class_init
};

static void io_port_80_register_types(void)
{
    type_register_static(&io_port_80_info);
}

type_init(io_port_80_register_types)
```

Такая заготовка может быть скомпилирована и создана при инициализации ВМ, но
она не будет никак себя проявлять в машине. Любое реальное устройство
может иметь регистры, исходящее и/или входящее прерывание.
Примеры кода, добавляющие такую функциональность приведены ниже.
<!--+ пример модуля устройства системной шины +-->


<!--- структура экземпляра, конструктор экземпляра, участок памяти IO,
MMIO, PMIO, IBM PC, ЭВМ, PIO, применение атрибута unused,
оформление листингов --->
### MMIO и PMIO

MMIO и PMIO являются регистрами устройств системной шины.
Причём PMIO --- это явление специфичное только для системной шины IBM PC
совместимых ЭВМ.
Оно также известно как PIO.
Эти и другие виды регистров реализуются как участки памяти типа IO.
Заготовка регистра устройства состоит из:

* обработчика чтения;
* обработчика записи;
* описателя параметров регистра;
* описателя самого регистр в структуре экземпляра;
* регистрации регистра в конструкторе экземпляра.

В данном примере описателем регистра в структуре экземпляра является
поле `mmio`.
Сама структура не приведена для экономии места.
```c
/** Пара функций: обработчики записи в регистр устройства и чтения. **/
static void a20_line_mmio_write(void* opaque, hwaddr addr, uint64_t data, \
    unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);

    switch (addr) {
    /** Для удобства отладки шаблон предусматривает только генерацию сообщения
    об обращении к нереализованному регистру. Реализация регистров заключается
    в добавлении `сase` блоков для обработки доступа к соответствующим смещениям
    регистров относительно условного стартового адреса. То есть одна пара
    функций может реализовывать сразу несколько регистров. Обычно за условный
    стартовый адрес принимают адрес регистра с наименьшим смещением. **/
    default:
        printf("%s: unimplemented write to 0x%"HWADDR_PRIx", size %d, "
                "value 0x%"PRIx64"\n", __FUNCTION__, addr, size, data);
        break;
    }
}

static uint64_t a20_line_mmio_read(void* opaque, hwaddr addr, unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
    /** Функция чтения будет что-то возвращать: сразу добавим для этого
    значения переменную. **/
    uint64_t ret = 0;

    switch (addr) {
    default:
        printf("%s: unimplemented read from 0x%"HWADDR_PRIx", size %d\n",
            __FUNCTION__, addr, size);
        break;
    }

    return ret;
}

/** Параметры регистра группируются в специальную структуру: описатель
параметров регистра. Он же --- описатель участка памяти типа IO. **/
static MemoryRegionOps a20_line_mmio_ops = {
    .read = a20_line_mmio_read,
    .write = a20_line_mmio_write
};

static void a20_line_instance_init(Object* obj)
{
    A20LineState *s = A20_LINE(obj);
    /** -= другой код =- **/
    /** Инициализация участка памяти, соответствующего регистру. **/
    memory_region_init_io(&s->mmio, obj, &a20_line_mmio_ops, s, TYPE_A20_LINE, \
        A20_LINE_MMIO_SIZE);
    /** Регистрация данного участка памяти именно как MMIO регистр. **/
    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);
    /** -= другой код =- **/
}
```

Добавление PMIO-регистров к заготовке устройства
отличается от добавления MMIO-регистров только способом регистрации.
Пример регистрации PMIO приведён ниже.

```c
static void io_port_80_instance_init(Object* obj)
{
    /** -= другой код =- **/
    memory_region_init_io(&s->pio, obj, &io_port_80_pio_ops, s, \
        TYPE_IO_PORT_80, IO_PORT_80_PIO_SIZE);
    /** Основное отличие MMIO и PMIO регистров системной шины IBM PC
    совместимых ВМ заключается в строчке ниже. **/
    sysbus_add_io(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, &s->pio);
    /** Данный код привязывает отображение к конкретному адресу. В общем случае,
    привязка возлагается на функцию инициализации ВМ. Но, по стандарту LPC,
    устройства не должны поддерживать произвольное указание адреса. Протокол
    шины таков, что только по ответу устройства можно установить его присутствие
    в системе. На какие адреса отвечать решает разработчик устройства. **/
    sysbus_init_ioports(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, \
        IO_PORT_80_PIO_SIZE);
    /** -= другой код =- **/
}
```
<!--+ примеры заготовок MMIO и PMIO регистров +-->


<!--- qemu_irq, структура экземпляра, конструктор экземпляра,
пример модуля устройства системной шины --->
### Исходящие прерывания

Заготовка устройства системной шины для каждого исходящего прерывания
имеет поле `qemu_irq` в структуре экземпляра. Объявления исходящего прерывания
происходит в конструкторе экземпляра следующим образом.

```c
static void io_port_f0_instance_init(Object* obj)
{
    IOPortF0State *s = IO_PORT_F0(obj);
    /** -= другой код =- **/
    /** Регистрация одного исходящего прерывания, соответствующего полю out_irq.
    В случае регистрации нескольких прерываний важен порядок, так как
    используется неявная нумерация. **/
    sysbus_init_irq(SYS_BUS_DEVICE(obj), &s->out_irq);
    /** -= другой код =- **/
}
```
<!--+ пример заготовки исходящего прерывания устройства системной шины +-->


<!--- PCI, функция PCI-устройства, QEMU, BAR (PCI), MSI (PCI), макрос --->
## PCI

PCI-устройство в QEMU соответствует одной _функции_ реального PCI-устройства.
Функция представлена:

* конфигурационным пространством, где, среди прочего, содержится
идентификационная информация PCI;
* перемещаемыми регистрами (BAR), отображаемыми на адресное пространство PCI;
* сигнальными прерываниями (INTx) и логическими прерываниями (MSI).
<!--+ PCI-устройство в QEMU +-->


<!--- PCI-устройство в QEMU, оформление листингов, конструктор экземпляра,
конструктор класса --->
### Идентификация

Конфигурационное пространство функции PCI является обязательным базовым
интерфейсом взаимодействия ПО с устройством.
Опрашивая регистры конфигурационного пространства с
_идентификационной информацией_, драйвер опознаёт соответствующее устройство,
и, используя другие регистры, осуществляет предварительную настройку.
В конфигурационном пространстве также содержится множество другой информации,
в том числе и меняющейся во время работы.

Чтобы обеспечить видимость присутствия PCI-устройства в системе достаточно
следующей заготовки.

```c
/** -= конструктор объекта =- **/

/** Базовый класс PCI-устройств перегружает методы realize и unrealize,
реализуя в них общую функциональность. PCI-функции должны перегружать
другую пару соответствующих методов: realize (несмотря на схожесть имён, это
разные методы) и exit, для добавления дополнительной логики. **/
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static void test_pci_card_exit(PCIDevice* dev)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        /** Всякая PCI-функция должна добавить к своему состоянию поле,
        соответствующее структуре экземпляра родительского класса - PCIDevice,
        так как в ней содержится состояние конфигурационного пространства. **/
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    /** Важно, что методы realize и exit перегружаются в PCIDeviceClass,
    а не в DeviceClass. **/
    pc->realize   = test_pci_card_realize;
    pc->exit      = test_pci_card_exit;
    dc->vmsd      = &vmstate_test_pci_card;
    /** Последующие поля определяют идентификационную информацию об устройстве.
    Они не являются непосредственной частью конфигурационного пространства, но
    на основании их значений конструктор экземпляра базового класса PCI
    автоматически заполнит соответствующие регистры. **/
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    pc->device_id = PCI_DEVICE_ID_AMD_SCSI;
    pc->class_id  = PCI_CLASS_STORAGE_SCSI;
    pc->revision  = 0;
}

static TypeInfo test_pci_card_info = {
    .name          = TYPE_TEST_PCI_CARD,
    .parent        = TYPE_PCI_DEVICE,
    /** -= указание конструкторов и размера структуры экземпляра =- **/
};
/** -= код регистрации типа =- **/
```
<!--+ пример заготовки PCI-функции +-->

<!--- пример заготовки PCI-функции, PCI-идентификатор, макрос,
заголовок (Си), ГИ, виджет --->
Значения идентифицирующих констант задаются с помощью макросов, которые
определены в заголовке `pci_ids.h`.
В инструменте реализован анализ заголовков с целью получения базы данных
макросов PCI-идентификаторов, которая используется для подсказки разработчику.
В ГИ реализован специальный виджет, позволяющий выбирать идентификатор из
списка.
Добавление собственных идентификаторов пока не реализовано и является
направлением дальнейших исследований.
<!--+ автоматизация указания PCI-идентификации +-->


<!--- пример заготовки PCI-функции, оформление листингов,
пример заготовки MMIO и PMIO, участок памяти типа IO, структура экземпляра --->
### BAR

Перемещаемые регистры реализуются таким же образом, как и MMIO (PMIO) регистры.
Принципиальное отличие заключается в способе регистрации.
Причём от разработчика устройства требуется только зарегистрировать
BAR-отображение.
Управление перемещаемыми регистрами осуществляется через конфигурационное
пространство.
Соответствующая логика реализуется базовым классом PCI-устройств.

```c
/** -= обработчики доступа к участку IO =- **/

static MemoryRegionOps test_pci_card_mem_bar_ops = {
/** -= регистрация обработчиков доступа и других параметров участка IO =- **/
};

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    TestPCIcardState *s = TEST_PCI_CARD(dev);
    /** -= инициализация участка памяти (поля в структуре экземпляра) =- **/
    /** Регистрация участка как BAR. **/
    pci_register_bar(&s->parent_obj, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, \
        &s->mem_bar);
    /** -= другой код =- **/
}
```
<!--+ пример заготовки BAR +-->


<!--- PCI, MSI-X, QEMU, материнская плата (часть ЭВМ),
дорожка (печатная плата) --->
### Прерывания INTx и MSI

На шине PCI существует ряд способов передачи прерываний. В работе
рассматриваются:

* сигнальная: по выделенным на шине дорожкам (INTx),
* логическая: с помощью сообщений (MSI).

При сигнальной передаче используется выделенные на материнской плате физические
дорожки (их обычно 4), к которым могут иметь доступ устройства на шине.
В конфигурационном пространстве предусмотрен регистр, через который можно
сообщить устройству, какую дорожку ему следует использовать.
Устройства в данном случае часто предсказуемы: они честно используют
указанную дорожку.
Модель PCI-устройств в QEMU имеет вспомогательные функции для этого.
Поведение остальных участников распространения прерываний сильно отличается от
платформы к платформе:

* может быть разное количество физических дорожек;
* дорожки могут быть разведены к разным контактам на разных разъёмах.

Количество дорожек и способ передачи прерываний за пределы шины определяется
контроллером.
Также предусмотрена возможность настройки отображения контактов на физические
дорожки.
Чтобы пользоваться сигнальными прерываниями от модели устройства не требуется
инициализации.
Подача прерывания выполняется одной функцией.
То есть для поддержки сигнальных прерываний не требуются шаблоны.

Сигнальные прерывания имеют ряд недостатков.
По этой причине были введены прерывания основанные на пересылке сообщений (MSI).
Впоследствии было увеличено количество сообщений, доступных устройству (MSI-X).
Пересылка сообщения есть запись по настраиваемому адресу.
Часто адрес соответствует специализированному регистру в контроллере прерываний.
Благодаря этому контроллер максимально быстро оповещается о прерывании.
<!--+ виды прерываний PCI +-->

<!--- пример заготовки PCI-функции, оформление листингов,
виды прерываний PCI --->
Наличие прерываний MSI --- особенность конкретного устройства.
О наличии свидетельствуют стандартные регистры в конфигурационном пространстве,
которые должны быть соответствующим образом настроены при создании экземпляра
устройства в эмуляторе.
Инструмент позволяет сгенерировать соответствующую заготовку.

```c
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /** -= другой код =- **/
    /** Инициализация MSI. **/
    msi_init(dev, TEST_PCI_CARD_MSI_CAP_OFFSET, TEST_PCI_CARD_MSI_VECTORS, \
        TEST_PCI_CARD_MSI_64BIT, TEST_PCI_CARD_MSI_VECTOR_MASKING);
    /** -= другой код =- **/
}

static void test_pci_card_exit(PCIDevice* dev)
{
    /** -= другой код =- **/
    msi_uninit(dev); /** Отмена инициализации MSI. **/
    /** -= другой код =- **/
}
```

При инициализации MSI требуется указать:

* смещение регистров в конфигурационном пространстве;
* количество векторов (значение должно быть степенью 2 в интервале [1, 32]);
* количество бит в адресе для записи сообщения (64 или 32);
* допустимость маскирования (отключения) сообщений.

Инструмент создаёт в заголовочном файле устройства макросы с
со значениями этих параметров и использует их в коде инициализации.
<!--+ пример заготовки INTx и MSI (PCI) +-->


<!--- оформление листингов, структуру экземпляра, УАПП, ВМ, прерывания --->
## Таймеры

Таймеры используются для отсрочки действия относительно времени ВМ или времени
основной машины.
С их помощью можно ограничить пропускную способность УАПП, реализовать
периодические прерывания и т.п.
Добавление заготовки таймера, помимо добавления поля структуру экземпляра,
включает следующий код.

```c
/** Функция, вызываемая по истечение времени таймера. **/
static void io_port_80_timer_cb(void* opaque)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(opaque);
}

static void io_port_80_instance_init(Object* obj)
{
    IOPort80State *s = IO_PORT_80(obj);
    /** -= другой код =- */
    /** Создание таймера. **/
    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, io_port_80_timer_cb, s);
}
```

Кроме этого таймер имеет часть состояния, которое должно быть сохранено в
снимке ВМ.
Генерация соответствующего кода рассматривается ниже.
<!--+ таймеры в QEMU, пример заготовки таймера +-->


<!--- состояние устройства, оформление листингов --->
## Состояние устройства

Любое устройство должно зарегистрировать в эмуляторе своё состояние.
Для этого оно инициализирует и регистрирует специальную структуру.
Пример регистрации состояния устройства приведён ниже.

```c
static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        /** Некоторые элемента API QEMU могут иметь состояние и соответствующие
        поля должны быть зарегистрированы. Например, таймеры. **/
        VMSTATE_TIMER_PTR(timer_0, TestPCIcardState),
        VMSTATE_TIMER_PTR(timer_1, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    /** -= другой код =- **/
    /** Регистрация описателя состояния в статической переменной класса. **/
    dc->vmsd      = &vmstate_test_pci_card;
    /** Большой пробел перед `=` является следствием выравнивания всех
       присваиваний. В данном случае по следующему коду. **/
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    /** -= другой код =- **/
}
```

Данный пример демонстрирует тесную связь между разными шаблонами. В частности,
добавление заготовки таймера к устройству также затрагивает заготовку
состояния устройства.
<!--+ пример заготовки состояния устройства +-->


<!--- оформление листингов, УАПП, QEMU, TCP, инкапсуляция? (модель OSI),
свойство устройства --->
## Символьные устройства

Абстракция "символьное устройство" в QEMU применяется для унификации
поточного ввода/вывода.
Распространённый пример: последовательный порт УАПП, который может быть
подключён к виртуальному терминалу, инкапсулирован в TCP соединение,
выведен в файл и мн.др.
Такая гибкость достигается использованием этой абстракции.
Для символьного устройства инструмент позволяет возвращает следующую заготовку.

```c
/** Вызывается для чтения size байт, начиная с адреса buf. **/
static void test_pci_card_chr_read(void* opaque, const uint8_t* buf, int size)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

/** Опрос устройства о количестве байт, которые оно готово принять. **/
static int test_pci_card_chr_can_read(void* opaque)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);

    return 0; /** Устройство ещё не реализовано и принимать не может. **/
}

/** Уведомление устройства о событии, произошедшем в канале. **/
static void test_pci_card_chr_event(void* opaque, int event)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /** -= другой код =- **/
    /** Наличие назначенного символьного устройства не обязательно. Устройство
    должно уметь корректно работать без него. **/
    if (s->chr) {
        /** Регистрация обработчиков. **/
        qemu_chr_add_handlers(s->chr, test_pci_card_chr_can_read, \
            test_pci_card_chr_read, test_pci_card_chr_event, s);
    }
    /** -= другой код =- **/
}
```

В примере не приведены добавление поля `chr` (описатель символьного устройства)
в структуру экземпляра и регистрация этого поля как _свойства_.
Последнее рассматривается ниже.
<!--+ пример заготовки символьного устройства, символьное устройство (QEMU) +-->


<!--- оформление листингов, ПЗУ, структура экземпляра, индивидуальная часть,
функция реализации устройства, свойство устройства --->
## Блочные устройства

Блочные устройства применяются для упрощения реализации ПЗУ.
Поддерживается доступ к блокам байт по произвольному адресу.
При этом применяется асинхронное выполнение (в отдельной нити) операций
ввода/вывода применительно к содержащему данные ПЗУ _файлу-образу_,
находящемуся в файловой системе основной ВМ.
Также абстракция "блочное устройство" поддерживает нетривиальные форматы
хранения файлов-образов, предоставляя разработчику ПЗУ унифицированный API.

Для добавления блочного устройства к заготовке устройства генерируется
следующий код.

```c
/** Структура экземпляра. **/
typedef struct _TestPCIcardState {
    /** -= другие поля =- **/
    BlockBackend *blk; /** Ссылка на описатель блочного устройства. **/
} TestPCIcardState;

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /** -= другой код =- **/
    if (s->blk) {
        /** Наличие назначенного блочного устройства не обязательно.
        Даже способ инициализации блочного устройства уже относится к
        индивидуальной части устройства. Всё что можно сделать: добавить блок
        проверки в функцию реализации устройства. **/
        /* TODO: Implement interaction with block driver. */
    }
    /** -= другой код =- **/
}
```

Помимо этого кода, поле `blk` (описатель блочного устройства) регистрируется
как свойство.
Это описано ниже.
<!--+ пример заготовки блочного устройства, блочное устройства QEMU,
файл-образ ПЗУ +-->


<!--- свойство устройства, оформление листингов, API QEMU,
конструктор экземпляра, конструктор класса, блочное устройства (QEMU),
символьное устройство (QEMU), пример заготовки состояния устройства --->
## Свойства устройств

Свойства используются для начальной настройки устройства во время его
создания в ВМ.
Модель устройства должна объявить свои свойства в конструкторе экземпляра.
Использование некоторых API QEMU подразумевает добавление свойств для
настройки использования этих API.
Например, для блочного или символьного устройств через свойства настраивается
подключение к внешней среде.
Ниже приведён пример определения свойств устройства.

```c
/** Этот массив определяет два свойства устройства: символьное и блочное
устройства. Макросы TEST_PCI_CARD_CHR и TEST_PCI_CARD_DRIVE раскрываются
в имена свойств. Они сгенерированы в заголовочном файле устройства. **/
static Property test_pci_card_properties[] = {
    DEFINE_PROP_CHR(TEST_PCI_CARD_CHR, TestPCIcardState, chr),
    DEFINE_PROP_DRIVE(TEST_PCI_CARD_DRIVE, TestPCIcardState, blk),
    DEFINE_PROP_END_OF_LIST()
};

/** Конструктор класса **/
static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    /** -= другой код =- */
    /** Регистрация перечня свойств затрагивает шаблон конструктора касса. **/
    dc->props     = test_pci_card_properties;
    /** -= другой код =- **/
}
```
Этот пример, аналогично примеру регистрации состояния устройства,
демонстрирует сложную взаимосвязь различных шаблонов.
<!--+ пример заготовки свойств устройства +-->


# Автоматизированная разработка моделей устройств и машин

Разработка моделей устройств и ВМ --- это два разных вида процессов.
Однако процесс разработки модели ВМ часто проходит одновременно и
взаимосвязанно с процессами разработки устройств, входящих в эту машину.
Далее эти процессы рассматриваются подробно с акцентом на применение
инструмента автоматизации, разработанного в рамках данной работы.

## Процесс разработки модели устройства

Общее время затрачиваемое на создание модели устройства
в течение автоматизированного подхода
складывается из этапов: _ознакомления_ с информацией об устройстве,
_подготовке_ инфраструктуры эмулятора к добавлению модели, _генерации_
заготовки и _реализации_.

### Ознакомление с имеющейся информацией об устройстве

На этом этапе разработчик должен получить следующую информацию.

*   тип шины, на которую подключается устройство (в данной работе
    подразумеваются только системная шина и PCI);
*   перечень внешних интерфейсов, через которые устройство взаимодействует
    с внешним миром, например:

    *   поточный (символьный или байтовый) канал;
    *   носитель информации, допускающий доступ к произвольным адресам;
    *   сетевой интерфейс; и др.;

*   перечень периодических событий в логике работы;
*   количество входящих и исходящих прерываний;
*   количество групп регистров для чтения и/или записи;
*   значения идентификаторов (для PCI);
*   имя нового типа QOM для этого устройства;
*   имя папки в QEMU, соответствующей семантике устройства.

### Подготовка эмулятора

Почти весь код модели может быть написан на этапе реализации. Однако, ввиду
того что инструмент получает часть информации из кода QEMU в процессе генерации,
соответствующие изменения нужно произвести заранее.
В настоящее время инструмент анализирует код QEMU не глубже уровня
препроцессора.
Поэтому на этапе подготовки нужно вносить изменения, влияющие на состав
заголовков и связи между ними.
Например, добавление идентификаторов PCI для добавляемого устройств.

### Генерация заготовки для устройства

В течение этого этапа разработчик должен
создать компилируемый код, учитывающий полученную на предыдущем этапе
информацию. При наличии возможности, следует внедрить устройство в ВМ, и,
запустив гостевое ПО, удостовериться, что оно пытается взаимодействовать с
устройством. Сбои и отказы в работе ПО ожидаемы, так устройство не
реализовано. Однако сбои и отказы в работе самого эмулятора свидетельствуют
об ошибках программиста, допущенных в течение предыдущей работы. Они должны
быть решены до перехода на следующий этап.

Разработанный инструмент ориентирован на автоматизацию этого этапа.
Использование инструмента состоит в выполнении следующих действий.

*   внесение информации с предыдущего этапа в настройки генерации;
*   генерация кода;
*   тестирование сгенерированного кода и возможная корректировка
    инструмента.

При обнаружении ошибок, вызванных несоответствием инструмента и QEMU,
разработчик должен идентифицировать изменения, произошедшие в QEMU, и
внести их в набор эвристик. Необходимость добавления эвристик в инструмент
смягчается их перманентностью: каждую корректировку нужно внести
однократно.

### Реализация индивидуальной части устройства.

Этот этап выполняется _итеративно_. Одна итерация включает:

*   реализация _части_ логики устройства;
*   тестирование реализованной части вплоть до исправления основных ошибок;

Размер части которую нужно реализовать за одну итерацию должен быть
выбран разработчиком по своему усмотрению. Часто для исправления всех
ошибок требуется реализовать оставшиеся части. Такие ошибки можно
отложить на последующие итерации, но соответствующие части нужно
реализовывать в первую очередь.

При тестировании на каждой итерации важную роль играет качество тестового
ПО. Вопрос, касающиеся тестового ПО, выходят за рамки настоящей работы.
Однако стоит перечислить средства, имеющиеся в QEMU.

*   GDB-сервер, реализующий протокол remote GDB для контроля гостевого ПО.
    Он позволяет проверять поведение устройства с точки зрения тестового ПО.
*   Можно использовать отладчик применительно к самому эмулятору. Но
    возможны проблемы с задержками в протоколе GDB, если необходимо
    одновременно контролировать и эмулятор, и гостевое ПО.

С версии 2.8 в QEMU была добавлена технология детерминированного
воспроизведения [[$](#ref.DetReplay)]. Выбранный подход к
реализации этой технологии требует от
разработчика устройства внимания к тому, что его устройство функционирует
детерминировано в рамках данного подхода. Подробное рассмотрение
правил, которых должен придерживаться разработчик, выходит за рамки данной
работы. Так или иначе, на каждой итерации следует хотя бы раз
воспользоваться технологией и убедиться в отсутствии расхождений при
воспроизведении.
Кроме того, отладка детерминированной модели принципиально легче.

Этот этап, в идеале, не заканчивается никогда. Практически, устройство
можно считать реализованным, когда в нём перестают проявляться ошибки
влияющие на работу _интересующего_ ПО. Опыт показывает, что глубина
проработки модели непосредственно определяется производственными нуждами и
экономической целесообразностью повышения качества модели.
Хорошим показателем является принятие модели устройства сообществом
разработчиков QEMU.

## Процесс разработки ВВМ

Разработка ВВМ включает разработку недостающих моделей устройств.
В особо сложном случае требуется разработка поддержки архитектуры процессора.
Исследование подходов к автоматизации этого случая является направлением
дальнейших исследований. Это выходит за рамки данной работы.

Разработка модели ВВМ состоит из таких же этапов, что и разработка устройства.
Более того, при совместной разработке в рамках предлагаемого подхода этап
генерации совпадает по времени у ВВМ и всех новых устройств.

### Ознакомление с имеющейся информацией о платформе

На этом этапе нужно получить следующую информацию.

* Перечень устройств. Для каждого устройства важно понять, имеется ли в QEMU
его реализация. Наличие аналога следует рассматривать как отсутствие самого
устройства с той разницей, что разработка этого устройства будет ускорена.

* Перечень шин. Эта информация может быть получена на основе анализа
устройств, являющихся мостами между разными шинами. Наличие в платформе
шины, не реализованной в QEMU значительно усложняет разработку, т.к. придётся
разрабатывать эмуляцию такой шины. Автоматизация создания нового типа шины
является направлением дальнейших исследований и выходит за рамки данной работы.

* Распределение устройств по шинам. К этой информации также относятся адреса,
которые имеют устройства на своих шинах.

* Перечень линий прерываний и прочей сигнализации, выходящей за пределы той,
что уже реализована в шине. В большинстве случаев это касается только
прерываний между устройствами системной шины, т.к. она не инкапсулирует этот
механизм.

* Перечень внешних интерфейсов. Сюда относятся порты сетевых адаптеров, УАПП и
носители для ПЗУ.

### Генерация заготовок недостающих устройств и ВВМ

Имея полный перечень устройств (или их заготовок) можно получить
заготовку ВВМ.
Разработанный инструмент позволяет выполнить большую часть этого этапа с
использованием схематичного представления ВВМ.
Используя информацию, полученную на этапе ознакомления, нужно сгенерировать
функцию инициализации машины QEMU, указав на схеме все элементы (устройства,
шины и внешние интерфейсы) и связи между ними.
Разумеется, в настройки генерации нужно добавить и все новые устройства.

Корректность функции инициализации будет проверяться в течение разработки
всех устройств (выполнения этапа реализации). В случае обнаружения ошибок
в схеме ВВМ, их нужно исправлять уже непосредственно в сгенерированном коде,
поскольку инструмент не поддерживает обратную связь.
Для сокращения количества таких ошибок рекомендуется внимательней выполнять
этап ознакомления.

### Реализация ВВМ

Инструмент генерирует функцию инициализации машины и интерфейсный код.
От разработчика требуется:

* уточнение интеграции процессора (т.к. процессоры часто имеют очень
нетривиальный механизм инициализации);
* связывание CLI со свойствами устройств (ПЗУ, ОЗУ, периферийные интерфейсы и
пр.);
* реализация прочей индивидуальной логики.

# Экспериментальные результаты

Для проверки состоятельности предложенного подхода с помощью разработанного
инструмента были реализованы две ВВМ:

* IBM PC совместимая машина "Q35" на базе одноимённого набора микроконтроллеров
фирмы Intel;
* криптомаршрутизатор СISCO серии 2600 (C2621XM).

В качестве основной метрики эффективности автоматизации было выбрано количество
строк.
Подсчёты производились по истории Git и сгруппированы поэтапно.
Замеры производились по разнице между начальной и конечной версией каждого
этапа.
Кроме этого для каждой ВВМ приведена суммарная разница между базовой версией
QEMU и полностью реализованной машиной.
Важно иметь ввиду, что в приведённой ниже статистике изменение одной строки
представлено как 1 удаление и 1 добавление.
Такова особенность Git.

## Q35

За основу Q35 была взята её реализация, уже имеющаяся в QEMU версии 2.9.5.
Целью данного эксперимента была проверка возможностей разработанного
инструмента.
Выбор Q35 обусловлен тем, что эта машина является одной из самых сложных машин,
реализованных в QEMU.

В ходе анализа исходного кода реализации Q35 был составлен перечень устройств и
выявлена их взаимосвязь.
Эти данные были формально описаны средствами разработанного инструмента.
Полученная схема ВМ представлена на рисунке [$](#pic.Q35).

![Рисунок <a name="pic.Q35">$</a> --- Схема ВМ Q35](Q35.png)

Поскольку реализация Q35 не полностью соответствует всем требованиям QEMU,
потребовался подготовительный этап.
На этапе подготовки в QEMU вносились изменения, которые могут ограничить
возможности инструмента:

* в заголовочный файл вынесена структура, описывающая устройство MC146818 RTC
и макрос динамического приведения к типу данного устройства;
* добавлены функции инициализации глобальных переменных `slave_pic` и `isa_pic`,
в которые записываются ссылки на два устройства "i8259".

На этапе генерации с помощью инструмента были сгенерированы заготовки ВВМ Q35 и
трёх устройств, входящих в её состав: "A20 line", "port 80" и "port F0".
В оригинальной ВВМ Q35 эти устройства реализованы в коде самой машины.

На этапе реализации в заготовку ВВМ были внесены следующие изменения:

* добавлен процессор;
* добавлена настройка BIOS;
* добавлен режим совместимости MSDOS с исключениями FPU;
* выделена память под eeprom;
* добавлены к машине свойства, хранящие указатели на объекты устройств
IOAPIC и PCI HOST;
* произведена инициализация ICH9 PM;
* произведена инициализация IDE;
* произведена инициализация PC CMOS;
* произведена инициализация VGA;
* произведена инициализация NIC;
* произведена инициализация ACPI;
* скорректированы имена переменных.

Необходимость инициализации некоторых устройств на этапе реализации
связана с тем, что эти устройства поддерживают настройку посредством CLI.

В таблице [$](#tbl.Q35_statistic) приведены оценки объёма работы по реализации
Q35.

Таблица <a name="tbl.Q35_statistic">$</a>. Оценка объёма реализации Q35

+------------+------------------+-----------------+---------------+
| Этап       | Затронуто файлов | Вставлено строк | Удалено строк |
+============+==================+=================+===============+
| Подготовка | 4                | 42              | 31            |
+------------+------------------+-----------------+---------------+
| Генерация  | 8                | 599             | 0             |
+------------+------------------+-----------------+---------------+
| Реализация | 5                | 162             | 93            |
+------------+------------------+-----------------+---------------+
| Суммарно   | 12               | 803             | 31            |
+------------+------------------+-----------------+---------------+

Стоит заметить, что в настоящее время инструмент не поддерживает группировку
связанных по смыслу переменных в массивы и инициализацию их в цикле.
Ввиду этого, инициализация прерываний была вынесена на этап реализации. Это
позволило произвести регистрацию прерываний в цикле, тем самым обеспечив
краткость кода ВВМ. Инициализация прерываний заняла 20 строк кода, что
составляет менее 3% от кода всей модели.

Таким образом, приблизительно 75% кода платформы было сгенерировано
автоматически и лишь 11% пришлось модифицировать.

Итоговая версия платформы Q35 была успешно протестирована.
Тестирование состояло из загрузки ОС Windows7 и запуска Internet Explorer с
последующим открытием страницы `google.com`.

## C2621XM

За основу C2621XM взята его реализация из эмулятора Dynamips
[[$](#ref.Dynamips)].
Последний распространяется с открытым исходным кодом.
Его разработка на данный момент заморожена, если не считать проект
GNS3 [[$](#ref.GNS3)], который использует Dynamips для эмуляции маршрутизаторов,
коммутаторов и концентраторов, исправляя в нём ошибки.

На этапе подготовки в QEMU вносились следующие изменения:

* реализован MMU;
* реализована внутренняя коммутация прерываний процессора;
* исправлены некоторые регистры процессора специального назначения согласно с
документацией [[$](#ref.MPC860)];
* добавлены идентификаторы новых PCI устройств.

Первые два изменения позволили использовать процессор в режиме полносистемной
эмуляции: до этого поддерживалась только эмуляция ABI ОС.

На этапе ознакомления, исходя из анализа исходного кода Dynamips, был
составлен перечень устройств и выявлена их взаимосвязь.
Схема ВВМ представлена на рисунке [$](#pic.C2621XM).

![Рисунок <a name="pic.C2621XM">$</a> --- Схема маршрутизатора C2621XM](C2600.png)

Начальной версией QEMU был выбран последний на тот момент выпуск 2.9.0.
Все устройства, использованные в C2621XM, отсутствовали в QEMU, и были
перенесены из Dynamips.
При этом все заготовки были сгенерированы с помощью инструмента.
В таблице [$](#tbl.C2621XM_devices) приведена обзорная информация по элементам
C2621XM.
Сразу стоит отметить, что все эти устройства в Dynamips и, как следствие, их
перенесённые в QEMU версии реализованы не полноценно, а лишь до той степени,
чтобы удовлетворять потребностям некоторых версий системного ПО.

Таблица <a name="tbl.C2621XM_devices">$</a>. Элементы C2621XM

+-------------------+----------------------------------------------------------+
|       Тип         |                         Описание                         |
+===================+==========================================================+
| `MPC860`          | Процессор с системой команд PowerPC из одноимённого МК.  |
+-------------------+----------------------------------------------------------+
| `MPC860_IC`       | Контроллер прерываний. Поддерживает маскировку           |
|                   | прерываний.                                              |
+-------------------+----------------------------------------------------------+
| `MPC860_CPM`      | Маршрутизатор прерываний, позволяющий программно         |
|                   | перенаправить прерывания на другие номера. Стоит между IC|
|                   | и некоторыми из устройств.                               |
+-------------------+----------------------------------------------------------+
| `MPC860_SCC`      | Заглушка неизвестного устройства, предположительно       |
|                   | применяемо для пакетного обмена данными. В данном случае |
|                   | этот функционал не требуется.                            |
+-------------------+----------------------------------------------------------+
| `MPC860_DMA`      | Связка из двух устройств осуществляющая копирование      |
|                   | данных без участия процессора. Фактически используется   |
| `MPC860_PORT`     | для копирования данных между буферами сетевого адаптера и|
|                   | ОС.                                                      |
+-------------------+----------------------------------------------------------+
| `MPC860_WDT`      | Заглушка сторожевого таймера.                            |
+-------------------+----------------------------------------------------------+
| `C2600_IO_FPGA`   | Устройство служит аккумулятором прерываний от шины PCI,  |
|                   | на которой, фактически, размещаются только сетевые       |
|                   | адаптеры, и предоставляет доступ к EEPROM, с             |
|                   | идентификационной информацией об установленных сетевых   |
|                   | адаптерах.                                               |
+-------------------+----------------------------------------------------------+
| `CISCO_NVRAM`     | ПЗУ используемое для хранения настроек маршрутизатора.   |
+-------------------+----------------------------------------------------------+
| `CISCO_REMOTE`    | Устройство предоставляет интерфейс для получения         |
|                   | информации о системе:                                    |
|                   |                                                          |
|                   | * объём ОЗУ,                                             |
|                   | * объём ПЗУ (NVRAM),                                     |
|                   | * вариант платформы (в данном случае C2621XM);           |
|                   |                                                          |
|                   | а также позволяет хранить данные с доступом по ключу.    |
+-------------------+----------------------------------------------------------+
| `8MB_BOOTFLASH`   | ПЗУ фиксированного размера 8МиБ неизвестного             |
|                   | назначения.                                              |
+-------------------+----------------------------------------------------------+
| `NS16552`         | УАПП с двумя портами, именуемыми "con" и "aux". Через эти|
|                   | порты осуществляется настройка маршрутизатора.           |
+-------------------+----------------------------------------------------------+
| `PPC32_PIT`       | Таймер, посылающий прерывания с частотой 250 Гц.         |
+-------------------+----------------------------------------------------------+
| `C2600_PCI_HOST`  | Главный мост PCI и его конфигурационное пространство.    |
|                   | Отличительной особенностью является наличие 8 выделенных |
| `C2600_PCI`       | линий прерываний вместо стандартных 4.                   |
+-------------------+----------------------------------------------------------+
| `AM79C971`        | Сетевой адаптер PCI. В QEMU уже имеется его двойник с    |
|                   | именем `pcnet`. Но особенности реализации сильно         |
|                   | отличаются, поэтому данное устройство было реализовано   |
|                   | исключительно на основе Dynamips.                        |
+-------------------+----------------------------------------------------------+

На этапе реализации была перенесена индивидуальная часть устройств из
Dynamips, а также скорректирована заготовка ВМ.
Корректировка ВМ, в основном, заключалась в следующем:

* связка параметров ВМ с CLI QEMU:
    * образы ПЗУ,
    * подключение сетевых интерфейсов,
    * подключение символьных устройств;
* реализация специального кода;
* корректировка имён переменных.

В таблице [$](#tbl.C2621XM_statistic) приведена оценка объёма работы.

Таблица <a name="tbl.C2621XM_statistic">$</a>. Оценка объёма реализации C2621XM

+------------+------------------+-----------------+---------------+
| Этап       | Затронуто файлов | Вставлено строк | Удалено строк |
+============+==================+=================+===============+
| Подготовка | 8                | 128             | 35            |
+------------+------------------+-----------------+---------------+
| Генерация  | 37               | 2186            | 0             |
+------------+------------------+-----------------+---------------+
| Реализация | 31               | 4747            | 419           |
+------------+------------------+-----------------+---------------+
| Суммарно   | 45               | 6642            | 35            |
+------------+------------------+-----------------+---------------+

Таким образом, приблизительно 1/3 кода всего маршрутизатора была
сгенерирована автоматически.
Причём только 1/5 часть сгенерированного кода потребовала модификации.
Итоговая версия маршрутизатора была успешно настроена для маршрутизации пакетов
между двумя сетями (по одной на каждый интерфейс) и обеспечивала стабильное
соединение в течении тестового времени (приблизительно 12 часов).
В качестве генератора трафика использовалась утилита `ping`, настроенная на
отправку ICMP запросов длиной 60кБ и 50кБ с машин из противоположных сетей.
Сбоев замечено не было.
Среднее время запроса 12мс.

# Заключение
# Использованные источники

$. <a name="ref.Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

$. <a name="ref.Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". "https://wiki.python.org/moin/TkInter", 2017.03.13.

$. <a name="ref.PyCParser"></a>Страница библиотека PyCParser на GitHub.
"https://github.com/eliben/pycparser", 20.03.2017.

$. <a name="ref.DetReplay"></a>V. Yu. Efimov, K. A. Batuzov, V. A. Padaryan,
A. I. Avetisyan. Features of the deterministic replay in the case of a
minimum device set. Programming and Computer Software, April 2016, Volume 42,
Issue 3, pp 174–186.

$. <a name="ref.Dynamips"></a>Руководство по работе с Dynamips.
"http://www.iteasypass.com/Dynamips.htm", 30.06.2017.

$. <a name="ref.GNS3"></a>Страница инструмента эмуляции сети GNS3.
"https://gns3.com", 30.06.2017

$. <a name="ref.MPC860"></a>Руководство пользователя для микроконтроллеров
серии MPC860. "http://www.nxp.com/docs/en/reference-manual/MPC860UM.pdf",
30.06.2017

$. <a name="ref.Python"></a>Сайт о языке программирования Python.
"https://www.python.org/", 06.07.2017.

$. <a name="ref.DBT"></a>_Что-нибудь про дин. дв. трансляцию_.

$. <a name="ref.Dovgaluk"></a>ссылка на Довгалюк-статью

$. <a name="ref.QEMU"></a>QEMU

$. <a name="ref.remote_GDB"></a> remote GDB

