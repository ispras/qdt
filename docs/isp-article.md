[//]: # (make)

<!--
Перед подачей в pandoc статься должна быть предобработана сценарием
md-preprocessor.py. Он осуществляет автоматизацию ссылок. Ниже приводятся
некоторые пояснения по поводу оформления ссылок. Подробные сведения и нюансы:
см. код сценария. Примеры оформления см. в тексте.

Типы ссылок:
ref.MyRefName     - ссылки на источники
rel.MyText        - ссылки на такст, которые будут заменены на "выше" или "ниже"
pic.MyPictureName - ссылка на картинку
tbl.MyTable       - ссылка на таблицу
без приставки     - ссылка никак не обрабатывается

Для каждой ссылки должен быть объявлен "якорь" - позиция, на которую эта ссылка
ссылается. Якори расставляются так.

$. <a name="preffix.MyName">$</a>

где $ - ставится только в том случае, если предполагается автоматическая
замена этого символа на что-то другое (в соответствии с типом ссылки). Якорь
должен быть ПЕРЕД соответствующим текстом.
-->

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

В.Ю. Ефимов &lt;real@ispras.ru>

А.А. Беззубиков &lt;abezzubikov@ispras.ru>

Д.А. Богомолов &lt;bda@ispras.ru>

О.В. Горемыкин &lt;goremykin@ispras.ru>

Институт системного программирования им. В.П. Иванникова РАН,

109004, Россия, г. Москва, ул. А. Солженицына, д. 25.

<!--
# Обозначения и сокращения

* API Application programming interface
* ABI Application binary interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* EEPROM Electrically erasable programmable ROM
* GNU GNU's Not Unix!
* GPIO general purpose input/output
* GPL General Public License
* ICH I/O Controller Hub
* ICMP Internet control message protocol
* IRQ Interrupt request
* JSON JavaScript Object Notation
* LPC Low pin count
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* MSI-X Extended MSI
* PCap Packet Capture
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* TCG Tiny code generator
* TCP Transmission control protocol
* UDP User datagram protocol
* USB Universal serial bus
* АСД абстрактное синтаксическое дерево
* ВМ вычислительная машина
* ГИП графический интерфейс пользователя
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* ПО программное обеспечение
* УАПП универсальный асинхронный приёмо-передатчик
-->

## Аннотация
Разработка моделей устройств и вычислительных машин для QEMU --- это трудоёмкий
процесс.
Ввиду этого есть необходимость в его автоматизации.
В данной работе был проведён анализ QEMU и процесса разработки моделей для QEMU.
Модель устройства имеет много формального избыточного кода.
Этот код имеет сравнительно небольшое количество информативных параметров.
Эти параметры были формализованы, и был разработан программный инструмент для
генерации заготовки кода устройства.
Модель машины получается путём компоновки из моделей устройств с использованием
объектной модели.
При этом машина состоит из большого количества элементов и связей между ними,
которые затруднительно воспринимать в форме программного кода.
В работе предлагается использовать схематичное представление машины в рамках
разработанного графического интерфейса пользователя.
При этом могут быть применены малые автоматизации компоновки машины.
Разработанный инструментарий предлагается применять в самом начале рабочего
процесса.
Разработчик, ознакомившись с документацией, может сформулировать параметры
генерации устройств, скомпоновать машину и получить заготовки кода устройств и
машины.
Согласно экспериментам, количество строк кода с параметрами устройства в 11-25
раз меньше количества строк получаемой заготовки.
Суммарный объём сгенерированного кода заготовок составляет от \(1/4\) до
\(3/4\) в зависимости от количества устройств, уже реализованных в QEMU.

<br>
Работа поддержана грантом РФФИ № 16-29-09632.

<br>
**Ключевые слова**:
программный эмулятор, бинарный код, разработка виртуальных машин.

**DOI:**
TODO

**Для цитирования:**
TODO

## <a name="Introduction"></a>$. Введение

Виртуальные вычислительные машины (ВВМ) применяются для решения разнообразных
задач: включая исследования в рамках информационной безопасности.
Одной из задач является организация контролируемого окружения для
исследуемого машинного кода во время динамического анализа.
Устоявшийся подход совмещает дизассемблер IDA Pro и интерактивную отладку,
когда сервером удаленной отладки выступает эмулятор.
Эмулятор дает дополнительный «рубеж» изоляции между исследуемым кодом и
инструментами анализа [[$](#ref.Dovgaluk)] и хорошо подходит для
исследования компьютерных вирусов и другого вредоносного ПО.
Одним из программных средств для организации ВВМ является эмулятор QEMU
[[$](#ref.QEMU)].

QEMU --- наиболее подходящий эмулятор для данной цели ввиду ряда свойств:

* открытый исходный код (лицензия GPL);
* поддержка разнообразных процессорных архитектур для ВВМ (Intel x86, AMD 64,
ARM, MIPS, PowerPC, SPARC и др.);
* реализация важных, с точки зрения динамического анализа, технологий и
возможностей:

    * динамическая двоичная трансляция (принципиально снижает относительное
    замедление);
    * интерфейс отладки ВВМ (по протоколу remote GDB [[$](#ref.remote_GDB)]);
    * сохранение и загрузка состояния ВВМ (_snapshot_);
    * дублирование сетевого трафика в PCap;
    * программный интерфейс контроля работы ВВМ --- QMP (QEMU Monitor Protocol),
    основанный на JSON;
    * ручной командно-ориентированный интерфейс контроля работы ВВМ --- HMP
    (Human Monitor Protocol);

* работоспособность в окружении распространённых операционных систем (ОС):

    * Microsoft Windows XP и новее,
    * GNU Linux (семейства Debian, Fedora и др.).
    * Mac OS;

* модульная архитектура, допускающая расширение перечня эмулируемых
процессорных архитектур, вычислительных машин (ВМ) и устройств.

При динамическом анализе машинного кода для узкоспециализированных и
малораспространённых ВМ необходимо реализовать в эмуляторе соответствующую ВВМ.
Существенной проблемой становится подготовка необходимого окружения, т.е. ВВМ
требуемой конфигурации, в котором будет работать исследуемое ПО.
Не имея законченной ВВМ, невозможно задействовать всю мощь динамического
анализа.
Даже самые простые ВМ состоят из десятков устройств.
Ввиду огромного разнообразия устройств в богатой библиотеке устройств QEMU
редко удаётся обнаружить требуемое устройство.
Особенно, когда речь идёт об узкоспециализированных ВМ.
Т.е. необходимо реализовывать большое количество моделей устройств.
Несмотря на то, что QEMU архитектурно приспособлен к добавлению новых моделей,
процесс их разработки --- трудоёмкая задача.
В связи с этим возникает необходимость исследовать процесс разработки
моделей ВМ и устройств с целью его ускорения.
Используемый в настоящее время подход к реализации моделей для QEMU сводится к
выполнению рутинной ручной работы.
Он заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию.
При этом применяется непосредственное копирование кода, с последующими его
правками и дополнениями.
Т.е. в качестве "чистого листа" используют схожие устройства.
Функциональное наполнение вносится согласно документации, а интерфейсы
обновляются, чтобы соответствовать требованиям актуальной версии эмулятора.
С опытом всё большую часть кода можно писать по памяти, следя за изменениями в
QEMU.
В данной работе разработан метод ускорения, основывающийся на выявлении и
автоматизации рутинных этапов данного процесса.
Метод был реализован в программном инструменте на языке
Python[[$](#ref.Python)].

Дальнейший текст организован следующим образом:

* рассматриваются работы, ориентированные на решение схожих проблем;
* описывается подход, используемый в QEMU для эмуляции устройств и ВМ;
* с учётом подхода к эмуляции формулируется предлагаемый подход к автоматизации;
* подобно описывается разработанный программный инструмент, реализующий
подход к автоматизации;
* предлагается процесс разработки устройств и ВМ с использованием
разработанного инструмента;
* приводятся экспериментальные данные об использовании инструмента.


## $. Обзор близких работ

Необходимость поддержать разработку новых ВВМ неизбежно возникает в любом
развивающемся эмуляторе.
Даже если рассматривается эмулятор с единственной гостевой процессорной
архитектурой, для работы системного кода может потребоваться определенный
комплект устройств, с определенной конфигурацией регистров
ввода/вывода, прерываниями, взаимодействием с внешней средой и др.
Среди множества известных эмуляторов стоит выделить
такие проекты, как SimNow [[$](#ref.SimNow)], Simics [[$](#ref.Simics)],
gem5 [[$](#ref.gem5)] и OVPsim [[$](#ref.OVPsim)].
Первые два эмулятора --- коммерческое ПО, gem5 --- ПО с открытым исходным
кодом, распространяемым по лицензии BSD.
OVPsim состоит из коммерческого ядра эмуляции и открытой библиотеки ВВМ.
Все перечисленные эмуляторы используются на практике и поддерживают быстрое
добавление новых ВВМ.

### $.$ AMD SimNow

Эмулятор AMD SimNow [[$](#ref.SimNow)] предназначен для упреждающей разработки
низкоуровневого системного ПО для выходящих на рынок x86 процессоров AMD,
в силу чего библиотека компонент ВВМ содержит только процессора этой фирмы.
Создание новой ВВМ происходит в графическом редакторе, где
задаются связи между компонентами машины.
Связь между устройствами задается пользователем, причём требуется указать
пару имен интерфейсов у связываемых устройств.
При задании связи сразу происходит проверка ее корректности.
У эмулятора SimNow имеется комплект разработчика (SDK), позволяющий создавать
на языке Си++ как инструменты анализа (трассировщики и т.п.), так и новые
устройства.
Модели устройств в SimNow реализуются на базе иерархии
классов Си++, которая в основном используется для наследования библиотечных
методов.
Типизация устройств крайне проста.
Как правило, базовый тип устройства отсутствует, набольшая часть методов класса
реализует служебную логику, необходимую для работы эмулятора.
Пример исключения из такой практики --- класс `CUsbMouse`, который наследуется
от классов `CUSBDevice` и `CAutomationLib`.
Первый базовый класс представляет абстрактное USB-устройство, второй ---
реализует возможность получать управляющие команд из консоли эмулятора для
конфигурации устройства или от сценария инициализации.
В SDK включены исходные коды типовых моделей устройств (ПЗУ BIOS,
аудио и видео адаптеры, мосты различных шин, контроллеры
прерываний и др.) на основе которых предлагается разрабатывать
собственные модели.

### $.$ gem5

В эмуляторе gem5 [[$](#ref.gem5)] предложена более сложная иерархия типов
устройств.
Еще одним отличием от SimNow, стала возможность быстрого прототипирования ВВМ
на языке Python, для которого была реализована привязка C++ API.
Реализация моделей устройств, требующих большого количества вычислений,
ведется на Си++, а их интеграция и задание конфигурации ВВМ выносится
в сценарий.
Поскольку gem5 разрабатывается для детального моделирования
современных процессоров, влияющих на производительность системного и
прикладного ПО: большая часть библиотечных компонентов эмулирует
многоуровневую память и топологию связей между вычислительными ядрами.
"Медленные" периферийные устройства в gem5 фактически не представлены.

### $.$ Simics

По сравнению с предыдущими двумя эмуляторами, Simics обладает наибольшими
возможностями по созданию новых моделей машин и отдельных устройств.
Как и gem5 объектная модель и API Си++ имеют привязку к языку Python.
Помимо того, доступен специализированный язык DML (Device Modeling Language),
предназначенный для моделирования устройств в Simics.
Описание устройства на DML транслируется компилятором dmlc в Си++ из которого
собирается разделяемая библиотека.
В DML программа описывает _класс-устройство_, возможно наследованный от
некоторого базового класса.
Полями класса-устройства могут быть объекты, которые должны представлять
один из встроенных классов.
Расширять перечень встроенных классов (в документации для них используют
термин _тип объекта_) пользователь не может.
Встроенные классы описывают как базовые примитивы виртуальной аппаратуры,
так и служебные данные, используемые эмулятором в работе.
Базовые примитивы сводятся к двум понятиям: регистр и соединение.
Имеется пять вспомогательных классов, используемых для различных способов
группировки регистров и соединений.
Класс (тип) `attbibute` описывает произвольное свойство объекта, которое
необходимо сохранять при создании снимка состояния.
При добавлении к устройству полей регистров и соединений среда разработки
автоматически создает для их описания поля типа `attribute`.
На рисунке [[$](#pic.DML_example)] представлено сокращенное описание
учебного устройства `excalibur`, подключаемого к шине `pci`.
У устройства имеется _банк регистров_, в которых размещаются некие данные.
Размер регистров --- 4 байта, регистр `r1` размещен в банке по нулевому
смещению, регистр `r2` --- по смещению 4.
Содержимое каждого регистра полностью покрывается единственным _полем_,
для которого определены методы _чтения_ и _записи_.
Для описания семантики действий, происходящих в устройстве,
тела DML-методов выражаются на языке, расширяющем подмножество ISO Си.
Добавлены некоторые конструкции, характерные для Си++, такие как
`new`/`delete`, `try`, `throw`.

+-----------------------------------+
|```                                |
|device excalibur;                  |
|                                   |
|connect bus {                      |
|    interface pci;                 |
|}                                  |
|...                                |
|bank databank {                    |
|    parameter function = 1;        |
|    register r1 size 4 @ 0x0000 {  |
|        field f1 {                 |
|            method read { ... }    |
|            method write { ... }   |
|        }                          |
|    }                              |
|    register r2 size 4 @ 0x0004 {  |
|        field f2 {                 |
|            method read { ... }    |
|            method write { ... }   |
|        }                          |
|    }                              |
|}                                  |
|```                                |
+-----------------------------------+

Рисунок <a name="pic.DML_example">$</a> --- Пример DLM-описания
модели устройства `excalibur`

### $.$ OVPSim

Поскольку эмулятор OVPSim изначально рассчитан на привлечение сторонних
разработчиков для создания новых ВВМ, он предлагает открытое и обширное API
на языке Си, которое распадается на три части:

* VMI --- разработка новых процессоров,
* PPM/BHM --- разработка новых периферийных устройств,
* OP --- интеграция компонент ВВМ и контролирование ее работы.

Ускорение разработки на начальном этапе обеспечивает утилита iGen
(входит в SDK), которая по декларативному описанию на языке TCL генерирует
заготовки.
Утилита поддерживает автоматическое создание набора Си-файлов для моделей
процессоров и устройств, встраиваемых в эмулятор; способна
интегрировать интерфейс разрабатываемого Си-модуля с SystemC TLM2.
Результат работы утилиты --- полный комплект файлов с исходным кодом,
которые компилируются в динамически загружаемую библиотеку.
Описание определяет перечень регистров устройства, их отображение на память,
интерфейсы шин.
Поведение устройства реализуется в OVPSim через функции обратного вызова,
сгенерированные файлы содержат объявления функций, а их определения имеют
пустые тела, которые разработчик реализует самостоятельно.
На рисунке [[$](#pic.TCL_example)] приведен пример TCL-сценария, описывающего
простую ВВМ с одним процессором OpenRISC 1000, 32-х разрядным адресным
пространством, на два диапазона которого отображено ОЗУ, и
регистрами УАПП, которые, в свою очередь, отображены на диапазон
адресов с `0x100003f8` по `0x100013f7`.

+-------------------------------------------------------------------+
|```                                                                |
|ihwnew -name simpleCpuMemoryUart                                   |
|ihwaddbus -instancename mainBus -addresswidth 32                   |
|ihwaddnet -instancename directWrite                                |
|ihwaddnet -instancename directRead                                 |
|ihwaddprocessor -instancename cpu1 \                               |
|    -vendor ovpworld.org -library processor -type or1k \           |
|    -version 1.0 -semihostname or1kNewlib \                        |
|    -variant generic                                               |
|ihwconnect -bus mainBus -instancename cpu1 \                       |
|    -busmasterport INSTRUCTION                                     |
|ihwconnect -bus mainBus -instancename cpu1 -busmasterport DATA     |
|ihwaddmemory -instancename ram1 -type ram                          |
|ihwconnect -bus mainBus -instancename ram1 \                       |
|    -busslaveport sp1 -loaddress 0x0 -hiaddress 0x0fffffff         |
|ihwaddmemory -instancename ram2 -type ram                          |
|ihwconnect -bus mainBus -instancename ram2 \                       |
|    -busslaveport sp1 -loaddress 0x20000000 -hiaddress 0xffffffff  |
|ihwaddperipheral -instancename periph0 \                           |
|    -vendor freescale.ovpworld.org -library peripheral \           |
|    -version 1.0 -type KinetisUART                                 |
|ihwsetparameter -handle periph0 -name outfile \                    |
|    -value uartTTY0.log -type string                               |
|ihwconnect -instancename periph0 \                                 |
|    -busslaveport bport1 -bus mainBus \                            |
|    -loaddress 0x100003f8 -hiaddress 0x100013f7                    |
|ihwconnect -instancename periph0 -netport DirectWrite              |
|    -net directWrite                                               |
|ihwconnect -instancename periph0 -netport DirectRead               |
|    -net directRead                                                |
|```                                                                |
+-------------------------------------------------------------------+

Рисунок <a name="pic.TCL_example">$</a> --- Пример TCL-сценария для создания
заготовки ВВМ

### $.$ Synopsys Virtualizer / Synopsys Virtual Platform

Отдельно стоит упомянуть Synopsys Virtualizer /
Synopsys Virtual Platform [[$](#ref.SynopsysVP)] --- эмулятор для языка
SystemC со средствами моделирования и поддержки быстрого прототипирования.
Несмотря на то, что эмуляция проводится на принципиально ином уровне
(SystemC и VHDL), комплект средств разработчика весьма схож с тем, что
предлагает Simics.
Помимо специфических для уровня VHDL программных инструментов, Synopsys
Virtualizer включает библиотеки готовых устройств, инструмент для быстрой
интеграции компонент и настройки виртуальной системы.
Интеграция выполняется как над графическим представлением системы, так и с
помощью интерпретируемого языка.

### $.$ QEMU

Среди полносистемных эмуляторов QEMU занимает особое место, в силу его
признания со стороны крупных IT-компаний.
Например, Google и Samsung, разрабатывают специализированные эмуляторы для
мобильных устройств на его основе.
В силу того, что развитие эмулятора ведется распределенным сообществом, вопрос
создания инструментальной поддержки для разработчика ВВМ не получает должного
приоритета.
Нередко новые машины на основе QEMU разрабатываются закрыто, для внутренних
нужд компании.
Применительно к "разовой" разработке ВМ создание инструментов поддержки не
актуально и более того, не целесообразно в силу отвлечения ограниченных
ресурсов.
Тем не менее, появление автоматизированных методов разработки ВМ и
соответствующих инструментов было бы полезно для всего сообщества
разработчиков QEMU.

<!--- QEMU --->
## $. Подход к автоматизации

Типовой процесс разработки новой модели (как устройства, так и ВМ) начинается
с изучения документации.
Сначала проводится поверхностное изучение, в результате которого формируются
общие представления об объекте моделирования.
Не лишним будет проверить факт наличия в QEMU уже готовой модели.
В противном случае, начинается процесс разработки, сопровождающийся более
подробным изучением документации.
Процесс разработки является итеративным.
В нём перемежаются написание кода модели и отладка.
В данной работе разработан инструмент, автоматизирующий первое написание кода
модели.
Он основан на объектной модели QEMU, применяемой к устройствам и ВМ.

### $.$ Объектная модель QEMU

Основой использованного в QEMU подхода к моделированию ВМ и их компонент
является "объектная модель QEMU" (англ. _QEMU Object Model_ или,
далее по тексту, _QOM_). Данная модель применяется не только для моделирования
ВМ и их
компонент, но и для реализации вспомогательных возможностей. QOM является
реализацией парадигмы ООП на языке Си.

QOM организует иерархию _типов_ (type).
Каждый тип имеет уникальное строковое _имя_.
Тип описывает _класс_ (class) и _экземпляр_ (instance).
Экземпляров может быть много, в то время как класс один.
Иерархия QOM получается путём _наследования_ (по аналогии с ООП) ---
установления отношения между двумя типами, таким образом, что один тип
называется _ребёнком_, а другой --- _родителем_.
Ребёнок копирует всю информацию из родителя --- _наследует_.
Множественное наследование не поддерживается.
Тип может быть _абстрактным_: такой тип не может иметь экземпляров.

Несмотря на название QOM, _объект_ (object) не является её базовым понятием, а
только одним из типов. Данный тип добавляет <a name="QOM_object_property">
_свойства_</a> к экземплярам и классам.
Свойство описывается строковым именем (уникальным в пределах объекта или
класса), функциями доступа (присваивания (set) и разыменования (get)) и типом.
Со свойством связана и другая информация, но её рассмотрение выходит за
рамки данной работы.
Тип свойства ограничивает область его допустимых значений.

Моделирование ВВМ и её элементов основано на потомках типа _объект_ (object).
К ним относятся:

* машина (machine),
* устройство (device),
* шина (bus),
* запрос прерывания (irq),
* участок памяти (qemu:memory-region).

Модели ВВМ, шин и устройств должны быть, соответственно, потомками machine, bus
и device.
Типы irq и участка памяти являются инфраструктурными, они используются в
общем API и их уточнение обычно не требуется.
Дальнейшее наследование шин и устройств происходит по принадлежности к
стандарту шины.
При этом вводятся промежуточные типы, реализующие общий функционал.
Конкретная модель устройства наследуется от типа соответствующего стандарту
её шины.
При реализации модельного ряда устройств добавляется промежуточный тип с общими
для всего ряда особенностями.

### $.$ Метод автоматизации

На рисунке [$](#pic.main) изображены основные принципы работы разработанного
инструмента.
Вручную или с помощью разработанного ГИП разработчик
указывает основные параметры разрабатываемых моделей.
Для указания параметров инструмент предоставляет человеко-ориентированный
интерфейс программирования.
На основе указанных параметров инструмент автоматически генерирует заготовки
программного кода моделей.
Эти заготовки не обладают законченной функциональностью, но готовы к компиляции.
Генерация основана на шаблонах --- фрагментах программного кода, которые
подстановками строковых параметров приводятся в синтаксически корректный код
на языке Си.
При этом используется информация, получаемая об эмуляторе автоматически, с
применением специализированного анализа программного кода.
Дальнейшая работа разработчика заключается во внесении в заготовку кода,
соответствующего не формализованным особенностям работы устройства, согласно
документации на него.
Важной особенностью является то, что объём кода, формулирующего параметры
устройства, на порядок меньше, чем объём генерируемого кода.
Таким образом, инструмент ускоряет разработку модели за счёт сокращения
объёма кода, написанного вручную.
В случае разработки ВВМ, принципиальной разницы в количестве кода нет.
Отличие заключается в представлении ВВМ в виде схемы средствами ГИП.
Схематичное представление облегчает восприятие ВВМ, что снимает с разработчика
умственную нагрузку.
Кроме этого исключаются лексические, синтаксические и некоторые семантические
ошибки.

![Рисунок <a name="pic.main">$</a> --- Схема работы генератора заготовок
моделей устройств и ВМ](main.png)

Метод шаблонов основан на следующей особенности кода QEMU.
Любая модель, как устройство, так и машина, является частью эмулятора.
Следовательно, её код, среди прочего, содержит фрагменты, обусловленные
требованиями эмулятора, а не особенностями оригинала.
Таким образом, условно код модели можно разделить на две части:
_индивидуальную_ и _интерфейсную_.

В первую очередь рассмотрим это разделение для устройств.
Индивидуальная часть задает поведение устройства в его программной реализации.
Именно эта часть определяет то, как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройства является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя возможности,
предоставленные посредством API QEMU. В модели всегда можно
выделить часть кода,
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и остальным кодом
эмулятора.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных. Т.е. её параметры хорошо
формализуемы.

Отдельно нужно сказать о применимости данного подхода к ВМ.
В QEMU присутствует развитый API для интеграции устройств в единое целое
(то есть в ВМ).
Разработанный API во многом похож на API из QEMU.
С помощью разработанного API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть, реализованную в
полном соответствии с принятым в QEMU подходом к написанию моделей устройств.
Иначе несоответствие придётся компенсировать вручную.

2. Сгенерированная машина не поддаётся настройке, так как все её параметры
зафиксированы на уровне исходного кода. Реализация возможности настраивать
машины требует внесения кода вручную.

Первое ограничение не существенно, если преобладающая часть устройств ВМ
реализуется вместе с ней по формальному описанию с помощью разработанного
инструмента.
Такие устройства будут иметь совместимую интерфейсную часть.
Но в QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к написанию моделей устройств.
На данный момент не все из них были переписаны в соответствии с этим подходом.
То есть они реализуют свою индивидуальную часть в обход новейших возможностей
API для интерфейсной части.
Если же нужно использовать подобную модель устройства, то возможно
использовать разработанный
инструмент, сгенерировав с его помощью новую интерфейсную часть.
В противном случае интеграцию такого устройства придётся производить
вручную, что менее эффективно.

Второе ограничение заключается в следующем.
Часть параметров машины задается пользователем только в момент запуска
эмулятора через CLI (Command Line Interface --- англ. интерфейс командной
строки):

* файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
* оконечную точку УАПП (виртуальный терминал, файл, и т.п.),
* способ подключения сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.)
и т.д.

Поддержка CLI требует внесения в код заготовки машины специального кода.
Автоматизация этого процесса для наиболее распространённых опций CLI является
направлением дальнейших исследований.
<!--+ интерфейсная часть, индивидуальная часть +-->


### $.$ API генератора заготовок
<!--- интерфейсная часть, индивидуальная часть, QEMU, эмулятор, интерфейс,
язык Си, функция (Си), аргумент функции, структура (Си) --->
Состав интерфейсной части устройства определяется:

* задаваемым эмулятором формальным минимумом;
* потребностями индивидуальной части.

QEMU предоставляет ряд интерфейсов, из которых в интерфейсную часть
выбираются нужные.
Код, соответствующий отдельно взятому интерфейсу, единообразен.
Его можно получать из некоторого набора строковых заготовок, путём подстановки
параметров.
Часть параметров одних интерфейсов может быть связана с параметрами других
интерфейсов.
Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и относительно фрагментов других интерфейсов.
Это требование следует из синтаксиса языка Си.
Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.
Также не стоит забывать про связь фрагментов с существующим кодом QEMU.
Кроме этого следует учитывать семантику фрагментов (близкие по смыслу фрагменты
должны располагаться близко) и требования стиля программирования QEMU.

Генератор заготовок предоставляет API, упрощающий учёт этих и других
особенностей.
Состав API генератора условно можно разбить на две части:

* для _использования_ шаблонов;
* для _добавления_ шаблонов.

Каждый шаблон использует обе части. Через API использования шаблонов он
добавляет себя в инфраструктуру инструмента, давая возможность применять себя
для генерации. А с помощью API добавления шаблон реализует генерацию кода в
соответствии с переданными ему параметрами.

Поскольку разработанный инструмент является в первую очередь инструментом
разработчика моделей для QEMU, обе части API генератора должны быть удобны
для использования.

<!--+ интерфейс использования шаблонов, интерфейс добавления шаблонов
шаблон, модуль (Python) +-->

<!--- интерфейс использования шаблонов, QEMU, иерархия классов QOM, ВМ,
PCI, MSI, QEMU, PCI Express, устройство PCI, функция PCI --->
#### Интерфейс использования шаблонов
Интерфейс использования шаблонов ориентирован на получение от пользователя
перечня интерфейсов QEMU, требуемых разрабатываемой моделью, и их
параметров.
Для этого интерфейс использования предоставляет иерархию классов.
Она построена по тому же принципу, что и иерархия классов QOM.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначен для
использования. `SysBusDeviceDescription` описывает устройство на системной шине.
`PCIExpressDeviceDescription` описывает PCI устройство QEMU.

<!--
Напомним, что PCI-_устройство_ в QEMU соответствует одной _функции_ реального
устройства.
А поскольку QEMU не моделирует физические взаимодействия по шине,
поддержка MSI (а именно реакция на запись сообщения в память) реализуется
мостом или контроллером прерываний, обычно являющимися устройствами.
Как следствие, и PCI, и PCI Express устройство может быть описано через этот
класс.
-->

Перечисленные классы выполняют роль контейнеров для параметров.
Но, в то время как для описания устройств системной шины или PCI достаточно
одного объекта перечисленных классов, для описания ВМ требуется ещё
одна иерархия, рассмотренная [$](#rel.machine_hierarchy).
Объект класса `MachineNode` служит контейнером для объектов этой иерархии
и прочих параметров генерации.
Совместно объекты классов-потомков `QOMDescription` образуют
_проект_ (`QProject`), аккумулирующий данные для генерации кода.
В функцию классов, описывающих проект, устройства, ВМ и её состав, входит
сохранение этой информации в файл.
<!--+ QOMDescription, SysBusDeviceDescription, PCIExpressDeviceDescription,
MachineNode, QProject +-->

<!-- MachineNode, мост, дочернее устройство, иерархия QOM, дочерняя шина,
устройство-родитель шины, свойства устройства, GPIO, инкапсуляция (ООП),
источник прерывания, приёмник прерывания, адресация GPIO, GPIO,
двоичный сигнал, участок памяти, участок-контейнер, участок-псевдоним,
участок-RAM, участок-ROM, участок-IO, графический интерфейс инструмента -->
#### <a name="rel.machine_hierarchy"></a> Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа.
Все дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для ручной работы с программным интерфейсом.
При использовании графического интерфейса это не актуально.

`DeviceNode` описывает параметры самого устройства и настройки его интеграции.
Классы наследуемые от `DeviceNode` расширяют этот список в соответствии с
шаблонами устройств для конкретных стандартов шин.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
инкапсулирована в шину).
Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два конца).

Следующие классы используются для явного создания участком памяти.
Хотя большую часть адресного пространства ВМ определяют сами устройства,
некоторые
участки памяти, соответствующие ОЗУ, некоторым ПЗУ и т.п., должны быть добавлены
явно.
Для ОЗУ используется `MemoryRAMNode`, а для ПЗУ `MemoryROMNode`.
`MemoryAliasNode` используется для ссылки на один участок адресного
пространства из другого диапазона адресов.
`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять участки в участки, не являющиеся контейнерами.

<!--+ Node, BusNode. SystemBusNode, PCIExpressBusNode, ISABusNode, IDEBusNode,
I2CBusNode, DeviceNode, SystemBusDeviceNode, PCIExpressDeviceNode`,
IRQLine, IRQHub, MemoryNode, MemoryLeafNode, MemoryAliasNode, MemoryRAMNode,
MemoryROMNode +-->

<!--- QProject, Python, аттрибут объекта (Python), "простой тип" (Python),
None (Python) --->
#### Формат файла проекта

<!--
При работе с ГИП используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.
-->

Формат файла, хранящего проект, основывается на возможности интерпретатора
языка Python динамически добавлять код в программу.
Сохранённый проект представляет собой код на языке Python.
В данном случае код загружается из файла.
Поскольку инструмент сам написан на языке Python, данное решение существенно
упростило разработку.
Результатом выполнения кода проекта является определение переменной,
ссылающейся на объект класса `QProject`, _эквивалентный_ объекту,
сохранённому в этом коде.
Генератор файлов сохранений изначально разрабатывался таким образом, чтобы
файлы выводились в удобном для человека форматировании.

Однако при сохранении _не_ гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически незначащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность имён переменных;
* использование тех же самых конструкций языка (например, программист может
создавать несколько объектов в цикле, в то время как инструмент сгенерирует для
этих объектов развёрнутый код);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является одним из направлений дальнейших исследований.
<!--+ формат файла проекта, эквивалентный объект (Python) +-->


<!--- шаблоны, .format (Python), % (Python), форматная строка (концепция),
АСД, препроцессор (Си), стиль программирования QEMU, printf,
интерфейсная часть, индивидуальная часть, цикл (Си), ветвление (Си),
конструктор экземпляра, конструктор класса, принцип чёрного ящика,
функции (Си), макрос, функция реализации устройства,
функция инициализации ВВМ --->
#### Модель языков Си и препроцессора

Шаблоны реализованы с помощью форматных строк.
Генерация кода заключается в подстановке параметров в форматные строки.
Из полученных фрагментов кода затем составляются файлы.
Форматные строки являются низкоуровневым способом определения шаблонов.
Они ограничены в возможностях программной обработки.
В связи с этим для разработки шаблонов был введён вспомогательный интерфейс.
Будем называть его _интерфейсом добавления шаблонов_.
Он основан на форматных строках, но предоставляемые им инструменты
ориентированы на генерацию базовых конструкций языка Си.
Поэтому интерфейс напоминает программную реализацию АСД, однако
есть принципиальное отличие: он поддерживает и язык препроцессора.

Параллельно была предпринята попытка использовать для определения
шаблонов АСД языка Си. Библиотека PyCParser[[$](#ref.PyCParser)],
реализует двустороннее преобразование. Однако у применения АСД имеются
следующие недостатки:

* не поддерживается препроцессор, макросы которого активно используются
в интерфейсной (и не только) части кода устройства;

* не учитываются незначащие символы (пробелы, переносы строк,
комментарии), что требует доработки генератора PyCParser, таким образом,
чтобы он генерировал код, не противоречащий стилю программирования QEMU.

<!--+ общие сведения об интерфейсе добавления шаблонов +-->


<!--+ общие сведения об интерфейсе добавления шаблонов,
двоичный транслятор QEMU, PyCParser, макрос  +-->
Основой интерфейса добавления шаблонов является модель _гибридного языка_,
сочетающего язык Си и подмножество языка препроцессора.
Эта модель описывает содержимое заголовков и модулей языка Си.
Разработчик описывает содержимое шаблона с точки зрения того, какие
конструкции должны быть добавлены в файл в соответствии с этим шаблоном.
Причём один шаблон может касаться нескольких файлов, ровно как и один файл
может содержать конструкции из нескольких шаблонов.
Некоторые конструкции из шаблонов связаны с уже существующими в QEMU
конструкциями.
Поэтому интерфейс позволяет определять содержимое существующих файлов.
Описание существующих конструкций носит декларативный характер.
Многие подробности могут быть пропущены, так как генерация не предполагается.
Иными словами используется принцип минимально достаточной информации.

При описании содержимого файла используются следующие классы.

* `Type`
    * `Structure`
    * `Function`
    * `Enumeration`
    * `Pointer`
    * `Macro`
    * `TypeReference`
* `Initializer`
* `Variable`
* `Usage`

`Structure`, `Function`, `Enumeration` и `Pointer` соответствуют структуре,
функции, перечислению и указателю в языке Си. `Macro` используется для
директив `#define` препроцессора.

Объект `TypeReference` (ссылка на тип) используется для ссылок на типы
из других файлов. Любой тип может присутствовать непосредственно только
в файле, где он объявлен. Но, когда один файл включается в другой с помощью
директивы `#include`, второй косвенно содержит все типы первого.
Чтобы отличить включённые типы от непосредственно определённых в данном файле
применяется `TypeReference`. Ссылка создаётся для каждого включённого типа,
включая те, которые уже были ссылками.
Такой подход даёт возможность при генерации кода
однозначно определить следует ли сгенерировать непосредственное
определение типа по шаблону, или сгенерировать включение заголовочного
файла, где он определён.

Одним из направлений дальнейших исследований является синтаксический
анализ файлов QEMU с целью автоматического создания объектов,
описывающих существующие типы. В настоящий момент такая функциональность
реализована только для макросов препроцессора и опирается на функционал
модифицированного препроцессора из библиотеки PyCParser.

Класс `Variable` (переменная) описывает пару: "тип, имя".
Если к переменной нужно добавить начальное значение, то применяется класс
`Initializer` (инициализатор).

Класс `Usage` (использование) применяется, когда требуется добавить
инициализатор к _типу_, а не к переменной.
Единственным примером в настоящее время является макрос.
Инициализатор используется для расстановки
значений при генерации вызова макроса.

Рассмотренная модель не является законченной. Но даже в таком варианте
она позволяет с достаточно гибкостью описывать шаблоны устройств и ВМ,
используемые при генерации интерфейсной части их кода. Развитие
этой модели является направлением дальнейших исследований.
<!--+ модель Си и препроцессора, элементы интерфейса добавления шаблонов +-->


<!--- шаблон, форматная строка, модель Си и препроцессора,
двоичный транслятор QEMU --->
###<a name="Codegeneration"></a> $.$ Генерация кода

Генерация кода заключается в получении из шаблонов фрагментов кода и
объединение их в файлы. Причём полученные фрагменты должны быть упорядочены с
учётом многих тонкостей.
Для этого была разработана вспомогательная модель файла с исходным кодом.
Она оперирует неделимыми текстовыми
фрагментами, из которых состоит файл, и порядковыми связями между ними.
Элементы этой модели конструируются из элементов модели языка Си и
препроцессора.

#### Модель файла с исходным кодом

Описанная выше модель языка Си и препроцессора не обеспечивает генерацию
синтаксически корректного файла. Её задача: сгенерировать законченные
_фрагменты_ генерируемого файла. При этом остаётся решить следующие
задачи:

* расположить фрагменты в синтаксически корректном порядке;
* обеспечить смысловую группировку фрагментов;
* соблюсти требования стиля программирования QEMU;
* минимизировать количество директив включения заголовков и др.

Далее эти задачи рассматриваются подробнее.

#### Сортировка фрагментов

Язык Си накладывает жесткие ограничения на порядок
определения различных символов. Например, тип должен быть объявлен
до того, как будет создана переменная этого типа, или будет
объявлена функция, принимающая аргумент такого типа. Подробное
рассмотрение всех возможных примеров выходит за пределы данной статьи.
Важно заметить, что почти все фрагменты связаны друг с другом, образуя
ациклический граф, и для обеспечения синтаксически корректного порядка
используется топологическая сортировка.

Помимо требований синтаксиса есть требования стиля программирования и
здравого смысла, согласно которым, фрагменты должны следовать в
следующем порядке:

1. включение заголовков;
2. объявление типов языка Си и макросов;
3. объявления функций;
4. определение функций, глобальных переменных и прочий код.

#### Учёт зависимостей и взаимосвязь с существующим кодом

Как уже отмечалось, для обеспечения видимости символов, объявленных в
других файлах, генерируются директивы `include`. При этом имеется ряд
тонкостей. Например, заголовочные файлы сами используют `include` для
подключения других файлов, поэтому подключение одного файла может заменить
подключение нескольких.

Эта особенность используется инструментом для сокращения количества
подключаемых заголовков на основе анализа графа включения заголовков.
Граф строится автоматически с использованием модифицированного
препроцессора из библиотеки PyCParser.

Инструмент учитывает и другие особенности, рассмотрение которых выходит за
рамки данной статьи.
<!--+ детали генерации кода +-->


<!--- GNU Make, bash, QEMU --->
#### Встраивание кода в QEMU

Для добавления заготовки устройства или платформы в QEMU кроме создания
соответствующего исходного кода на Си, нужно зарегистрировать новые
модули компиляции в системе сборки. Инструмент имеет соответствующую
функциональность.
<!--+ детали встраивания в QEMU +-->


<!--- QEMU, Git, SHA1, граф, Python, шаблон, целое число, модуль (Python),
класс (Python) --->
#### Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие шаблоны несовместимыми с
новой версией.

Для решения этой проблемы используется эвристический подход. Все аспекты
поведения инструмента, зависящие от версии QEMU, называются _эвристиками_.
Так как один аспект работы может меняться многократно, то каждая эвристика
представлена одной или несколькими записями в базе данных.

Код инструмента получает доступ к требуемой эвристике по _строковому
ключу_ --- уникальному имени эвристики.
Значением эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая запись об эвристике имеет как минимум два значения: _новое_ и _старое_.
Запись привязывается к SHA1-идентификатору изменения в Git-графе
[[$](#ref.Git)] истории QEMU.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей. Хранение обоих значений в каждой записи об эвристике избыточно. Но эта
избыточность используется для проверки непротиворечивости записей.
<!--+ эвристика, ключ эвристики, значение эвристики,
запись об изменении значения эвристики +-->


<!-- интерфейс использования шаблонов, лексическая ошибка (Python),
имя переменной, синтаксическая ошибка (Python), QEMU, марос, параметр шаблона
стиль программирования QEMU, виджет, ВВМ, аббревиатура ГИП -->
### $.$ Графический интерфейс пользователя

Все возможности инструмента доступны разработчику посредством интерфейса
использования шаблонов.
Для описания устройств и ВВМ достаточно произвольного текстового редактора.
Однако применение ГИП, спроектированного _специально_ для работы с этим
интерфейсом, имеет следующие преимущества.

* Исключены лексические в именах переменных, названиях элементов интерфейса, а
также синтаксические ошибки: разработчик вводит только значения параметров.

* Для многих значений параметров в QEMU определены макросы, использование
которых предпочтительнее, согласно стилю программирования QEMU.
ГИП интерфейс, проанализировав код QEMU, может предоставить разработчику
список доступных макросов, обычно применяемых с данным типом параметра.
Например:

    * идентификатор PCI,
    * имя типа QOM,
    * список свойств выбранного устройства и т.п.

* Исключены некоторые семантические ошибки (например, в ГИП не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как разработчик волен написать всё, что угодно в текстовом редакторе).
Имеется возможность дополнить ГИП средствами поиска менее очевидных
семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ и сопровождаются
названиями на естественном языке.
В большинстве случаев знания QEMU достаточно, чтобы понять суть параметра,
не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.
Эта возможность особенно актуальна при разработке многоэлементных ВВМ с
большим количеством связей, так как на схеме легче ориентироваться, чем в
тексте.

Для реализации ГИП инструмент использует API Tkinter[[$](#ref.Tkinter)].
Данный интерфейс содержит всё необходимую функциональность и прост в
развёртывании, так как включён в дистрибутивы Python.

<!--+ ГИП, Tkinter +-->

## $. Автоматизированная разработка моделей устройств и машин

Разработка моделей устройств и ВМ --- это два разных вида процессов.
Однако процесс разработки модели ВМ часто проходит одновременно и
взаимосвязанно с процессами разработки устройств, входящих в эту машину.
Далее эти процессы рассматриваются подробно с акцентом на применение
инструмента автоматизации, разработанного в рамках данной работы.

### $.$ Процесс разработки модели устройства

Общее время затрачиваемое на создание модели устройства
в течение автоматизированного подхода
складывается из этапов: _ознакомления_ с информацией об устройстве,
_подготовке_ инфраструктуры эмулятора к добавлению модели, _генерации_
заготовки и _реализации_.

#### Ознакомление с имеющейся информацией об устройстве

На этом этапе разработчик должен получить следующую информацию.

*   тип шины, на которую подключается устройство (в данной работе
    подразумеваются только системная шина и PCI);
*   перечень внешних интерфейсов, через которые устройство взаимодействует
    с внешним миром, например:

    *   поточный (символьный или байтовый) канал;
    *   носитель информации, допускающий доступ к произвольным адресам;
    *   сетевой интерфейс; и др.;

*   перечень периодических событий в логике работы;
*   количество входящих и исходящих прерываний;
*   количество групп регистров для чтения и/или записи;
*   значения идентификаторов (для PCI);
*   имя нового типа QOM для этого устройства;
*   имя папки в QEMU, соответствующей семантике устройства.

#### Подготовка эмулятора

Почти весь код модели может быть написан на этапе реализации. Однако, ввиду
того что инструмент получает часть информации из кода QEMU в процессе генерации,
соответствующие изменения нужно произвести заранее.
В настоящее время инструмент анализирует код QEMU не глубже уровня
препроцессора.
Поэтому на этапе подготовки нужно вносить изменения, влияющие на состав
заголовков и связи между ними.
Например, добавление идентификаторов PCI для добавляемого устройств.

#### Генерация заготовки для устройства

В течение этого этапа разработчик должен
создать компилируемый код, учитывающий полученную на предыдущем этапе
информацию. При наличии возможности, следует внедрить устройство в ВМ, и,
запустив гостевое ПО, удостовериться, что оно пытается взаимодействовать с
устройством. Сбои и отказы в работе ПО ожидаемы, так устройство не
реализовано. Однако сбои и отказы в работе самого эмулятора свидетельствуют
об ошибках программиста, допущенных в течение предыдущей работы. Они должны
быть решены до перехода на следующий этап.

Разработанный инструмент ориентирован на автоматизацию этого этапа.
Использование инструмента состоит в выполнении следующих действий.

*   внесение информации с предыдущего этапа в настройки генерации;
*   генерация кода;
*   тестирование сгенерированного кода и возможная корректировка
    инструмента.

При обнаружении ошибок, вызванных несоответствием инструмента и QEMU,
разработчик должен идентифицировать изменения, произошедшие в QEMU, и
внести их в набор эвристик. Необходимость добавления эвристик в инструмент
смягчается их перманентностью: каждую корректировку нужно внести
однократно.

#### Реализация индивидуальной части устройства.

Этот этап выполняется _итеративно_. Одна итерация включает:

*   реализация _части_ логики устройства;
*   тестирование реализованной части вплоть до исправления основных ошибок;

Размер части которую нужно реализовать за одну итерацию должен быть
выбран разработчиком по своему усмотрению. Часто для исправления всех
ошибок требуется реализовать оставшиеся части. Такие ошибки можно
отложить на последующие итерации, но соответствующие части нужно
реализовывать в первую очередь.

При тестировании на каждой итерации важную роль играет качество тестового
ПО. Вопрос, касающиеся тестового ПО, выходят за рамки настоящей работы.
Однако стоит перечислить средства, имеющиеся в QEMU.

*   GDB-сервер, реализующий протокол remote GDB для контроля гостевого ПО.
    Он позволяет проверять поведение устройства с точки зрения тестового ПО.
*   Можно использовать отладчик применительно к самому эмулятору. Но
    возможны проблемы с задержками в протоколе GDB, если необходимо
    одновременно контролировать и эмулятор, и гостевое ПО.

С версии 2.8 в QEMU была добавлена технология детерминированного
воспроизведения [[$](#ref.DetReplay)]. Выбранный подход к
реализации этой технологии требует от
разработчика устройства внимания к тому, что его устройство функционирует
детерминировано в рамках данного подхода. Подробное рассмотрение
правил, которых должен придерживаться разработчик, выходит за рамки данной
работы. Так или иначе, на каждой итерации следует хотя бы раз
воспользоваться технологией и убедиться в отсутствии расхождений при
воспроизведении.
Кроме того, отладка детерминированной модели принципиально легче.

Этот этап, в идеале, не заканчивается никогда. Практически, устройство
можно считать реализованным, когда в нём перестают проявляться ошибки
влияющие на работу _интересующего_ ПО. Опыт показывает, что глубина
проработки модели непосредственно определяется производственными нуждами и
экономической целесообразностью повышения качества модели.
Хорошим показателем является принятие модели устройства сообществом
разработчиков QEMU.

### $.$ Процесс разработки ВВМ

Разработка ВВМ включает разработку недостающих моделей устройств.
В особо сложном случае требуется разработка поддержки архитектуры процессора.
Исследование подходов к автоматизации этого случая является направлением
дальнейших исследований. Это выходит за рамки данной работы.

Разработка модели ВВМ состоит из таких же этапов, что и разработка устройства.
Более того, при совместной разработке в рамках предлагаемого подхода этап
генерации совпадает по времени у ВВМ и всех новых устройств.

#### Ознакомление с имеющейся информацией о платформе

На этом этапе нужно получить следующую информацию.

* Перечень устройств. Для каждого устройства важно понять, имеется ли в QEMU
его реализация. Наличие аналога следует рассматривать как отсутствие самого
устройства с той разницей, что разработка этого устройства будет ускорена.

* Перечень шин. Эта информация может быть получена на основе анализа
устройств, являющихся мостами между разными шинами. Наличие в платформе
шины, не реализованной в QEMU значительно усложняет разработку, т.к. придётся
разрабатывать эмуляцию такой шины. Автоматизация создания нового типа шины
является направлением дальнейших исследований и выходит за рамки данной работы.

* Распределение устройств по шинам. К этой информации также относятся адреса,
которые имеют устройства на своих шинах.

* Перечень линий прерываний и прочей сигнализации, выходящей за пределы той,
что уже реализована в шине. В большинстве случаев это касается только
прерываний между устройствами системной шины, т.к. она не инкапсулирует этот
механизм.

* Перечень внешних интерфейсов. Сюда относятся порты сетевых адаптеров, УАПП и
носители для ПЗУ.

#### Генерация заготовок недостающих устройств и ВВМ

Имея полный перечень устройств (или их заготовок) можно получить
заготовку ВВМ.
Разработанный инструмент позволяет выполнить большую часть этого этапа с
использованием схематичного представления ВВМ.
Используя информацию, полученную на этапе ознакомления, нужно сгенерировать
функцию инициализации машины QEMU, указав на схеме все элементы (устройства,
шины и внешние интерфейсы) и связи между ними.
Разумеется, в настройки генерации нужно добавить и все новые устройства.

Корректность функции инициализации будет проверяться в течение разработки
всех устройств (выполнения этапа реализации). В случае обнаружения ошибок
в схеме ВВМ, их нужно исправлять уже непосредственно в сгенерированном коде,
поскольку инструмент не поддерживает обратную связь.
Для сокращения количества таких ошибок рекомендуется внимательней выполнять
этап ознакомления.

#### Реализация ВВМ

Инструмент генерирует функцию инициализации машины и интерфейсный код.
От разработчика требуется:

* уточнение интеграции процессора (т.к. процессоры часто имеют очень
нетривиальный механизм инициализации);
* связывание CLI со свойствами устройств (ПЗУ, ОЗУ, периферийные интерфейсы и
пр.);
* реализация прочей индивидуальной логики.

## $. Экспериментальные результаты

Для проверки состоятельности предложенного подхода с помощью разработанного
инструмента были реализованы две ВВМ:

* IBM PC совместимая машина "Q35" на базе одноимённого набора микроконтроллеров
фирмы Intel;
* криптомаршрутизатор СISCO серии 2600 (C2621XM).

В качестве основной метрики эффективности автоматизации было выбрано количество
строк.
Подсчёты производились по истории Git и сгруппированы поэтапно.
Замеры производились по разнице между начальной и конечной версией каждого
этапа.
Кроме этого для каждой ВВМ приведена суммарная разница между базовой версией
QEMU и полностью реализованной машиной.
Важно иметь ввиду, что в приведённой ниже статистике изменение одной строки
представлено как 1 удаление и 1 добавление.
Такова особенность Git.

### $.$ Q35

За основу Q35 была взята её реализация, уже имеющаяся в QEMU версии 2.9.5.
Целью данного эксперимента была проверка возможностей разработанного
инструмента.
Выбор Q35 обусловлен тем, что эта машина является одной из самых сложных машин,
реализованных в QEMU.

В ходе анализа исходного кода реализации Q35 был составлен перечень устройств и
выявлена их взаимосвязь.
Эти данные были формально описаны средствами разработанного инструмента.
Полученная схема ВМ представлена на рисунке [$](#pic.Q35).

![Рисунок <a name="pic.Q35">$</a> --- Схема ВМ Q35](Q35.png)

Поскольку реализация Q35 не полностью соответствует всем требованиям QEMU,
потребовался подготовительный этап.
На этапе подготовки в QEMU вносились изменения, которые могут ограничить
возможности инструмента:

* в заголовочный файл вынесена структура, описывающая устройство MC146818 RTC
и макрос динамического приведения к типу данного устройства;
* добавлены функции инициализации глобальных переменных `slave_pic` и `isa_pic`,
в которые записываются ссылки на два устройства "i8259".

На этапе генерации с помощью инструмента были сгенерированы заготовки ВВМ Q35 и
трёх устройств, входящих в её состав: "A20 line", "port 80" и "port F0".
В оригинальной ВВМ Q35 эти устройства реализованы в коде самой машины.

На этапе реализации в заготовку ВВМ были внесены следующие изменения:

* добавлен процессор;
* добавлена настройка BIOS;
* добавлен режим совместимости MSDOS с исключениями FPU;
* выделена память под eeprom;
* добавлены к машине свойства, хранящие указатели на объекты устройств
IOAPIC и PCI HOST;
* произведена инициализация ICH9 PM;
* произведена инициализация IDE;
* произведена инициализация PC CMOS;
* произведена инициализация VGA;
* произведена инициализация NIC;
* произведена инициализация ACPI;
* скорректированы имена переменных.

Необходимость инициализации некоторых устройств на этапе реализации
связана с тем, что эти устройства поддерживают настройку посредством CLI.

В таблице [$](#tbl.Q35_statistic) приведены оценки объёма работы по реализации
Q35.

Таблица <a name="tbl.Q35_statistic">$</a>. Оценка объёма реализации Q35

+------------+------------------+-----------------+---------------+
| Этап       | Затронуто файлов | Вставлено строк | Удалено строк |
+============+==================+=================+===============+
| Подготовка | 4                | 42              | 31            |
+------------+------------------+-----------------+---------------+
| Генерация  | 8                | 599             | 0             |
+------------+------------------+-----------------+---------------+
| Реализация | 5                | 162             | 93            |
+------------+------------------+-----------------+---------------+
| Суммарно   | 12               | 803             | 31            |
+------------+------------------+-----------------+---------------+

Стоит заметить, что в настоящее время инструмент не поддерживает группировку
связанных по смыслу переменных в массивы и инициализацию их в цикле.
Ввиду этого, инициализация прерываний была вынесена на этап реализации. Это
позволило произвести регистрацию прерываний в цикле, тем самым обеспечив
краткость кода ВВМ. Инициализация прерываний заняла 20 строк кода, что
составляет менее 3% от кода всей модели.

Таким образом, приблизительно 75% кода платформы было сгенерировано
автоматически и лишь 11% пришлось модифицировать.

Итоговая версия платформы Q35 была успешно протестирована.
Тестирование состояло из загрузки ОС Windows7 и запуска Internet Explorer с
последующим открытием страницы `google.com`.

### $.$ C2621XM

За основу C2621XM взята его реализация из эмулятора Dynamips
[[$](#ref.Dynamips)].
Последний распространяется с открытым исходным кодом.
Его разработка на данный момент заморожена, если не считать проект
GNS3 [[$](#ref.GNS3)], который использует Dynamips для эмуляции маршрутизаторов,
коммутаторов и концентраторов, исправляя в нём ошибки.

На этапе подготовки в QEMU вносились следующие изменения:

* реализован MMU;
* реализована внутренняя коммутация прерываний процессора;
* исправлены некоторые регистры процессора специального назначения согласно с
документацией [[$](#ref.MPC860)];
* добавлены идентификаторы новых PCI устройств.

Первые два изменения позволили использовать процессор в режиме полносистемной
эмуляции: до этого поддерживалась только эмуляция ABI ОС.

На этапе ознакомления, исходя из анализа исходного кода Dynamips, был
составлен перечень устройств и выявлена их взаимосвязь.
Схема ВВМ представлена на рисунке [$](#pic.C2621XM).

![Рисунок <a name="pic.C2621XM">$</a> --- Схема маршрутизатора C2621XM](C2600.png)

Начальной версией QEMU был выбран последний на тот момент выпуск 2.9.0.
Все устройства, использованные в C2621XM, отсутствовали в QEMU, и были
перенесены из Dynamips.
При этом все заготовки были сгенерированы с помощью инструмента.
В таблице [$](#tbl.C2621XM_devices) приведена обзорная информация по элементам
C2621XM.
Сразу стоит отметить, что все эти устройства в Dynamips и, как следствие, их
перенесённые в QEMU версии реализованы не полноценно, а лишь до той степени,
чтобы удовлетворять потребностям некоторых версий системного ПО.

Таблица <a name="tbl.C2621XM_devices">$</a>. Элементы C2621XM

+-------------------+----------------------------------------------------------+
|       Тип         |                         Описание                         |
+===================+==========================================================+
| `MPC860`          | Процессор с системой команд PowerPC из одноимённого МК.  |
+-------------------+----------------------------------------------------------+
| `MPC860_IC`       | Контроллер прерываний. Поддерживает маскировку           |
|                   | прерываний.                                              |
+-------------------+----------------------------------------------------------+
| `MPC860_CPM`      | Маршрутизатор прерываний, позволяющий программно         |
|                   | перенаправить прерывания на другие номера. Стоит между IC|
|                   | и некоторыми из устройств.                               |
+-------------------+----------------------------------------------------------+
| `MPC860_SCC`      | Заглушка неизвестного устройства, предположительно       |
|                   | применяемо для пакетного обмена данными. В данном случае |
|                   | этот функционал не требуется.                            |
+-------------------+----------------------------------------------------------+
| `MPC860_DMA`      | Связка из двух устройств осуществляющая копирование      |
|                   | данных без участия процессора. Фактически используется   |
| `MPC860_PORT`     | для копирования данных между буферами сетевого адаптера и|
|                   | ОС.                                                      |
+-------------------+----------------------------------------------------------+
| `MPC860_WDT`      | Заглушка сторожевого таймера.                            |
+-------------------+----------------------------------------------------------+
| `C2600_IO_FPGA`   | Устройство служит аккумулятором прерываний от шины PCI,  |
|                   | на которой, фактически, размещаются только сетевые       |
|                   | адаптеры, и предоставляет доступ к EEPROM, с             |
|                   | идентификационной информацией об установленных сетевых   |
|                   | адаптерах.                                               |
+-------------------+----------------------------------------------------------+
| `CISCO_NVRAM`     | ПЗУ используемое для хранения настроек маршрутизатора.   |
+-------------------+----------------------------------------------------------+
| `CISCO_REMOTE`    | Устройство предоставляет интерфейс для получения         |
|                   | информации о системе:                                    |
|                   |                                                          |
|                   | * объём ОЗУ,                                             |
|                   | * объём ПЗУ (NVRAM),                                     |
|                   | * вариант платформы (в данном случае C2621XM);           |
|                   |                                                          |
|                   | а также позволяет хранить данные с доступом по ключу.    |
+-------------------+----------------------------------------------------------+
| `8MB_BOOTFLASH`   | ПЗУ фиксированного размера 8МиБ неизвестного             |
|                   | назначения.                                              |
+-------------------+----------------------------------------------------------+
| `NS16552`         | УАПП с двумя портами, именуемыми "con" и "aux". Через эти|
|                   | порты осуществляется настройка маршрутизатора.           |
+-------------------+----------------------------------------------------------+
| `PPC32_PIT`       | Таймер, посылающий прерывания с частотой 250 Гц.         |
+-------------------+----------------------------------------------------------+
| `C2600_PCI_HOST`  | Главный мост PCI и его конфигурационное пространство.    |
|                   | Отличительной особенностью является наличие 8 выделенных |
| `C2600_PCI`       | линий прерываний вместо стандартных 4.                   |
+-------------------+----------------------------------------------------------+
| `AM79C971`        | Сетевой адаптер PCI. В QEMU уже имеется его двойник с    |
|                   | именем `pcnet`. Но особенности реализации сильно         |
|                   | отличаются, поэтому данное устройство было реализовано   |
|                   | исключительно на основе Dynamips.                        |
+-------------------+----------------------------------------------------------+

На этапе реализации была перенесена индивидуальная часть устройств из
Dynamips, а также скорректирована заготовка ВМ.
Корректировка ВМ, в основном, заключалась в следующем:

* связка параметров ВМ с CLI QEMU:
    * образы ПЗУ,
    * подключение сетевых интерфейсов,
    * подключение символьных устройств;
* реализация специального кода;
* корректировка имён переменных.

В таблице [$](#tbl.C2621XM_statistic) приведена оценка объёма работы.

Таблица <a name="tbl.C2621XM_statistic">$</a>. Оценка объёма реализации C2621XM

+------------+------------------+-----------------+---------------+
| Этап       | Затронуто файлов | Вставлено строк | Удалено строк |
+============+==================+=================+===============+
| Подготовка | 8                | 128             | 35            |
+------------+------------------+-----------------+---------------+
| Генерация  | 37               | 2186            | 0             |
+------------+------------------+-----------------+---------------+
| Реализация | 31               | 4747            | 419           |
+------------+------------------+-----------------+---------------+
| Суммарно   | 45               | 6642            | 35            |
+------------+------------------+-----------------+---------------+

Таким образом, приблизительно 1/3 кода всего маршрутизатора была
сгенерирована автоматически.
Причём только 1/5 часть сгенерированного кода потребовала модификации.
Итоговая версия маршрутизатора была успешно настроена для маршрутизации пакетов
между двумя сетями (по одной на каждый интерфейс) и обеспечивала стабильное
соединение в течении тестового времени (приблизительно 12 часов).
В качестве генератора трафика использовалась утилита `ping`, настроенная на
отправку ICMP запросов длиной 60кБ и 50кБ с машин из противоположных сетей.
Сбоев замечено не было.
Среднее время запроса 12мс.

## $. Заключение

В ходе данной работы был проанализирован процесс разработки моделей устройств и
ВМ для эмулятора QEMU.
В изученном процессе был выделен рутинный начальный этап, хорошо поддающийся
формализации.
А именно, логику модели можно условно разделить на две части: индивидуальную и
интерфейсную.
Последняя служит прослойкой между индивидуальной частью и остальной
ВВМ, а также внешней средой.
При этом, интерфейсная часть содержит много формального кода, который
может быть сгенерирован по сравнительно небольшому количеству параметров.
Поверхностный анализ документации на устройство позволяет сформулировать эти
параметры.
Таким образом, в разработке устройства можно выделить промежуточный этап
между изучением документации и реализацией.
В течение этого этапа происходит генерация интерфейсного кода по заданному
набору параметров.

Был разработан программный инструмент, автоматизирующий этап генерации.
Инструмент поддерживает генерацию заготовок для устройств системной шины и
шины PCI.
Количество строк кода настройки генерации модели устройства в 11-25 раз
меньше количества строк получаемой заготовки.
Этот подход может быть применён не только к устройству, но и ко всей ВВМ в
целом.
Однако для ВВМ подобной разницы в количестве строк достичь не удалось,
ввиду того, что QEMU использует объектную модель для компоновки машин,
что уже является шагом в сторону сокращения объёма кода.
Однако по аналогии с этой объектной моделью в инструменте была разработана
схожая модель, которая позволила представить ВВМ в виде схемы в рамках
графического интерфейса пользователя.
Схема облегчает восприятие состава и связей ВВМ для разработчика.
Кроме того имеется возможность применить малые автоматизации компоновки ВВМ.
Предложенный подход пригоден как для полной реализации ВВМ вместе со всеми
устройствами (при условии, что в QEMU уже есть поддержка соответствующей
архитектуры процессора), так и для реализации ВВМ с использованием уже
имеющихся в QEMU устройств.

Инструмент был протестирован на двух ВВМ: IBM PC совместимая машина "Q35"
на базе Intel Q35 и машина "C2600", являющаяся криптомаршрутизатором фирмы
СISCO серии 2600 (C2621XM).
Они представляют две обозначенные крайности применимости данного инструмента.
А именно, для Q35 в QEMU уже присутствовали все требуемые устройства, хотя
некоторые из них пришлось привести в соответствие с требованиями
объектной модели QEMU, используя данный инструмент.
Для C2621XM, напротив, в QEMU отсутствовали все требуемые устройства.
Доля сгенерированного кода составляет от \(1/4\) до \(3/4\) в зависимости
от количества уже реализованных устройств.

Перспективными направлениями исследований являются:

* автоматизация разработки поддержки процессорной архитектуры, что позволило
бы полностью покрыть инструментом начальный этап разработки даже ВВМ с новой
для QEMU процессорной архитектурой;

* поддержка добавления новых стандартов шин и генерации заготовок для
устройств остальных, реже используемых шин, уже имеющихся в QEMU;

* развитие графического интерфейса пользователя с целью внедрения в него
малых автоматизаций, в совокупности облегчающих и ускоряющих процесс
разработки;

* реализация обратной связи о состоянии ВВМ из запущенного QEMU с
отображением информации времени выполнения на схеме ВМ, что позволит
использовать инструмент ещё и для отладки в течение цикла итеративной
разработки;
обратную связь предполагается организовать, запустив QEMU под отладчиком и
контролируя состояние переменных времени выполнения и потока управления;
поскольку инструмент сам генерирует код ВВМ, то информация, необходимая
для сопоставления переменных времени выполнения и элементов схемы ВМ для
него доступна.

## Использованные источники

$. <a name="ref.Git"></a>Страница системы контроля версий Git. Доступна по
ссылке: https://git-scm.com/about, 09.03.2017.

$. <a name="ref.Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". Доступна оп ссылке: https://wiki.python.org/moin/TkInter,
2017.03.13.

$. <a name="ref.PyCParser"></a>Страница библиотека PyCParser на GitHub.
Доступна по ссылке: https://github.com/eliben/pycparser, 20.03.2017.

$. <a name="ref.DetReplay"></a>V. Yu. Efimov, K. A. Batuzov, V. A. Padaryan,
A. I. Avetisyan. Features of the deterministic replay in the case of a
minimum device set. Programming and Computer Software, April 2016, Volume 42,
Issue 3, pp 174–186.

$. <a name="ref.Dynamips"></a>Руководство по работе с Dynamips. Доступно по
ссылке: http://www.iteasypass.com/Dynamips.htm, 30.06.2017.

$. <a name="ref.GNS3"></a>Страница инструмента эмуляции сети GNS3. Доступна по
ссылке https://gns3.com, 30.06.2017

$. <a name="ref.MPC860"></a>Руководство пользователя для микроконтроллеров
серии MPC860. Доступно по ссылке:
http://www.nxp.com/docs/en/reference-manual/MPC860UM.pdf, 30.06.2017

$. <a name="ref.Python"></a>Страница языка программирования Python. Доступна по
ссылке: https://www.python.org/, 06.07.2017.

$. <a name="ref.Dovgaluk"></a>ссылка на Довгалюк-статью

$. <a name="ref.QEMU"></a>Bellard F. QEMU, a Fast and Portable Dynamic
Translator. USENIX Annual Technical Conference, FREENIX Track. USENIX, 2007.
P. 41–465 p.

$. <a name="ref.remote_GDB"></a>J. Bennett. Howto: GDB Remote Serial Protocol.
Writing a RSP Server. Application Note 4. Issue 2, Embecosm, Доступно по ссылке:
http://www.embecosm.com/appnotes/ean4/embecosm-howto-rsp-server-ean4-issue-2.pdf,
ноябрь 2008.

$. <a name="ref.SimNow"></a> Страница AMD SimNow Simulator. Доступна по ссылке:
http://developer.amd.com/simnow-simulator/, 12.10.2017.

$. <a name="ref.Simics"></a> D. Aarno, J. Engblom. Software and System
Development using Virtual Platforms. Full-System Simulation with Wind River
Simics. Elsevier Inc. 15.09.2014. 366c.

$. <a name="ref.gem5"></a> N. Binkert, B. Beckmann, G. Black, S.K. Reinhardt,
A. Saidi, A. Basu, J. Hestness, D.R. Hower, T. Krishna, S. Sardashti, R. Sen,
K. Sewell, M. Shoaib, N. Vaish, M.D. Hill, and D.A. Wood.
The gem5 simulator. SIGARCH Comput. Archit. News 39, 2, August 2011, 1-7.

$. <a name="ref.OVPsim"></a> Страница Open Virtual Platforms. Доступна по
ссылке: http://www.ovpworld.org/, 12.10.2017.

$. <a name="ref.SynopsysVP"></a> SynopsysVP

