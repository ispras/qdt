__all__ = [
    "cpp_lexer"
  , "cpp_parser"
]

from common import (
    def_tokens,
    unify_rules,
    make_count_columns
)
from ply.lex import (
    lex
)
from ply.yacc import (
    yacc
)

# This language corresponds to 3-nd and 4-th translation phases defined by
# 5.1.1.2 of ISO/IEC 9899:202x (~C 17)

for d in ["if", "ifdef", "ifndef", "elif", "else", "endif", "include",
    "define", "undef", "line", "error", "pragma"
]:
    code = """
def t_{D}(t):
    r"\\#\\s*{d}(?=\\s)"
    t.tags = ("keyword",)
    t.lexer.columnno += len(t.value)
    return t
""".format(
        d = d,
        D = d.upper()
    )
    exec(code)

def t_DEF_ID(t):
    r"\w+(?!\s)"
    t.lexer.columnno += len(t.value)
    t.tags = ("id",)
    return t

for kw in [ "defined", "sizeof" ]:
    code = """
def t_{KW}(t):
    r"{kw}(?=\\s)"
    t.tags = ("keyword",)
    t.lexer.columnno += len(t.value)
    return t
""".format(
        kw = kw,
        KW = kw.upper()
    )
    exec(code)

def t_ID(t):
    r"\w+"
    t.lexer.columnno += len(t.value)
    t.tags = ("id",)
    return t

def t_NL(t):
    r"\n+"
    t.lexer.lineno += len(t.value)
    t.lexer.columnno = 1
    return t


t_COLON = r':'
t_COMMA = r","
t_CONDOP = r'\?'
t_DOTS = r"\.\.\."
t_LPAREN = r"\("
t_RPAREN = r"\)"
t_LBRACKET = r'\['
t_RBRACKET = r'\]'
t_LBRACE = r'\{'
t_RBRACE = r'\}'

# multiplicative operators
t_TIMES = r'\*'
t_DIVIDE = r'/'
t_MOD = r'%'

# additive operators
t_PLUS = r'\+'
t_MINUS = r'-'

# logical operators
t_LAND = r'&&'
t_LOR = r'\|\|'
t_LNOT = r'!'

# bit logic operators
t_AND = r'&'
t_OR = r'\|'
t_XOR = r'\^'
t_NOT = r'~'

# bit shift operators
t_LSHIFT = r'<<'
t_RSHIFT = r'>>'

# relational operators
t_LT = r'<'
t_GT = r'>'
t_LE = r'<='
t_GE = r'>='

# equality operators
t_EQ = r'=='
t_NE = r'!='

# Increment/decrement
t_PLUSPLUS = r'\+\+'
t_MINUSMINUS = r'--'

make_count_columns(globals())

def_tokens(globals())

# ignore whitespaces
t_ignore = " \t"

def t_error(t):
    raise AssertionError("How could this happen?")

cpp_lexer = lex()

def p_preprocessing_file(p):
    ": group_opt"

def p_group_opt(p):
    """ :
        | group
    """

def p_group(p):
    """ : group_part
        | group group_part
    """

def p_group_part(p):
    """ : if_section
        | control_line
        | text_line
    """
    # | # non-directive

def p_if_section(p):
    """ : if_group ENDIF NL
        | if_group elif_groups ENDIF NL
        | if_group else_group ENDIF NL
        | if_group elif_groups else_group ENDIF NL
    """

def p_if_group(p):
    ": if_group_heading group_opt"

def p_if_group_heading(p):
    """ : IF const_expr NL
        | IFDEF ID NL
        | IFNDEF ID NL
    """

def p_elif_groups(p):
    """ : elif_group
        | elif_groups elif_group
    """

def p_elif_group(p):
    ": ELIF const_expr NL group_opt"

def p_else_group(p):
    ": ELSE NL group_opt"

def p_pp_tokens_opt(p):
    """ :
        | pp_tokens
    """

def p_pp_tokens(p):
    """ : preprocessing_token
        | pp_tokens preprocessing_token
    """

def p_control_line(p):
    """ : INCLUDE pp_tokens NL
        | DEFINE ID replacement_list NL
        | DEFINE def_id id_list RPAREN replacement_list NL
        | DEFINE def_id DOTS RPAREN replacement_list NL
        | DEFINE def_id id_list COMMA DOTS RPAREN replacement_list NL
        | UNDEF ID NL
        | LINE pp_tokens NL
        | ERROR pp_tokens_opt NL
        | PRAGMA pp_tokens_opt NL
        | NL
    """

def p_def_id(p):
    ": DEF_ID LPAREN"

def p_text_line(p):
    ": pp_tokens_opt NL"

def p_replacement_list(p):
    ": pp_tokens_opt"

def p_id_list(p):
    """ : ID
        | id_list COMMA ID
    """

def p_expr(p):
    ": cond_expr"
    # XXX: check it

def p_const_expr(p):
    ": cond_expr"

def p_cond_expr(p):
    """ : logical_or_expr
        | logical_or_expr CONDOP expr COLON cond_expr
    """

def p_logical_or_expr(p):
    """ : logical_and_expr
        | logical_or_expr LOR logical_and_expr
    """

def p_logical_and_expression(p):
    """ logical_and_expr : inclusive_or_expr
                         | logical_and_expr LAND inclusive_or_expr
    """

def p_inclusive_or_expr(p):
    """ : exclusive_or_expr
        | inclusive_or_expr OR exclusive_or_expr
    """

def p_exclusive_or_expr(p):
    """ : and_expr
        | exclusive_or_expr XOR and_expr
    """

def p_and_expr(p):
    """ : equality_expr
        | and_expr AND equality_expr
    """

def p_equality_expr(p):
    """ : relational_expr
        | equality_expr EQ relational_expr
        | equality_expr NE relational_expr
    """

def p_relational_expr(p):
    """ : shift_expr
        | relational_expr LT shift_expr
        | relational_expr GT shift_expr
        | relational_expr LE shift_expr
        | relational_expr GE shift_expr
    """

def p_shift_expr(p):
    """ : additive_expr
        | shift_expr LSHIFT additive_expr
        | shift_expr RSHIFT additive_expr
    """

def p_additive_expr(p):
    """ : multiplicative_expr
        | additive_expr PLUS multiplicative_expr
        | additive_expr MINUS multiplicative_expr
    """

def p_multiplicative_expr(p):
    """ : cast_expr
        | multiplicative_expr TIMES cast_expr
        | multiplicative_expr DIVIDE cast_expr
        | multiplicative_expr MOD cast_expr
    """

def p_cast_expr(p):
    """ : unary_expr
        | LPAREN type_name RPAREN cast_expr
    """

def p_type_name(p):
    ": ID"

def p_unary_expr(p):
    """ : postfix_expr
        | PLUSPLUS unary_expr
        | MINUS unary_expr
        | unary_op cast_expr
        | SIZEOF unary_expr
        | SIZEOF LPAREN type_name RPAREN
    """

def p_unary_op(p):
    """ : AND
        | TIMES
        | PLUS
        | MINUS
        | NOT
        | LNOT
    """

def p_postfix_expr(p):
    """ : primary_expr
    """
    # TODO: p.75 of ISO/IEC 9899:202x

def p_primary_expr(p):
    """ : ID
        | const
        | LPAREN expr RPAREN
    """
    # TODO: p.56 of ISO/IEC 9899:202x


unify_rules(globals())

def p_error(p):
    raise ValueError("bad preprocessor syntax")

cpp_parser = yacc(write_tables = False)